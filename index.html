<!doctype html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<base target="_blank">

<title>Totally Not Scary Guide to Statistics</title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-59181255-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-59181255-1');
</script>


<link href="https://fonts.googleapis.com/css?family=Itim|Fira+Sans:300,700" rel="stylesheet">

<script src="js/lodash.min.js"></script>
<script src="js/d3.v5.min.js"></script>
<script src="js/vue.min.js"></script>
<script src="js/howler.min.js"></script>

<style>

*{
  font-family: 'Fira Sans', sans-serif;
  font-size: 18px;
  font-weight: 300;
}

.handwriting, .handwriting *{
  font-family: 'Itim';
}

.comment{
  font-family: 'Itim';
  font-size:14px;
  margin-left: 16px;  
}

.chapter-icon{
  max-width:50px; 
  max-height:70px;
  margin: 0 auto;
}

.tree-header{
  width: 80px;
  font-size: 12px;
  display: inline-block;
  text-align: center;
  background-color: black;
  font-weight: bold;
  color: white;
}

h2{
  font-family: 'Itim';
  font-size: 36px;  
  max-width: 600px;
  margin: 0 auto;
  margin-bottom: 16px;
  margin-top: 16px;
}

h4{
  font-family: 'Itim';
  font-size: 18px;  
  margin-top: 16px;  
  margin-bottom: 16px;
}

ul {
  list-style-type: square;
}

li, li * {
  font-size: 16px;
  margin-bottom: 8px;
}

.ev-answer-bar{
  transition: all 1s ease;
}

.hint, .hint *{
  font-size: 16px;
  margin: 8px;
  font-weight: 700;
  color: #777;
}

.bayes-comp{
  display: inline-block;
  position:relative;
  width: 120px;
  height: 300px;
  vertical-align: top;
  text-align: center;
}
.bayes-comp .label *{
  font-size: 14px;
  text-align: center;
}

.dot{
  border-radius: 50%;
  width: 12px;
  height: 12px;
  background-color: blue;
  cursor: ns-resize;
}

text{
  font-size: 10px;
}

div{
  margin-bottom: 16px;
}

.normal-div, .normal-div div{
  margin-bottom: 0px;
}

a{
  color: #337ab7; /* bootstrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}

button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px; 
  padding: 8px 16px;
  margin: 8px;
  max-width: 180px;
  display: inline-block;
}

.bold{
  font-weight: 700;
}
.smaller-children, .smaller-children *{
  font-size: 14px;
}

.cropcircle{
    width: 100px;
    height: 100px;
    border-radius: 100%;
    background-size: cover;
    border: 4px solid black;
    margin-right: 16px;
}

.coin{
  display: inline-block;
  width: 120px;
  cursor: pointer;
  vertical-align: top;
  word-wrap: break-word;
}

.no-select, .no-select *{
  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}

.sideways{
  transform: translateX(-50%) translateY(-50%) rotate(-90deg);
  position: absolute;
  top: 50%;
  left: 50%;
}

.toc-chapter{
  display: grid;
  grid-template-columns: 50px auto;
}

.toc-chapter:hover{
  background-color: #ddd;
}

.disabled, .disabled * { 
  pointer-events: none;
  user-select: none; 
}

/*.unused {
  color: red;
  opacity: 0.5;
}*/

.disabled .highlight{
  font-weight: bold;
}

svg *{
    font-family: 'Itim';
}
svg .emoji-outcome{
  font-size: 30px;
}

svg .emoji-branch{
  font-size: 16px;
}

svg .outcome{
  font-size: 30px;
}


.shrink .emoji-outcome{
  font-size: 20px;
}


.fulcrum {
  display: inline-block;
  color: white;
  width: 0; 
  height: 0; 
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;  
  border-bottom: 50px solid black;
}

.right-wobble{
  position: absolute;
  animation: rightwobble 1s ease 0s 1;
}
@keyframes rightwobble {
  0% {
    transform: rotate(0turn);
  }
  30% {
    transform: rotate(0.005turn);
  }
  100% {
    transform: rotate(0turn);
  }
}
.left-wobble{
  position: absolute;
  animation: leftwobble 0.5s ease 0s 1;
}
@keyframes leftwobble {
  0% {
    transform: rotate(0turn);
  }
  30% {
    transform: rotate(-0.01turn);
  }
  100% {
    transform: rotate(0turn);
  }
}


/*@media only screen and (max-width: 500px) {

}
*/

.navbar{
  width:60px;
  position: fixed; 
  top:0px; 
  left:0px; 
  width: 100%;
  text-align: center; 
  background-color: #eee;
}


</style>
</head>


<body>


<div id="app" @click="mainClick($event)">

  <div ref="toc" class="normal-div navbar" style="text-align: left; position:fixed; z-index: 1; display: grid; grid-auto-flow: column; padding-top:8px; ">

    <div style="display: inline-block; white-space: nowrap; margin-right:8px">
    <img @click="toggleTOC" 
         :src="showTOC ? 'images/x.png' : 'images/menu.png'"
         style="cursor: pointer; height: 28px; margin-left: 8px" >

    <img @click="toggleVolume" 
         :src="hasVolume ? 'images/volume.png' : 'images/volume_off.png'" 
         style="width:20px; padding-bottom: 4px; padding-left: 4px" >
     </div>

   <div class="handwriting" style="white-space: nowrap;display: inline-block; overflow: hidden">Totally Not Scary Guide to Statistics</div>

  </div> 


  <div v-if="showTOC" class="normal-div" style="position:fixed; z-index:1; width:150px;top:40px; left:0px;
    bottom:0;
overflow-y:auto;padding-top:8px; background-color: rgb(247,247,247);">
    <div v-for="(chapter, ind) in chapters"
         @click="showTOC = false; chapterInd = ind"
         class="toc-chapter"
         style="padding:4px">
      <img :src="'images/' + chapter.image" 
           class="chapter-icon">
      <span style="top:60px; font-size:12px; display: inline-block; margin:8px;"><bold style="font-size:12px">{{chapter.title || 'Chapter ' + ind}}</bold><br> {{chapter.description}}</span>
    </div>
  </div>

<!--left:calc(50% - 10px) -->
<keep-alive>
  <component v-bind:is="visibleScreen" :style="componentStyle" style="margin-top: 52px"></component>
</keep-alive>


</div> <!-- end #app -->



<script type="text/x-template" id="intro-to-pvalues-template">
<div>

<h2>Chapter 5: P-Values</h2>

<pset>

<avatar image="scroll.png">
  <div>
    This is a flashback to the recent past in which Elena was still with us...
  </div>
  <next>Next</next>
</avatar>

<avatar 
  text="Elena, my crow friend is really smart.">
  <next>Next</next>
</avatar>


<avatar 
  text="I'm going to get her evaluated by Wei the Scientist to see if her intelligence is statistically significant.">
  <next>Next</next>
</avatar>


<avatar image="scientist.png"
  text="My my, what a pretty little bird.">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw caw!">
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="I can certainly design an intelligence test worthy of this lovely creature.">
  <next>Next</next>
</avatar>

<avatar image="scientist.png">
  <div>
    Although, I guess the default belief is that you're just an average crow.
  </div>
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Cawwww (Don't insult my intelligence, human).">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    Another name for default belief is <bold>null hypothesis</bold>.
  </div>
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png">
  <div>My apologies, clever crow. I'm just trying to explain what a p-value is. A <bold>p-value</bold> is the probability that you'll see as extreme a result if the null hypothesis is true.</div>
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png"
  text="I ran Elena through my first battery of intelligence tests, and got a p-value of 0.6.">

  <div>
    What does a p-value of 0.6 mean?
  </div>

  <buton-group>
    <buton nope>There's a 60% chance that Elena is smarter than the average crow</buton>
    <buton nope>There's a 60% chance that Elena is an average crow</buton>
    <buton yay>There's a 60% chance of observing as extreme a result even if Elena is just an average crow</buton>

    <template v-slot:hint>
    P-values only speak about the probability of obtaining the results if the null hypothesis is true. It isn't the probability of the null hypothesis being correct, or the alternative hypothesis ("Elena is smarter than an average crow") being correct.
    </template>
  </buton-group>

</avatar>

<avatar image="scientist.png">
  <div>
    Correct. A P-value assumes the null hypothesis (aka that Elena is just an average crow) and says how extreme the results are under this assumption.
  </div>
  <next>Next</next>
</avatar>

<avatar  image="scientist.png"
  text="I ran Elena through a different intelligence test and got a p-value of 0.01. What does a p-value of 0.01 mean?">

  <buton-group>
    <buton yay>There's a 1% chance of observing as extreme a result even if Elena is just an average crow</buton>
    <buton nope>There's a 1% chance that Elena is an average crow</buton>
    <buton nope>There's a 1% chance that the results are due to chance</buton>

    <template v-slot:hint>
    P-values only speak about the probability of obtaining the results if the null hypothesis is true. It isn't the probability of the null hypothesis being correct, or the alternative hypothesis being correct.
    </template>
  </buton-group>
</avatar>

<avatar 
  image="scientist.png"
  text="For one of my experiments, what would be a more exciting result? A p-value of 0.01 or 0.001? ">

  <buton-group>
    <buton nope>0.01</buton>
    <buton yay>0.001</buton>

    <template v-slot:hint>
    A p-value of 0.01 would mean that there's a 1% chance that we would observe as extreme a result if the potion didn't work. While that's nice, it would be nicer if there were only a 0.1% chance that the result would occur.
    </template>
  </buton-group>
</avatar>

<avatar image="scientist.png">
  <div>
    Yes! We're hoping that Elena is smarter than an average crow, so a lower p-value is better. 
  </div>
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="Oh interesting...">
  <next>What?</next>
</avatar>

<avatar image="scientist.png"
  key="trap"
  text="Some other scientists have been testing unusual crows as well. One scientist found a crow that tested more intelligent than normal  at a p-value of 0.05. Another scientist found a crow that tested more intelligent than normal at a p-value of 0.1. Which crow do you think is smarter?">

  <buton-group>
    <buton nope>p<0.05 crow</buton>
    <buton nope>p<0.1 crow</buton>
    <buton yay>Not enough info</buton>
  </buton-group>

</avatar>


<avatar image="brain.png">
  <div>
    {{ got('trap') ? "Correct! There's not enough info." : 'Good attempt, but not quite.' }}  
  </div>

   <div>
    The surprising thing about p-values is that they don't say anything about <bold>effect size</bold>. The effect size is the actual difference in the measured quantity. A p-value just tells you how likely something is under the null hypothesis. 
  </div>
  <next>Next</next>
</avatar>


<avatar image="scientist.png">
  <div>
    The two other crows scored as such. Which one do you think is the smarter bird?
  </div>

<div style="margin-bottom:24px;">
<bold>Bird A</bold>
<div>Scores compared to average:
  <div style="font-size:14px">+2% +0% +6% +6% +8% +3% +4% +0% +9% +4% +7% +5% +9% +9% +4% +3% +7% +7% +1% +8% +3% +9% +5%</div>
</div>
<div>Average effect size: 5%</div>
<div>P-value: 0.05</div>
</div>


<div>
<bold>Bird B</bold>
<div>Scores compared to average:
  <div style="font-size:14px">+47% +46% +6% +0% -7% -3% +13% +0% -10% +28% -4% +30% +1% +48% +37% +26% +47% +46% -13% +15% +33% +33% +26% </div>
</div>
<div>Average effect size: 11% </div>
<div>P-value: 0.1</div>
</div>

<once-group>
  <next>Bird A</next>
  <next>Bird B</next>
</once-group>
</avatar>

<avatar image="brain.png" text="It's hard to say, right? It's possible to have a greater average effect size but a less compelling p-value.">
<next>Next</next>
</avatar>

<avatar text="I don't care about these other birds. What is Elena's p-value?">
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="Well, based on the exxperiments I've run so far... Elena's p-value is 0.14.">

  <next>Next</next>
</avatar>

<avatar text="WHAT!">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="CAW!??! (WHAT!??!)">
  <next>Next</next>
</avatar>

<avatar 
  image="scientist.png">

  <div>
    Scienitific journals usually require a p-value of 0.05 or smaller to publish. If a p-value is less than 0.05, it is called <bold>statistically significant</bold>. Experimenting with another battery of tests yielded a p-value of 0.14. Which is...
  </div>

  <buton nope>Statistically significant</buton>
  <buton yay>Not statistically significant</buton>
</avatar>


<avatar text="I DO NOT accept this!!!!">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Cawwww!! (Indeed, what a gross miscalculation!!)">
  <next>Next</next>
</avatar>


<avatar image="scientist.png">
  <div>
    Well "statistically significant" sounds really important, but it's just the scientific name for p-value less than a threshold. It's up to the domain expert to determine if the result is meaningful or not.
  </div>
  <next>Next</next>
</avatar>

<avatar text="I am SO OFFENDED (on Elena's behalf).">
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png"
  text="How should a p-value of 0.14 be interpreted?">

  <buton nope>Weak evidence that Elena is the same as an average crow</buton>
  <buton yay>Weak evidence that Elena is smarter than an average crow</buton>
  <buton nope>Strong evidence that Elena is the same as an average crow</buton>
  <buton nope>Strong evidence that Elena is smarter than an average crow</buton>

</avatar>

<avatar image="scientist.png">
  <div>
    Correct. Although a p-value of 0.14 does not meet the threshold for "statistical significance", it is still weak evidence that the results may be unusual under the null hypothesis (aka default world view). There was only a 14% chance that we would observe as extreme a result. 
  </div>

  <next>Next</next>
</avatar>

<avatar image="scientist.png">
  <div>
    When you get a borderline p-value like 0.14 it is worth investigating further, perhaps redesigning part of the experiment to better capture signal from the noise. 
  </div>
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw caw caw caw?? (Test me 10 more times!)">
  <next>Er...</next>
</avatar>


<avatar image="scientist.png">
  <div>
    I can't just randomly test you until I get a positive result. That is p-hacking like in the <a href="//xkcd.com/882/">xkcd green jelly bean case</a>.
  </div>
  <next>Next</next>
</avatar>


<avatar text="Well, I don't need a p-value to tell me that Elena is no average bird.">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw... (Sad...)">
  <next>Next</next>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>
  <ul>
    <li>The <bold>null hypothesis</bold> is the default belief (e.g. it's not possible to learn by drinking a potion).</li>
    <li>You learned that a <bold>p-value</bold> is the chance of witnessing as extreme an outcome under the null hypothesis.</li>
    <li>p-values below a threshold of 0.05 are called <bold>statistically significant</bold> but that does not mean it is necessarily useful.</li>
    <li>A smaller p-value does not imply a larger effect size.</li>
  </ul> 

  <buton @click.native="$root.nextChapter()">Next chapter?</buton>

</avatar>


</pset>
</div>
</script>


<script type="text/x-template" id="once-group-template">
<div :class="{disabled: isClicked}"><slot></slot></div>
</script>


<script type="text/x-template" id="intro-scene-template">
<div style="max-width:600px; margin: 0 auto; text-align:center;">

  <div class="handwriting" style="font-size:48px;">Totally Not Scary Guide to Statistics</div>

  <img src="images/wizard.png" style="max-width:280px">

  <div style="max-width:500px; margin: 0 auto">
    <div>
      <bold>Statistics is useful ‚Äî </bold> in daily life and machine learning. Approach this topic in a non-scary way... through weird stories, cartoon characters, and interactivity!
    </div>
  </div>


  <div>Expected playtime: <bold>60 min</bold></div>
  <buton @click.native="$root.nextChapter()" :font-size="28">PLAY</buton>
</div>
</script>

<script type="text/x-template" id="thanks-template">
<div style="max-width:400px; margin: 0 auto;" >

<h2>The End</h2>


<p>
  As you can see, life can be quite eventful with probability and statistics. I hope this guide helps add a bit of mischief to your life.
</p>

<img src="images/wizard.png" style="max-width:200px">



<p>
That's all the chapters for now, but the story may continue... Afterall, the wizard could do a whole section on useful distributions. 


<ul>
<li>Sign up to be notified of <a href="//eepurl.com/c8ur5T">future chapters</a></li>
<li>Or leave me some <a href="//forms.gle/QeUmVfvoxpNJMEcDA">feedback</a> on story so far</li>
</ul>
</p>


<p>
If you liked this story, you might like

<ul>
<li>My other story about thinking rationally <a href="//cassandraxia.com/cogbiases/">Adventures in Cognitive Biases</a></li>

<li>A much more comprehensive text covering much more statistics <a href="https://www.amazon.com/gp/product/1446210456/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1446210456&linkCode=as2&tag=cassandraxia-20&linkId=38c49070a217a5b8b289553486d6d721">An Adventure in Statistics: The Reality Enigma</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=cassandraxia-20&l=am2&o=1&a=1446210456" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>

<li>A very enlightening book on the parts of frequentist statistics that are used by real scientists <a href="https://www.amazon.com/gp/product/0321629302/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321629302&linkCode=as2&tag=cassandraxia-20&linkId=8acaf4f7bf04f2ff7ac0341e952c9670">What is a p-value anyway? 34 Stories to Help You Actually Understand Statistics</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=cassandraxia-20&l=am2&o=1&a=0321629302" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>

</p>


<h4>Music</h4>
<div class="smaller-children">
<p>
The sound for this story was graciously edited to be nonobtrusive by auditory doctor Hanoi Hantrakul.
</p>

<p>
Background pieces included those created by <a href="//plasterbrain.com">plasterbrain</a> including 'Rusted Maid', 'Extreme Hardcore Death Metal Loop', 'Comma Flaw', and 'Find My Body Please'. 
</p>

<p>
And two pieces from <a href="//filmmusic.io">https://filmmusic.io</a>
"Sneaky Snitch" and "Wholesome" by Kevin MacLeod (<a href="//incompetech.com">https://incompetech.com</a>)
License: CC BY (http://creativecommons.org/licenses/by/4.0/)
</p>
</div>


<h4>Thanks</h4>

<div class="smaller-children">

<p>
I want to thank my family who made me weird. I also want to thank... 
</p>

<p>
The backers and supporters of Timmy's Journey, including Vivek Rajkumar, Conrad Ho, Brienne and Eliezer Yudkowsky, Eric Chisholm, Alia McCutcheon and other folks from the LessWrong scene encouraged me to develop Adventures in Cognitive Biases further. Ruwen Liu contributed a few pieces of good art to this story and I found or drew the less artistic ones.
</p>

<!--wholesome-by-kevin-macleod_edit.wav
comma-flaw_edit.wav
extreme-hardcore-death-metal-loop_edit.wav
find-my-body-please_edit.wav
rusted-maid_edit.wav
sneaky-snitch-by-kevin-macleod_edit.wav
-->


<p>
<a href="//ncase.me/">Nicky Case</a> who created multiple examples for how to make experiences both fun and educational and built a community of excellent folks around it. Folks from the explorabl.es community provided valuable advice on how to improve the design including, Srini Kadamati, Zachary Steinberg, Philipp Legner, Amit Patel, and Philipp Wacker. 
</p>

<p><a href="//www.spencergreenberg.com/">Spencer Greenberg</a> and Mike Mozer resuscitated the project at points through their enthuasism and insightful critique. And thank you to all the folks who emailed in with encouragement and offers to help when earlier projects stagnated. 
</p>

<p>
Anand Babu and Google Kernel friends provided a safe space and the final push of energy to rewrite this. Ric Ewing designed Chapter 2 and taught me how to properly do paper prototypes. Fred Bertsch and Vivek Sri greatly improved the story in different ways. Kourosh Gharachorloo for all the bugs he found, and accidentally the most senior QA tester I've ever had. Tianyu Liu recommended the perfect pieces of prior work. Nathan Martz was the oracle who was right about all the pitfalls.
</p>

<p>
On the tech side, <a href="//vuejs.org/">Vue.js</a> greatly simplified the code needed for this project. I think it's better than React. I also want to thank jpegslayer who helped me on the friendly Vue forums.
</p>

<p>
If after all this, you're still here and want to buy me a coffee, that would be a great boost to my ego!
</p>

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_donations" />
<input type="hidden" name="business" value="cssndrx@gmail.com" />
<input type="hidden" name="currency_code" value="USD" />
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donate_SM.gif" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" />
</form>


</div>
</div>
</script>



<script type="text/x-template" id="next-template">
  <buton @click="next()"><slot></slot></buton>
</script>


<script type="text/x-template" id="ev-tree-template">
<svg height="100" width="90">
   <line x1="0" y1="55" x2="45" y2="20" style="stroke:#ddd;stroke-width:2" />
   <line x1="0" y1="55" x2="45" y2="90" style="stroke:#ddd;stroke-width:2" />

   <text class="outcome" x="50" y="30">{{prettyString(outcomes[0].payoff)}}</text>
   <text class="outcome" x="50" y="100">{{prettyString(outcomes[1].payoff)}}</text>

   <text class="branch" x="10" y="30" >{{$root.formatPct(outcomes[0].certainty)}}</text>
   <text class="emoji-branch" x="28" y="50">{{outcomes[0].emoji}}</text>

   <text class="emoji-branch" x="28" y="74">{{outcomes[1].emoji}}</text>
   <text class="branch" x="10" y="86">{{$root.formatPct(outcomes[1].certainty)}}</text>
</svg>
</script>


<script type="text/x-template" id="tree-node-template">
  <g>
   <line x1="0" :y1="height/2" :x2="lineX"" :y2="linePadding" style="stroke-width:2"
   :style="{stroke: color.indexOf('0') > -1 ? 'black': '#eee'}" />

   <line x1="0" :y1="height/2" :x2="lineX" :y2="height-linePadding" style="stroke-width:2"
   :style="{stroke: color.indexOf('1') > -1 ? 'black': '#eee'}" />

   <text class="emoji-outcome" :x="lineX+emojiPadding" :y="emojiHeight">üç±</text>
   <text class="emoji-outcome" :x="lineX+emojiPadding" :y="height-10">ü•õ</text>
  </g>
</script>

<!-- 

2 day tree
  <tree-node transform="translate(0, 150)"></tree-node>
  <tree-node transform="translate(80,90)"></tree-node>
  <tree-node transform="translate(80,200)"></tree-node>

3 day tree
-->
<script type="text/x-template" id="tree-diagram-template">

<div>
<svg height="150" width="80" style="border: 1px solid red">
  <tree-node :height="150" :width="80"></tree-node>
</svg>


  <svg height="210" width="180">
    <g transform="translate(0,-90)">
      <tree-node color="1" transform="translate(0, 150)"></tree-node>
      <tree-node color="" transform="translate(80,90)"></tree-node>
      <tree-node color="1" transform="translate(80,200)"></tree-node>
    </g>
  </svg>

</div>

</script>


<script type="text/x-template" id="coin-flips-template">
<div>
<h2>Chapter 1: Independent Events</h2>
<pset>


<avatar
  text="I am your companion through this Totally Not Scary Guide to Statistics.">
  <next>Who are you?</next>
</avatar>


<avatar>
  <div>
    I'm your friendly neighborhood <bold>statistics wizard</bold>. I've been learning about statistics my whole life. And mom would use statistics to pack my lunch.
  </div>
  <next>Next</next>
</avatar>


<avatar 
  text="My mom would flip a (presumably) fair coin, and if it would land heads she would pack me lunch üç± like a normal mother.">
  <next>Next</next>
</avatar>

<avatar image="milk.png"
    text="But if it landed tails, she would pack me a gross white potion ü•õ to make me stronger.">
  <next>Next</next>
</avatar>

<avatar key="HH"
  text="What is the probability that after my mom flips a fair coin twice, I'll be drinking the gross potion ü•õ two days in a row?">

  <div>
  <div>
    <div class="tree-header">Day 1</div>
    <div class="tree-header">Day 2</div>
  </div>
  <svg height="210" width="180">
    <g transform="translate(0,-90)">
      <tree-node color="1" transform="translate(0, 150)"></tree-node>
      <tree-node color="" transform="translate(80,90)"></tree-node>
      <tree-node color="1" transform="translate(80,200)"></tree-node>
    </g>
  </svg> <span style="font-size:32px; position:relative:-20px">?</span>
  </div>

  <buton nope="1/2 is the probability of tossing a single coin and getting T. Getting two tails is rarer, but how much rarer?">1/2</buton>
  <buton yay>1/4</buton>
</avatar>

<avatar image="brain.png"
  key="HH-explanation">
  <div>
    Right. Coin flips are <bold>independent</bold>. Knowing the result of one event does not give you information about the other events, because coins have no memory. 
  </div>
  <div>
    To calculate the probability that multiple independent events will occur together, you can multiply them.
  </div>
  <div>
    Probability of TT = 1/2 √ó 1/2.
  </div>
  <next>Next</next>
</avatar> 

<avatar key="HHH"
  text="What is the probability that after my mom tosses a (presumably) fair coin three times, I'll end up drinking the potion three days in a row?">

  <div>
    <div class="tree-header">Day 1</div>
    <div class="tree-header">Day 2</div>
    <div class="tree-header">Day 3</div>
  </div>

  <div>
  <svg height="420" width="300">

    <g transform="translate(0,-30)">
      <tree-node color="1" transform="translate(0, 150)" :height="200" :width="80"></tree-node>

      <g transform="translate(84, -60)">
        <tree-node color="" transform="translate(0, 150)"></tree-node>
        <tree-node color="" transform="translate(80,90)"></tree-node>
        <tree-node color="" transform="translate(80,200)"></tree-node>
      </g>


      <g transform="translate(84, 150)">
        <tree-node color="1" transform="translate(0, 150)"></tree-node>
        <tree-node color="" transform="translate(80,90)"></tree-node>
        <tree-node color="1" transform="translate(80,200)"></tree-node>
      </g>
    </g>

  </svg>
  </div>

  <buton-group>
    <buton nope>1/2</buton>
    <buton nope>1/3</buton>
    <buton yay>1/8</buton>
  </buton-group>
</avatar>

<avatar key="HHHHH"
  text="If mom's (presumably) fair coin gave me the gross potion for the last five days, am I more likely to get the potion today OR a normal lunch today?">

  <buton-group>
    <buton @click="memory='userSaidT'" nope>Gross potion ü•õ</buton>
    <buton @click="memory='userSaidH'" nope>Normal lunch üç±</buton>
    <buton yay>It's 50-50</buton>

    <template v-slot:hint>
      <div v-if="memory == 'userSaidT'">
        <div>That's the Gambler's Fallacy... a common misconception that events that haven't occured are more likely to occur.</div>

        <div>Coins have no memory, so just because tails came up a lot, doesn't mean that heads is more likely to come up in the future.</div>
      </div>

      <div v-if="memory == 'userSaidH'">
        <div>That's the Hot Hand Fallacy... a common misconception that events that have occurred recently are "hot" and more likely to come up.</div>

        <div>Coins have no memory, so just because tails came up a lot, doesn't mean that tails is any more likely to come up in the future.</div>
      </div>

    </template>
  </buton-group>
</avatar>

<avatar
  text="Yeah! If mom's coin is really fair, I still have a 50-50 chance to get a normal lunch since coins have no memory.">
  <next>Next</next>
</avatar>


<avatar key="100H"
  text="Okay, but if I told you my mom's coin doomed me to the potion the last 100 days, what would you think I would get today?">

  <buton-group>
    <buton yay>Gross potion ü•õ</buton>
    <buton nope>Normal lunch üç±</buton>
    <next nope>It's 50-50</next>
  </buton-group>
</avatar>

<avatar image="brain.png">
  <div>
   {{got('100H') ? 'Yeah!': 'Nice try but not quite.'}} The problem of seeing 100 tails in a row on a fair coin is different from seeing 5 tails in a row, because seeing 100 tails in a row is basically impossible. 
 </div>

 <div>The probability is so tiny (1/<exp base="2" pow="100"/>) that if all the <exp base="2" pow="80"/> atoms in the universe were flipping coins, it still be a 1 in million chance of happening of any atom seeing 100 tails in a row. So if the wizard's mom says tails came up 100 times in a row, we know the coin is not fair. 
 </div>

   <next>Oh</next>
</avatar>

<avatar text="So somewhere in between drinking the potion 5 days in a row and a 100 days in a row, I ought to start questioning if my mom is playing fair. We will formalize this idea in Chapter 5: P-values.
">
  <next>Next</next>
</avatar>


<avatar>
  <div>
    But this was around the time that I stopped trusting what people said and started <bold>testing their claims</bold>.
  </div>
  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <ul>
    <li>You met a statistics wizard.</li>
    <li>You learned about <bold>independent events</bold></li>
    <li>You learned to calculate the <bold>joint probability</bold> of independent events.</li>
    <li>You learned that there are <exp base="2" pow="80"/> atoms in the universe.</li>
    <li>You learned to test people's claims.</li>
  </ul> 
  <buton @click.native="$root.nextChapter()">Next chapter</buton>
</avatar>



</pset>
</div>
</script>

<script type="text/x-template" id="wizard-flips-template">
<div>

<h2>Chapter 2: Randomness</h2>
<pset>

<avatar  
  text="By the way, have you met my crow friend Elena?">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>

<avatar text="Elena found some hilarious coins. They say H on one side, and A on the other. Let's play with them! ">
  <next>Next</next>
</avatar>

<avatar 
  text="Of these 3 coins, 2 are fair and 1 is unusual. Let's see if you can find the unusual one.">

  <div class="smaller-children">
    <div>Click (or hold down) the coins to flip them. When you have enough info, submit your guess.</div>
  </div>

  <coin></coin>
  <coin></coin>
  <coin :bias="0.7"></coin>

  <div>The unusual coin is:</div>

  <buton-group>
    <buton nope>Coin 1</buton>
    <buton nope>Coin 2</buton>
    <buton yay>Coin 3</buton>

    <template v-slot:hint>
      Hint: One coin has a tendency to land on one side more than the other.
    </template>
  </buton-group>

</avatar>

<avatar >

  <div>
    {{ perfect('3coins') ? 'Oh. You got me. That coin was biased to land on H, 70% of the time.' : "HAAAHHAA! It's pretty hard to find the biased coin, right? And that was when the coin was biased to land on H, 70% of the time!"}} 
  </div>

  <div>
     What is the weakest bias with which you can easily tell that the coin is biased?
  </div>

  <div>
    On weakly biased coins, how many flips do you need to see that it's unfair?
  </div>

  <biased-coin-machine></biased-coin-machine>
  <next>Done with this</next> 

</avatar>

<avatar 
  text="HAHA this is fun. I again have 3 coins. 2 are fair, 1 is unusual. Find the unusual coin.">


  <div class="smaller-children">
    <div>Click (or hold down) the coins to flip them. When you have enough info, submit your guess.</div>
  </div>

  <coin></coin>
  <coin pattern="haha"></coin>
  <coin></coin>

  <div>The unusual coin is:</div>

  <buton-group>
    <buton nope>Coin 1</buton>
    <buton yay>Coin 2</buton>
    <buton nope>Coin 3</buton>

    <template v-slot:hint>
      Hint: Look at the pattern of coin flips. The wizard may be having a joke at your expense.
    </template>
  </buton-group>
</avatar>


<avatar 
  text="Good find (or lucky guess)! That coin always says HAHA. It lands on heads 50% of the time, but it's unusual because I know what's coming next. Genius, isn't it??">

  <next>Next</next>
</avatar>


<avatar 
  text="OKOK last one. Find the unusual coin.">

  <div class="smaller-children">
    <div>Click (or hold down) the coins to flip them. When you have enough info, submit your guess.</div>
  </div>

  <coin></coin>
  <coin pattern="human"></coin>
  <coin></coin>

  <div>The unusual coin is:</div>

  <buton-group>
    <buton nope>Coin 1</buton>
    <buton yay>Coin 2</buton>
    <buton nope>Coin 3</buton>

    <template v-slot:hint>
      Hint: Look at the streaks within the pattern of coin flips.
    </template>
  </buton-group>
</avatar>


<avatar 
  text="Yes, Coin 2 never has long streaks of one thing or the other. Humans tend to generate 'random' sequences like this. But they aren't random, because nature doesn't mind having long streaks.">

  <next>Next</next>
</avatar>


<avatar 
  text="HAHAHA. Aren't these coins great? Isn't Elena the Crow great? ">
  <next>Yes</next>
</avatar>

<avatar text="Elena is my only friend actually.">
  <next>Oh</next>
</avatar>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
    Well, at least you learned
  </div>
  <ul>
    <li>What real randomness feels like</li>
  </ul> 

  <buton @click.native="$root.nextChapter()">Next Story</buton>
</avatar>

</pset>
</div>
</script>


<script type="text/x-template" id="bayes-rule-template">
<div>

<h2>Chapter 6: Bayes Rule</h2>  

<pset>

<avatar text="Elena??? Where's Elena??">
  <next>NEXT</next>
</avatar>

<avatar text="Oh noooo my one and only friend!">
  <next>NEXT?!?!!</next>
</avatar>

<avatar image="brain.png"
        text="Calm down calm down CALM DOWN.">
  <next>Breathe</next>
</avatar>

<avatar text="Wait... does this have to do with Chapter 5??">
  <next>Next</next>
</avatar>

<avatar text="Do you think Elena was offended by her p-value?">
  <next>Possibly</next>
</avatar>


<avatar text="But Elena is a very clever self sufficient crow. Chances are that she's okay.">
  <next>Next</next>
</avatar>


<avatar text="But then again, I've never seen Elena so ruffled before.">
  <next>Next</next>  
</avatar>

<avatar text="There's too much conflicting info!! Is Elena okay or not??">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    To reconcile the two pieces of information into a single belief use <bold>Bayes Rule</bold>.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    I thought Bayes Rule was just the relationship between conditional probabilities?
  </div>
  <div class="handwriting">
  P(A|B) = <big-frac style="position:relative; top:12px" num="P(B|A) √ó P(A)" den="P(B)" />
  </div>
  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
    Yes, but if you plug in meaningful values, then Bayes Rule becomes a general relationship of how to change your mind in response to new data.
  </div>

  <div style="margin-bottom:28px;" class="smaller-children handwriting">
  P(Hypothesis|Evidence) = <big-frac style="position:relative; top:12px" num="P(Evidence|Hypothesis) √ó P(Hypothesis)" den="P(Evidence)" />
  </div>

  <next>Try it</next>
</avatar>

<avatar>
  <div>What is my <bold>prior belief P(Hypothesis)</bold> on Elena being okay? (i.e. what did I think before I found out she was ruffled?)</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Elena is a very self-sufficient bird, so 80% of the times she's disappeared on me, she has been okay.
  </div>

  <div>Input your prior belief that Elena is okay. 
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [1, 1], correct: [4, 1], isActive: true, isControllable:true}}">
  </triple-bayes>

</avatar>

<avatar image="brain.png">
  <div>
    Now you need to take into account the data that Elena was last seen visibly ruffled. 
  </div>
  <div>
    To incorporate this data, Bayes Rule says to look at the likelihood of the data under each hypothesis P(D|H). 
  </div>

  <div>
    We need to compute the ratio of
  </div>

  <div>
    P(Ruffled|OK) vs P(Ruffled|Not OK).
  </div>

  <div>
    This is called the <bold>likelihood ratio of the evidence</bold>.
  </div>
  <next>Next</next>
</avatar>


<avatar>
  <div>
    Out of 100 OK birds, I imagine 10 of them might be ruffled.
    Out of 100 Not OK Birds, probably 80 are ruffled.
  </div>

  <div>
    Input the likelihood ratio of the evidence.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [4, 1]}, likelihood: {dist: [1, 1], correct: [1, 8], isActive: true, isControllable: true}}">
  </triple-bayes>

</avatar>

<avatar 
  text="Bayes Rule says our belief after seeing the evidence is our prior belief multiplied by the likelihood ratio.">

  <div>
    The belief after we have considered the evidence is called the <bold>posterior belief</bold>.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [4, 1]}, likelihood: {dist: [1, 8]}, posterior: {isActive: true}}">
  </triple-bayes>

  <div>
    Looking at the posterior belief, what is the probability that Elena is OK?
  </div>
  <buton yay>33%</buton>
  <buton nope>40%</buton>
  <buton nope>80%</buton>
</avatar>

<avatar text="That's not great odds.">
  <next>Oh no</next>
</avatar>


<avatar text="The other thing is she didn't leave a note.">
  <div>
  50 out of 100 OK people don't leave a note when they are ruffled.<br>
  90 out of 100 Not OK people don't leave a note when they are ruffled.
  </div>

  <div>
  Use this information to create a likelihood ratio.<br>
  </div>

  <triple-bayes 
    :hypotheses="['Ok', 'Not OK']" 
    :config="{prior: {dist: [4, 8]}, likelihood: {dist: [1, 1], correct: [5, 9], isActive: true, isControllable: true}, posterior: {isActive:true}}">
  </triple-bayes>
</avatar>

<avatar text="Oh no!!! Only a 22% chance she's okay??">
  <next>Next</next>
</avatar>

<avatar text="Wait I hear a cacophony of crows!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    What's the probability that I'd hear a cacophony of crows under each hypothesis?
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png"
  text="Get out of your head and follow the noise!">
  <next>Next</next>
</avatar>

<avatar text="ELENA!!!">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="CAWW (HELP)">
  <next>Next</next>
</avatar>

<avatar text="There you are Elena!">
  <next>Next</next>
</avatar>

<avatar text="Was I right to infer that there was a 78% chance you were in trouble?">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="CAWW CAWW (HELP HELP)">
  <next>Next</next>
</avatar>

<avatar text="You get away from her, mean crows!">
  <next>Next</next>
</avatar>

<avatar text="Thank you for helping me find Elena.">
  <next>Next</next>
</avatar>

<avatar text="Elena, I hope that p-value nonsense didn't cause you to run away.">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="...">
  <next>Next</next>
</avatar>

<avatar text="Not only are you the cleverest crow I know, you're my best friend.">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="c... aw...">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  While this is all touching, let's take another look at Bayes Rule that saved the day.
  </div>
  <next>Next</next>
</avatar>

<avatar image="brain.png"
      text="This is the Taxi-cab problem by psychologists Kahneman & Tversky.">

  <div style="max-width: 350px; margin:0 auto; margin-bottom: 16px; line-height:1.4em; text-align: justify" class="smaller-children">
  30% of the cabs in the city are Blue and 70% are Green.
  A cab was involved in a hit and run, and the witness identified the cab as Blue. 
  The court tested the reliability of the witness under the circumstances that existed on the night of the accident, and concluded that the witness correctly identified each one of the two colors 80% of the time and failed 20% of the time.
  What is the probability that the cab involved in the accident was Blue?
  </div>

  <div>
    Use the widget to solve the problem.
  </div>

  <triple-bayes 
    :hypotheses="['B guilty', 'G guilty']" 
    :config="{prior: {dist: [1, 1], correct: [3, 7], isActive: true, isControllable: true}, likelihood: {dist: [1, 1], correct:[4, 1], isActive:true, isControllable: true}, posterior: {isActive: true}}">

    <template v-slot:yay>
      <buton @click="set('bayes-rule')">Next</buton>
    </template>

    <template v-slot:hint>

      <div>
      <div><bold>Prior</bold></div>
      Ignoring the eye witness evidence, and just considering the base rate of cabs in the city gets the prior.
      </div>

      <div>
      <div><bold>Likelihood Ratio</bold></div>
      The likelihood ratio of the data P(D|H) given that the eyewitness saw a blue cab consists of
      </div>
      <big-frac>
        <template v-slot:num>
          P(Saw blue|Blue guilty)
          </template>
          <template v-slot:den>
          P(Saw blue|Green guilty)
        </template>
      </big-frac>
    </template>
  </triple-bayes>

</avatar>


<avatar>
  <div>
    <div>
      So even though there is pretty accurate eyewitness testimony pointing to Blue cabs, given the low base rate of Blue cabs, it's still pretty uncertain which cab company was at fault.
    </div>
    <next>Next</next>
  </div>
</avatar>

<avatar image="brain.png"
  text="Congrats, you solved a problem that few people get correct. By using both the prior and likelihood of evidence, you avoided the human tendency to just use one or the other.">

  <next>Next</next>
</avatar>

<avatar text="Hey... are you my friend? ">
  <next>Next</next>
</avatar>

<avatar text="I feel like we've hit the three tenets of friendship from Chapter 4.">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    We have consistency ‚Äî you've hung out with me for {{$root.elapsedMinutes}} minutes and {{$root.elapsedSeconds}} seconds.
  </div>
  <next>Next</next>
</avatar> 

<avatar text="And positivity ‚Äî you look like you're having fun.">
  <next>Next</next>
</avatar>

<avatar text="And vulnerability ‚Äî you saw my struggle to make friends.">
  <next>Next</next>
</avatar>

<avatar>
  <p>
    Wait, I don't know anything vulnerable about you.
  </p>

  <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSfD8mzdkhL4XiSSg-Z2hCtRxvsxjvanklWZrODVEmbtW4LV5Q/viewform?embedded=true" width="400" height="471" frameborder="0" marginheight="0" marginwidth="0">Loading‚Ä¶</iframe>

  <next>Next</next>
</avatar>

<avatar>
  <div>
  So... I guess we're friends now? 
  </div>

  <once-group>
    <next>Yes</next><next>Possibly</next>
  </once-group>
</avatar>

<avatar>
  <div>
  And you see probability and statistics in real life now? 
  </div>

  <once-group>
    <next>Yes</next><next>Possibly</next>
  </once-group>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>

  <ul>
    <li>how to update beliefs with <bold>Bayes Rule</bold> is the average reward.</li>
    <li><bold>posterior belief</bold> is proportional to <bold>prior belief</bold> √ó <bold>likelihood of evidence</bold></li>
    <li>To breathe when panicking.</li>
    <li>That you have a new friend.</li>
  </ul> 

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    By the way, Bayes Rule is easy to derive, if you ever forget it.
  </div>

  <div>
    P(A AND B) = P(A|B) √ó P(B)  <span class="comment"># From Chapter 3</span>
  </div>

  <div>
    P(A|B) = <big-frac num="P(A AND B)" den="P(B)"/>  <span class="comment"># Rearrange the terms</span>
  </div>

  <div>
    P(A|B) = <big-frac num="P(B|A) √ó P(A)" den="P(B)" />  <span class="comment"># Expand P(A AND B) again</span>
  </div>


  <div>
    P(A|B) = <big-frac style="position:relative; top:12px" num="P(B|A) √ó P(A)" den="P(B)" /> <span class="comment"># Tada! It's Bayes Rule</span>
  </div> 

  <div>
    <buton @click.native="$root.nextChapter()" :scroll="false">Next chapter</buton>
  </div>
</avatar>


</pset>
</div>
</script>

<script type="text/x-template" id="the-end">
<div>
</div>
</script>

<script type="text/x-template" id="pset-template">
  <div class="pset">
    <slot></slot>
  </div>
</script>

<script type="text/x-template" id="coin-template">
  <div @mousedown="isMouseDown = true" 
       @mouseup="isMouseDown = false" 

       @touchstart="isMouseDown = true"
       @touchend="isMouseDown = false"

       @contextmenu="isMouseDown = false"
       class="coin normal-div no-select" style="position:relative">
    <img v-if="isShowingH" src="images/coin_heads.png" style="width:100px">
    <img v-if="!isShowingH" src="images/coin_tails.png" style="width:100px">
    <div ref="flip-string" style="font-size:13px; margin-left:8px; margin-right:8px" :style="flipStringStyle">{{flipString ? flipString.length + ' flips ' : ''}} {{flipString}}</div>
    <samples-chart v-if="flips.length > 0" :xdomain="xDomain" :dist="dist" :style="chartStyle"></samples-chart>
  </div>
</script>


<script type="text/x-template" id="biased-coin-machine-template">
<div>

  <div class="smaller-children">Adjust the bias, and click (or hold down) on the coin to flip.</div>

  <div>
    <span class="smaller-children">Lands H with <bold>{{$root.formatPct(bias)}}</bold> chance:</span>
    <input v-model="slider" type="range" min="0" max="100" style="width:200px; display:inline">
  </div>


  <div>
  <coin ref="coin" :bias="bias" style="width:120px" :sideBySide="true"></coin>
  </div>
</div>
</script>


<script type="text/x-template" id="chain-rule-template">
<div>

  <h2>Chapter 3: Chain Rule of Probability</h2>
<pset>

<!--<div class="normal-div" style="display:table-cell; vertical-align:bottom; border:1px solid red">
    <div style="width:40px; height:60px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:64px; position:absolute; top:-70px;left:-12px">üßô‚Äç‚ôÇÔ∏è</div>
    </div>
    <div style="width:40px; height:20px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:64px; position:absolute; top:-70px;left:-12px">üßô‚Äç‚ôÇÔ∏è</div>
    </div>
    <div style="width:40px; height:60px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:48px; position:absolute; top:-50px;left:-4px">üë±</div>
    </div>
    <div style="width:40px; height:20px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:48px; position:absolute; top:-50px;left:-4px">üë±</div>
    </div>
</div>-->

<avatar text="I like someone but she doesn't like me back.">
  <next>Next</next>
</avatar>

<avatar 
  image="girl.png" 
  text="I'm Veronica and I only date characters that are tall and have beards.">

  <next>Next</next>
</avatar>


<avatar 
  text="So I cast a spell to cause many characters to be unable to grow beards...">
  <next>Oh</next>
</avatar>


<avatar image="girl.png"
  text="Is that why it's so hard to find someone I like?">
  <next>Next</next>
</avatar>

<avatar image="girl_happy.png"
  text="Naw, I don't think that's it. I'm just waiting for my Mister Right.">
  <next>Next</next>
</avatar>


<avatar 
  image="girl.png" 
  text="1/2 of all characters are tall and 1/4 of characters have beards.">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    Let's write what Veronica told us in math language.
  </div>

  <div>
    The probability of a character having a beard can be written as:
  </div>

  <div>
    P(beard) = 1/4
  </div>

  <div>
    This is pronounced as "the probability of a beard is 1/4".
  </div>

  <div>
    Veronica also told us
  </div>

  <div>
    P(tall) = 1/2
  </div>
  <next>Next</next>
</avatar>
<avatar key="fakeout1"
  image="girl.png" 
  text="What is the probability that a random character is datable? i.e. What is P(tall AND beard)?">

  <buton-group>
    <next>1/8</next>
    <buton nope="Hm... 1/3 doesn't make sense. Try again.">1/3</buton>
    <buton nope="Although 1/4 is the number of characters that have a beard, it's not clear that all bearded characters are tall. Try again.">1/4</buton>
    <buton nope="There aren't even that many tall characters! Try again.">3/4</buton>
    <buton yay>Not enough info</buton>
  </buton-group>
</avatar>


<avatar image="brain.png">

  <div>
    {{got('fakeout1') ? "Right! It's not possible to say." : "Nice try, but there's a catch." }}
  </div>

  <div>
    It is only valid to multiply two probabilities to calculate the joint probability if the two events are <bold>independent</bold> ‚Äî like coin flips.
  </div>

  <div>
     In our case, independence occurs if a character's height <bold>does not provide any information</bold> on the greatness of a characters hair. 
  </div>

  <div>
    So if knowing that a character is tall or short, does not make it any more or less likely that the character has a beard... then it's safe to say that having a beard and being tall are independent.
  </div>

  <next>Next</next>
</avatar>


<avatar image="girl.png" 
        text="I guess I do see some correlation between being tall and having a beard, so they're not independent. If I know a character is tall, there's a 1/3 chance that they have a beard.">
  <next>Next</next>
</avatar>



<avatar image="brain.png">

  <div>
  Veronica told us a <bold>conditional probability</bold> when she said:
  </div>

  <div>
   The probability a character has a beard is 1/3 <bold>given</bold> that we know the character is tall. 
  </div>

  <div>
    Conditional probabilities are written like P(X|Y). The bar "|" is  pronounced as "given", and P(X|Y) indicates the probability of X given that we know Y to be true.
  </div>


  <div>
    Veronica told us P(beard|tall) = 1/3.
  </div>


  <div>
   This is read as "the probability a character has a beard given that we know the character is tall is 1/3". 
  </div>


  <next>Next</next>
</avatar>


<avatar  image="brain.png">

  <div>
    We can use the conditional probability to calculate P(tall AND beard) without assuming independence:
  </div>

  <div>
    P(tall AND beard) = P(tall) x P(beard|tall)
  </div>

  <div>
    The formula says to get the probability of finding a tall character with a beard = (probability of finding a tall character) x (probability that a tall character has a beard).
  </div>

  <next>Try it</next>
</avatar>


<avatar key="tall-hair" 
        image="girl.png" 
        text="Okay so what is the probability that a random character is datable?">

  <div>What is P(tall AND beard)?</div>

  <div class="extra-info">Facts from before:
  <ul>
    <li class="highlight">P(tall) = 1/2</li>
    <li class="unused">P(beard) = 1/4</li>
    <li class="highlight">P(beard | tall) = 1/3</li>
  </ul>
  </div>

  <buton-group>
    <buton yay>1/6</buton>
    <buton nope="We said that being tall and having a beard are not independent, so we can't just multiply 1/2 x 1/4.">1/8</buton>
    <buton nope="Are you just multiplying things together? Try again.">1/24</buton>
    <buton nope="The answer isn't always 'Not enough info'...">Not enough info</buton>
  </buton-group>
</avatar>


<avatar image="girl_happy.png" text="Thank you for your help so far. But I forgot... ">
  <next>Yes?</next>
</avatar>


<avatar key="fakeout2"
        image="girl.png"
        text="I also want my character to have tattoos. 1/5 of characters have tattoos.">

  <div>In math speak, <bold>P(tattoos) = 1/5.</bold></div>
  <div>What is P(tall, beard, tattoos)? <span style="color:#777"><- Note: This is a more compact way of writing P(tall AND beard AND tattoos).</span></div>

  <div class="extra-info">Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(beard) = 1/4</li>
      <li>P(beard|tall) = 1/3</li>
      <li>You calculated P(beard, tall) = 1/6</li>
    </ul>
  </div>

  <buton-group>
    <next>1/30</next>
    <buton nope="Remember, we want to use P(beard|tall), not P(tall).">1/40</buton>
    <buton nope="Wait, are you just blindly multiplying numbers? Stop that.">1/120</buton>
    <buton yay>Not enough info</buton>
  </buton-group>
</avatar>


<avatar 
    image="brain.png">

  <div>
    {{ got('fakeout2') ? 'Right.': 'Not quite.' }} Again, it's not possible to say!
  </div>

  <div>
    To get P(tattoo, beard, tall), we can't just multiply
    P(tattoo) x P(beard, tall) without assuming independence.
  </div>

  <div>
    We need another conditional probability.
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    And this brings us to the <bold>Chain Rule of Probability</bold>.
  </div>

  <div class="smaller-children">
    P(tattoo, beard, tall) = <br>
    <span style="color:#7570b3">P(tall)</span> x <span style="color:#1b9e77">P(beard | tall)</span> x <span style="color:#d95f02">P(tattoo | beard AND tall)</span>
  </div>

  <div class="smaller-children" style="margin-left: 16px;">
    <div>
      First, consider the <span style="color:#7570b3">probability of the character being tall</span>.
    </div>

    <div>
      Then, consider the <span style="color:#1b9e77">probability of a tall character having a beard</span>.
    </div>

    <div>
      Then, consider the <span style="color:#d95f02">probability that a tall character with a beard, would have a tattoo</span>.
    </div>

    <div>
      Multiply together to get characters that are tall and have a beard and have tattoos.
    </div>
  </div>

  <div>
    Basically, the Chain Rule says that when bringing a new item to the joint probability, condition on all the events that already exist.
  </div>

  <next>Try it</next>
</avatar>


<avatar key="problem3" 
        image="girl.png" 
        text="Ooh yes, I've heard of the Chain Rule. Here are the numbers that you'll need.">

  <div>
  What is P(tall, beard, tattoos)?
  </div>

  <div class="extra-info">
  Facts from before:
  <ul>
    <li>P(tall) = 1/2</li>
    <li class="unused">P(beard) = 1/4</li>
    <li>P(beard|tall) = 1/3</li>
    <li class="highlight">You calculated P(beard AND tall) = 1/6</li>
    <li class="unused">P(tattoos) = 1/5</li>
    <li class="unused">P(tattoos|tall) = 1/6</li>
    <li class="highlight">P(tattoos|tall AND beard) = 1/7</li>
  </ul>
  </div>

  <div>
  P(tall, beard, tattoos) = 1/<input-box right="42">
    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So P(tall, beard, tattoos) = P(tall) x P(beard | tall) x P(tattoos | beard AND tall). 
      </div>
    </template>
  </input-box>
  </div>

</avatar>

<avatar key="problem4" 
        image="girl.png" 
        text="Yes, thank you! But silly us! We forgot to include that these tall, bearded, tattooed characters also need to be... around my age and single.">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li class="unused">P(tall) = 1/2</li>
      <li class="unused">P(beard) = 1/4</li>
      <li class="unused">P(beard|tall) = 1/3</li>
      <li class="unused">You calculated P(beard AND tall) = 1/6</li>
      <li class="unused">P(tattoos) = 1/5</li>
      <li class="unused">P(tattoos|tall) = 1/6</li>
      <li class="unused">P(tattoos|tall AND beard) = 1/7</li>
      <li class="highlight">You calculated P(beard, tall, tattoos) = 1/42</li>
      <li class="highlight">P(around her age | tall, beard, tattoos) = 1/5</li>
      <li class="highlight">P(single | tall, beard, tattoos, around her age) = 1/2</li>
    </ul>
    </div>


    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So in the case of four events, P(tall, beard, tattoos, single) = P(tall) x P(beard | tall) x P(tattoos | beard AND tall) * P(beard AND tall AND tattoos | single). 
      </div>
      <div>
        What is it for five events?
      </div>
    </template>

    <div>
    P(tall, beard, tattoos, around her age, single) =
    </div>

    1/<input-box right="420"/>
</avatar>


<avatar image="girl_shock.png"
        text="That's not very many people!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Even though each individual criterion may not seem picky, requiring that a character have all the traits leaves Veronica with a very small dating pool. Ha-ha!
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>But hey, at least Veronica's pickiness taught you the Chain Rule.</div>

  <next>Next</next>
</avatar>

<avatar 
    image="brain.png"
    key="decompose" >

  <div>
    We had been decomposing:
  </div>

  <div style="font-size:16px">
    P(tall, beard, tattoos) = P(tall) x P(beard|tall) x P(tattoos | tall AND beard).
  </div>

  <div>
    But notice... that we can also decompose it as:
  </div>

  <div style="font-size:16px">
    P(tall AND beard and tattoos) = P(beard) x P(tattoos | beard) x P(tall | tattoos AND beard).
  </div>

  <div>
    We can decompose it in any order we choose to, depending on what information we have on hand.
  </div>

  <div>
    How many different ways are there to decompose P(tall, beard, tattoos) using the Chain Rule?
  </div>
  <input-box right="6" :feedback="true"/>
</avatar>


<avatar image="wizard.png"
        text="Aw, you foiled my plan by showing Veronica how picky she was. But....">
  <ul>
    <li>You learned about independence</li>
    <li>You learned about Chain Rule</li>
    <li>You learned to not be too picky ‚ù§Ô∏è</li>
  </ul> 

  <next>Next</next>
</avatar>


<avatar text="Hey, do you think I'll find love one day?">
  <next>Yes</next>  <next>No</next>

</avatar>

<avatar text="What about a friend?">
  <next>Let's get you friends</next>
</avatar>

<avatar text="Uh... it might be harder than you think...">
  <buton @click.native="$root.nextChapter()">Next chapter</buton>
</avatar>

</pset>
</div>
</script>

<script type="text/x-template" id="ev-story-template">
<div>
<h2>Chapter 4: Expected Value</h2>
<pset ref="pset">

<!--  <fulcrum>
    <template v-slot:left>Yooooooo</template>
    <template v-slot:right>Yooooooo</template>
  </fulcrum> -->

<avatar text="How can I make friends?">
  <next>Next</next>
</avatar>

<avatar image="brain.png">

<div>The <a href="//www.youtube.com/watch?v=hmJyWreER7A">internet</a> claims that the 3 tenets of friendships are...</div>

<ul>
  <li>positivity</li>
  <li>consistency</li>
  <li>vulnerability</li>
</ul>
<next>Thanks internet</next>
</avatar>

<avatar>
  <div>To become friends, make interactions positive. That makes sense.</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    I'm a pretty good joke teller. I'll memorize some jokes from the <a href="//www.rd.com/funny-stuff/short-jokes/">internet</a> and make people laugh.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    But jokes don't always hit. A bad joke might lead to an awkward silence. 
  </div>
  <next @click.native="$root.play('crickets')">Crickets ü¶óü¶óü¶ó</next>
</avatar>

<avatar text="Take this joke for instance... should I tell it?">
  <div>
  40% of the time it lands üòÇüòÇüòÇüòÇ
  </div>

  <div>
  60% of the time it fails ü¶óü¶óü¶óü¶óü¶óü¶ó
  </div>

  <next>Yes</next>  <next>No</next>
</avatar>

<avatar image="brain.png"
        text="The answer actually depends on the payoffs. If ">
  <div>
    üòÇ = +1 positivity point<br>
    ü¶ó = -1 positivity point<br>
  </div>

  <div>
    Then it seems like a bad deal, because on average the wizard loses -0.2 positivity points each time I tell the joke. 
  </div>

  <div>
    This average is called the <bold>expected value</bold>.
  </div>

  <next>Next</next>
</avatar>


<avatar>
  <div>
    I feel like the payoff looks like this. If the joke lands, I'll gain 5 points because there's nowhere to go but up for my reputation. Ha-ha!
  </div>

  <div>
    üòÇ = +5 positivity points<br>
    ü¶ó = -1 positivity point<br>
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    To calculate the expected value, calculate the <bold>average outcome</bold>. For each possible outcome, multiply the probability of that outcome with the reward of that outcome, and add it all together. 
  </div>

  <div>The expected value of the joke in question is?</div>

  <div>
    <ev-tree></ev-tree>
  </div>

  <input-box right="1.4"/>
</avatar>


<avatar>
  <div>So, I should tell the joke?</div>
  <buton-group>
    <buton yay>Yes</buton>
    <buton nope>No</buton>

    <template v-slot:hint>
      The wizard should tell the joke because it has positive expected value, given that there aren't options that are higher in expected value.
    </template>
  </buton-group>
</avatar>

<avatar text="Okay... here goes...">
  <next>Next</next>
</avatar>

<avatar text="Where are average things manufactured?">
  <next>Next</next>
</avatar>

<avatar>
  <div><bold>The satisfactory!</bold></div>
  <next @click.native="memory='haha'; positivityPoints+=5; $root.play('haha')">Ha-ha!</next> 
  <next @click.native="memory='eh'; positivityPoints-=1; $root.play('crickets')">Eh...</next>
</avatar>

<avatar>
  <div v-if="memory=='haha'">
    Yay!! That joke landed! So I gain 5 positivity points.
  </div>
  <div v-if="memory=='eh'">
    Aw... it seems like that joke didn't land. So I lost 1 positivity point. I'm still glad I told the joke, because it was positive expected value.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
Help me decide whether to tell each joke or not, by calculating their expected value.
</div>
<next>Next</next>
</avatar>


<div>
  <ev-joke 
    v-for="(joke, index) in jokes" 
    v-if="index <= jokeInd" 
    :joke="joke"
    :key="joke.lead"
    @done="nextJoke"
   />
</div>

<avatar image="brain.png">
<div>
Okay, I think that's enough for positivity. The second tenet of friendship is consistency... find a structure that makes people repeatedly hangout with you.
</div>
<next>Next</next>
</avatar>

<avatar text="Hm... I could join a CLUB.">
  <next>Next</next>
</avatar>

<avatar text="Captive Lovable Uniform Besties">
  <next>Next</next>  
</avatar>

<avatar text="Which club should I join to maximize the number of interactions?">
  <next>Next</next>
</avatar>


<avatar>
  <div>I've plotted the average number of interactions other people have experienced from joining the fencing club.</div>

  <distribution :outcomes="[{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.3},{x: 4, y: 0.4},]" xLabel="Number of interactions" yLabel="Probability" title="Fencing Club" />

  <div>This type of plot with possibilities on the x-axis, and probabilities on the y-axis is called a <bold>distribution</bold>.</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Hm... I wonder how many interactions I could expect to get from joining the fencing club?
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  Just like before, you can take the expected value. Once the data is plotted as a distribution is the same as finding the <bold>balance point</bold> (where would the distribution balance on your finger if it were made of cardboard).
  </div>

<!--  <fulcrum>
    <template v-slot:center>  <visual-ev-click 
    :outcomes="clubs[0].outcomes"
    :title="clubs[0].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</template>
  </fulcrum>-->

 <visual-ev-click 
    :outcomes="clubs[0].outcomes"
    :title="clubs[0].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 

</avatar>

<avatar text="That's not a bad number of interactions. What about the math team?">

  <visual-ev-click 
    :outcomes="clubs[1].outcomes"
    :title="clubs[1].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="What about Biology Olympiad?">
  <visual-ev-click 
    :outcomes="clubs[2].outcomes"
    :title="clubs[2].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="The other club I was considering was the Knitting Circle.">
  <visual-ev-click 
    :outcomes="clubs[3].outcomes"
    :title="clubs[3].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar>
  <div>
    Okay, so which club should I join? 
  </div>

  <buton-group>
    <buton nope>Fencing Club</buton>
    <buton nope>Math Team</buton>
    <buton yay>Bio Olympiad</buton>
    <buton nope>Knitting Circle</buton>

    <template v-slot:hint>
      Join the club with the maximum expected number of interactions.
    </template>
  </buton-group>
</avatar>

<avatar>
  <div>
Cool, so now I'm a member of Bio Olympiad. And I have {{positivityPoints}} positivity points. What's next?
</div>
<next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
The final ingredient in making friends is that you need to be vulnerable.
</div>
<next>Next</next>
</avatar>

<avatar>
  <div>
Eh... I'm not going there. Who needs friends anyways?
</div>
<next>Next</next>
</avatar>

<avatar>
  <div>
Why bother... I have Elena. 
</div>
<next>Next</next>
</avatar>

<avatar image="" text="(silence)">
  <next>Next</next>
</avatar>

<avatar text="Elena??? Where's Elena??">
  <next>Next</next>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>

  <ul>
    <li>The <bold>expected value</bold> is the average reward.</li>
    <li>To use the expected value to make good decisions (on average).</li>
    <li>To take the expected value of a scenario by multiplying the probability of each outcome by the reward, and then summing.</li>
    <li>That the expected value of a distribution its balance point.</li>
  </ul> 

  <buton @click.native="$root.nextChapter()">Next chapter</buton>

</avatar>

</pset>
</div>
</script>


<script type="text/x-template" id="visual-ev-click-template">

<div>

<!--<div>
Click where you think the balance point is...
</div>
-->

<div style="position:relative">

<distribution ref="distribution" 
  :outcomes="outcomes"
  :title="title"
  :xLabel="xLabel"
  :yLabel="yLabel" ></distribution>

<div style="position:absolute; top:0px; z-index:1"   
  class="overlay"
  :style="overlayStyle"
  @mousemove="mouseX = getRelativeMouseX($event)"
  @mouseenter="isMouseover = true"
  @click.once="distributionClicked">

  <!-- tracks the user mouseover and user answer -->
  <div v-if="isMouseover" 
       style="border-left:2px solid #7570b3; width:1px; height:200px; position:absolute; bottom: -48px; pointer-events:none;"
       :style="trackerStyle"></div>

  <!-- show the real answer -->
  <div ref="answer-marker"
       v-if="answerPx" 
       class="ev-answer-bar"
       :style="{left: answerPx + 'px'}"
       style="border-left:2px solid #1b9e77; width:1px; height:200px; position:absolute; bottom: -48px; pointer-events:none;"></div>
</div>


<div v-if="answerReal" class="smaller-children">
  <div>
  You <span style="color:#7570b3">guessed {{$root.roundTo(guessReal, 1)}}</span>. The <span style="color:#1b9e77">expected value of  {{$root.roundTo(answerReal,1)}}</span> was {{feedbackString}}
  </div>

  <buton @click.native="$emit('done')">Next</buton>
</div>


</div>
</div>
</script>

<script type="text/x-template" id="ev-joke-template">
<div ref="container">

<avatar ref="joke">
  <div>Should I tell the joke?</div>

  <div v-for="outcome in joke.outcomes">
    {{$root.roundTo(outcome.certainty*100, 0)}}% chance joke {{outcome.present}}, {{outcome.payoff}} points
  </div>

  <div>
    <ev-tree :outcomes="joke.outcomes" /> 
  </div>

  <buton @click.native="setUserAnswer('Yes')">Yes</buton>
  <buton @click.native="setUserAnswer('No')">No</buton>
</avatar>


<avatar v-if="ev > 0 && userAnswer == 'No'">
  <div>Oh, what's wrong with this joke? It seems like positive expected value to me: </div>
  <div>{{evCalculation}}</div>
  <div>Pick again.</div>
</avatar>

<avatar v-if="ev < 0 && userAnswer == 'Yes'">
  <div>Hmm... I'm not sure if this is a good idea: </div>
  <div>{{evCalculation}}</div>
  <div>Pick again.</div>
</avatar>

<avatar v-if="ev < 0 && userAnswer == 'No'">
  <div>
    Good call... that joke has negative expected value so I probably shouldn't tell it.
  </div>
  <buton @click.native="finish(0)">Next</buton>
</avatar>


<pset v-if="(ev > 0 && userAnswer == 'Yes') || forceTell">
<avatar text="Okay... here goes...">
  <next>Next</next>
</avatar>

<avatar :text="joke.lead">
  <next>Next</next>
</avatar>

<avatar>
  <div><bold>{{joke.punchline}}!</bold></div>
  <next @click.native="playJokeSound">{{chosenOutcome.payoff > 0 ? 'Ha-ha!' : 'Eh...'}}</next>
  <div style="font-size:10px">The random number generator in the background dictates that the joke {{chosenOutcome.past}}.</div>
</avatar>


<avatar v-if="userAnswer !== null && chosenOutcome.payoff < 0">
  <div>
    Aw... it seems like that joke {{chosenOutcome.past}}. So I lost {{chosenOutcome.payoff}} positivity points. I'm still glad I told the joke, because it was +{{evString}} points in expected value.
  </div>

  <div>
    {{evCalculation}}
  </div>

  <next @click.native="finish(chosenOutcome.payoff)">Next</next>
</avatar>

<avatar v-if="userAnswer !== null && chosenOutcome.payoff > 0">
  <div>
    Yay!! That joke {{chosenOutcome.past}}! So I gain {{chosenOutcome.payoff}} positivity points.
  </div>
  <next @click.native="finish(chosenOutcome.payoff)">Next</next>
</avatar>

</pset>

</div>
</script>


<script type="text/x-template" id="fulcrum-template">

<div class="normal-div" style="position:relative; width: 100%; height: 250px;">


  <!-- black bar and items -->
  <div :class="{'left-wobble': shouldLeftWobble, 'right-wobble': shouldRightWobble}" 
        :style="{width: width + 'px'}"
        style="position:absolute; border-bottom: 5px solid black; bottom:50px;">


    <div style="position:absolute; left: 40px; top:-180px;">
      <slot name="center"><slot>
    </slot>



  </div>

  <!-- triangle fulcrum -->
  <div class="fulcrum smooth" 
    style="position:absolute; bottom:-50px;"
    :style="fulcrumStyle">
    <div class="bold" style="position:absolute; width:30px; font-size:18px; color:white; left:-22px; top:22px">{{percent}}</div>
  </div>

  <button @click="wobble(3)" style="position:absolute;top:0px; left:0px">wobble</button>


</div>
</script>

<script type="text/x-template" id="bold-template">
<span class="bold"><slot></slot></span> 
</script>


<script type="text/x-template" id="distribution-template">
<div class="distribution" style="display:inline-block">
<div v-if="title" style="text-align: center; font-size: 16px; text-transform:capitalize" :style="titleStyle">{{title}}</div>

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
      <rect v-for="outcome in outcomes"
          :x="xScale(outcome.x)"
          :y="yScale(outcome.y)"
          :width="xScale.bandwidth()"
          :height="chartHeight - yScale(outcome.y)"
          :key="outcome.x"
          fill="#EA27A2"/>

      <!-- top of bar 
      <text v-for="outcome in outcomes" 
        :x="xScale(outcome.x) + xScale.bandwidth()/2 - 8"
        :y="yScale(outcome.y) - 2">
        {{ outcome.y }}
      </text>-->
    </g>
</svg>
</div>
</script>

<!-- <triple-bayes 
  :hypotheses="['Nice', 'Evil']" 
  :config="{prior: {dist: [1, 1], correct: [1, 2], isActive: true, isControllable:true}, likelihood: {dist: [10, 1], isActive: true, isControllable: true}, posterior: {}}"></triple-bayes> -->
<script type="text/x-template" id="triple-bayes-template">
<div style="display:inline-block">

<div v-if="hasKey('prior')" class="bayes-comp" :style="compStyle('prior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('prior')}}</div>
    <div>{{subtitle('prior')}}</div>
  </div>

  <samples-chart 
  :xdomain="hypotheses"
  :xLabels="xLabels('prior')"
  :dist="arrToDist(priorArr)"
  :isControllable="isControllable('prior')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  @dist-changed="priorChanged" /> 
</div>


<div v-if="hasKey('likelihood')" class="bayes-comp" :style="compStyle('likelihood')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('likelihood')}}</div>
    <div>{{subtitle('likelihood')}}</div>
  </div>
  <samples-chart
  :xdomain="hypotheses"
  :xLabels="xLabels('likelihood')"
  :dist="arrToDist(likelihoodArr)"
  :isControllable="isControllable('likelihood')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  @dist-changed="likelihoodChanged" /> 
</div>

<div v-if="hasKey('posterior')" class="bayes-comp" :style="compStyle('posterior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('posterior')}}</div>
    <div>{{subtitle('posterior')}}</div>
  </div>
  <samples-chart 
  :xdomain="hypotheses"
  :xLabels="xLabels('posterior')"
  :dist="posteriorDist"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  ref="posterior-samples-chart" /> 
</div>

<div v-if="showFeedback && !allCorrect" class="handwriting">
  <div>Not quite. Try again!</div>
  <slot name="hint"></slot>
</div>


<div v-if="showFeedback && allCorrect" class="handwriting">
  <div>Correct!</div>
  <slot name="yay"></slot>
</div>

<div v-if="(isControllable('prior') || isControllable('likelihood')) && !(showFeedback && allCorrect)">
<buton @click="submitClicked">Submit</buton>
</div>

  </div>
</script>

<script type="text/x-template" id="samples-chart-template">
<div style="position:relative; display:inline-block" class="samples-chart no-select normal-div"
:class="{disabled: !isControllable}">

<!-- discrete -->
  <svg v-if="view=='discrete'"
     :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">

        <g v-for="x in xdomain">
          <rect v-for="countInd in counts[x]"
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x]) + yScaleBandwidth*(countInd-1)+yPadBetweenBars"
          :width="xScale.bandwidth()"
          :height="yScaleBandwidth-yPadBetweenBars"
          :key="x + countInd"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="Math.max(0, chartHeight - yScale(counts[x]) - 4)">
        {{ prob(x) }}%
      </text>

    </g>
</svg>

<!-- continuous -->
 <svg v-if="view=='continuous'"
     :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">

        <g v-for="x in xdomain">
          <rect
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x])"
          :width="xScale.bandwidth()"
          :height="yScale(counts[x])"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="Math.max(0, chartHeight - yScale(counts[x])) - 4">
        {{ prob(x) }}%
      </text>

    </g>
</svg>


<input v-if="isCreated && isControllable"
       v-for="x in xdomain" 
      :key="x" 
      v-model="counts[x]"
      style="font-size:28px; width:50px; text-align:center" />


</div>
</script>

<script type="text/x-template" id="avatar-template">
<div style="position: relative; display:grid; grid-auto-flow:column; max-width:600px; margin:0 auto; margin-top:16px; grid-template-columns: auto 1fr">

 <div class="cropcircle" :style="cropCircleStyle" style="display:inline-block; vertical-align:top;">
 </div>


<div style="display:inline-block; max-width:400px">
    <div>{{text}}<slot name="text"></slot></div>

    <slot></slot>
</div>

</div>
</script>


<script type="text/x-template" id="exp-template">
<var>{{base}}<sup>{{pow}}</sup></var>
</script>


<script type="text/x-template" id="big-frac-template">
<div style="display: inline-block; text-align:center" class="normal-div">
    <div style="border-bottom:1px solid">{{num}}<slot name="num"></slot></div>
    <div>{{den}}<slot name="den"></slot></div>
  </td>
</div>
</script>

<script type="text/x-template" id="frac-template">
<var><sup>{{num}}</sup>&frasl;<sub>{{den}}</sub></var>
</script>

<script type="text/x-template" id="buton-template">
<span style="margin-bottom:0px; position:relative; display:inline-block; vertical-align:top" class="normal-div">
  <div style="display:inline-block">
    <div v-if="showX" 
         class="handwriting" 
         style="display:inline-block; position:absolute; color:red; font-size: 48px; top:-4px;"
         :style="xStyle">‚úó</div>
     <div v-if="showYay"
              class="handwriting" 
         style="display:inline-block; position:absolute; color:green; font-size: 48px; top:0px; left:calc(50% - 10px)">
     	‚úì
     </div>
    <button ref="button" 
      @click="butonClicked()" v-on="$listeners" 
      :class="{'clicked-button': clickedButton}" 
      class="handwriting"
      :style="buttonStyle"
      style="margin-bottom:4px"><slot></slot>
    </button>
  </div>

  <div v-if="showNopeText" class="hint" style="margin-left:12px;">
    {{nopeText}}
  </div>
  <div v-if="showYay" style="margin:8px;" class="hint" >
    Yay
  </div>

</span>
</script>

<script type="text/x-template" id="buton-group-template">
<div>
  <slot></slot>
  <div v-if="showHint" class="hint"><slot name="hint"></slot></div>
</div>
</script>

<script type="text/x-template" id="input-box-template">
<div style="display:inline-block; position:relative; top:-16px;">

  <input v-model="val" placeholder="?" style="width:70px; display:inline; position:relative; top:16px" v-on:keyup.enter="answerSubmit">
  <slot></slot>
  <buton style="display:inline" @click="answerSubmit">Go</buton>

  <!-- absolute position so they don't shift the screen -->
  <span v-if="showCannedHint" class="hint" style="position:absolute; bottom:-24px; right:4px">
    {{cannedHint}}
  </span>
  <span v-if="showYay" class="hint" style="position:absolute; bottom:-24px; right:4px">
    Yay!
  </span>


  <div v-if="showHintSlot" class="hint normal-div">
    <slot name="hint"></slot>
  </div>
</div>
</script>


<script>
var DEBUG = true;


const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();



const sneakySnitch = new Howl({src: ['sounds/sneaky-snitch-by-kevin-macleod_edit.wav'], loop: true});

const sounds = {
  // 'coin': {clip: new Audio('sounds/gold1.wav')},
  'heads': {clip: new Audio('sounds/gold0.wav')},
  'tails': {clip: new Audio('sounds/gold1.wav')},


  // 'buton': {clips: [new Audio('sounds/237422__plasterbrain__hover-1.mp3')]},

  'nope': {clip: new Audio('sounds/423169__plasterbrain__pc-game-ui-error.mp3')},
  'yay': {clip: new Audio('sounds/237422__plasterbrain__hover-1.mp3')},

  'haha': {clip: new Audio('sounds/laugh.mp3')},
  'crickets': {clip: new Audio('sounds/crickets.mp3')},

  'open': {clip: new Audio('sounds/swish0.wav')},
  'close': {clip: new Audio('sounds/swish1.wav')},


	'intro-scene': sneakySnitch,  
	'coin-flips': sneakySnitch,
	'wizard-flips': new Howl({src: ['sounds/comfortable_mystery_edit.wav'], loop:true}),
  // 'chain-rule': new Howl({src: ['sounds/wholesome-by-kevin-macleod_edit.wav'], loop:true}),
  // 'chain-rule': new Howl({src: ['sounds/rusted-maid.wav'], loop:true}),
  'chain-rule': new Howl({src: ['sounds/your_call_edit.wav'], loop:true}),

  'ev-story': new Howl({src: ['sounds/extreme-hardcore-death-metal-loop_edit.wav'], loop:true}),
  'intro-to-pvalues': new Howl({src: ['sounds/comma-flaw_edit.wav'], loop:true}),
  'bayes-rule': new Howl({src: ['sounds/find-my-body-please_edit.wav'], loop:true}),
	'thanks': sneakySnitch,
};

const volume = {
  'wizard-flips': 0.7,
  'chain-rule': 0.3,
  'ev-story': 0.3,
  'intro-to-pvalues': 0.7,
  'bayes-rule': 0.7
}

Howler.volume(0.5);


const jokes = [
{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.5, payoff: 3},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.5, payoff: -1}, 
  ],
  lead: "Did you hear about the mathematician who's afraid of negative numbers?",
  punchline: "He'll stop at nothing to avoid them",
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ',certainty: 0.4, payoff: 1},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.6, payoff: -1}, 
  ]
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.4, payoff: 5},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.6, payoff: -1}, 
  ],
  lead:"Why don't scientists trust atoms?",
  punchline:"Because they make up everything"
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.45, payoff: 3},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.55, payoff: -1}, 
  ],
  lead:   "How many times can you subtract 10 from 100?",
  punchline: "Once. The next time you would be subtracting 10 from 90"
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.3, payoff: 4},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.7, payoff: -2}, 
  ]
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.68, payoff: 4},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.32, payoff: -1}, 
  ],
  lead: "The numbers 19 and 20 got into a fight.",
  punchline: "21"
},
];

const clubs = [
  {
    name: 'fencing club',
    outcomes: [{x: 1, y: 0.2},{x: 2, y: 0.3},{x: 3, y: 0.3},{x: 4, y: 0.2},]
  },
  {
    name: 'math team',
    outcomes: [{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.3},{x: 4, y: 0.4},]
  },
  {
    name: 'biology olympiad',
    outcomes: [{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.1},{x: 4, y: 0.6},]
  },
  {
    name: 'knitting circle',
    outcomes: [{x:1, y: 0}, {x: 2, y: 0.5},{x: 3, y: 0.3},{x: 4, y: 0.2},]
  },
];



Vue.component('coin', {
  props: {
    bias: {type: Number, default: 0.5},
    pattern: {type: String},
    sideBySide: {type: Boolean, default: false},
  },
  data: function(){
    return {
      flips: [], //true, false, true, true], 
      isMouseDown: false,
      autoFlipper: null,
    }
  },
  watch: {
    isMouseDown(){
      if (this.isMouseDown == false){
        // This flip handles the click case.
        this.flip();
        if (this.autoFlipper){
          clearInterval(this.autoFlipper);
        }
      }

      if (this.isMouseDown == true){
        const this_ = this;
        this.autoFlipper = setInterval(function(){
          if (this_.isMouseDown == true){
            this_.flip();
          }
        }, 150);        
      }
    }
  },
  computed: {
    flipString: function(){
      return this.samples.join('');
    },
    flipStringStyle: function(){
      return { 'min-height': '30px'};
    },
    isShowingH: function(){
      if (this.flips.length == 0){
        return true;
      }
      return this.render(this.last) == 'H';
    },
    last: function(){
      return this.flips[this.flips.length-1];
    },

    xDomain(){
      return ['H', 'A'];
    },
    // ['H', 'A', 'H', 'A']
    samples(){
      return this.flips.map(this.render);
    },
    dist(){
      return _.assign({'H': 0, 'A': 0}, _.countBy(this.samples));
    },
    chartStyle(){
      if (this.sideBySide){
      return {
        position: 'absolute',
        left: '150px',
        bottom: '0px'       
      };
    }
    }
  },
  methods: {
    render: function(flip){
      return flip ? 'H' : 'A';
    },
    append: function(flip){
      this.$root.play(flip ? 'heads' : 'tails');
      this.flips.push(!!flip);
    },
    reset: function(){
      this.flips = [];
    },
    flip: function(){
      // Always repeats as HAHA.
      if (this.pattern == 'haha'){
        if (this.flips.length == 0){
          this.append(1);
        } else {
          this.append(Math.abs(this.last - 1));
        }

        // Early return.
        return;
      }

      // Prevents long streaks from happening.
      if (this.pattern == 'human'){
        const maxStreak = 3;
        if (this.flips.length > maxStreak){
          const slice = this.flips.slice(-maxStreak);
          if(_.every(slice) || _.every(slice, x => !x)){ 
            // If the last ones have all been of a type, the new one must be opposite.
            this.append(Math.abs(this.last - 1));
          } 

          // Fallthrough.
        }
      }

      // True coin flip.
      this.append(Math.random() < this.bias); 
    }
  },
  template: '#coin-template'
});


// Returns a boolean measuring if two numbers are approximately equal.
function approx(a, b, epsilon){
  var epsilon = _.isUndefined(epsilon) ? .001 : epsilon;
  return Math.abs(a - b) < epsilon;
}

function cumulativeSum(arr){
  if (arr.length < 1){
    return [];
  }

  var total = [arr[0]];
  for (var i=1; i<arr.length; i++){
    var last = total[total.length - 1];
    total.push(last + arr[i]);
  }
  return total;
}


// outcomes = [
//  {certainty: 0.4, ...}, 
//  {certainty: 0.6, ...}
// ]
function drawFromOutcomes(outcomes){
  var ind = drawIndFromOutcomes(outcomes);
  return outcomes[ind];
}

function drawIndFromOutcomes(outcomes){
  var certainties = _.map(outcomes, 'certainty');
  if (!approx(_.sum(certainties), 1.0)){
    debugger;
    console.error('certainties for outcomes did not sum to 1: ' + outcomes);
  }

  var rand = Math.random();
  var cumsum_certainties = cumulativeSum(certainties);
  var cumsum_ind = 0;
  while (cumsum_certainties[cumsum_ind] < rand){
    cumsum_ind++;
  }
  return cumsum_ind;
}

Vue.component('ev-joke', {
  props: {
    joke: {type: Object},
  },
  computed: {
    ev(){
      return _.sum(this.joke.outcomes.map(outcome => outcome.certainty * outcome.payoff));
    },
    evString(){
      return this.$root.roundTo(this.ev, 2);
    },
    evCalculation(){
      return this.joke.outcomes.map(outcome => outcome.certainty + ' √ó ' + outcome.payoff).join(' + ') + ' = ' + this.evString;
    },
    chosenOutcome(){
      return this.joke.outcomes[this.chosenOutcomeInd];
    },
    isWrong(){
      return (this.ev > 0 && this.userAnswer == 'No') || (this.ev < 0 && this.userAnswer == 'Yes');
    }
  },
  mounted(){
   this.chosenOutcomeInd = drawIndFromOutcomes(this.joke.outcomes);
  },
  data: function(){
    return {
      stage: 0,
      userAnswer: null,
      forceTell:null,
    }
  },
  methods: {
    setUserAnswer(answer){
      this.userAnswer = answer;
      if(!this.isWrong){
        this.$refs['joke'].$el.style.opacity = 0.5;        
      }
    },
    playJokeSound(){
      const soundName = this.chosenOutcome.payoff > 0 ? 'haha' : 'crickets';
      this.$root.play(soundName);
    },
    finish(payoff){
      this.$refs['container'].style.opacity = 0.5; 
      this.$emit('done', {payoff: payoff});
    }
  },
  template: '#ev-joke-template'
});


Vue.component('biased-coin-machine', {
  data: function(){
    return {
      slider: '50',
    }
  },
  computed: {
    bias: function(){
      return +this.slider / 100;
    },
  },
  watch:{
    bias: function(){
      this.$refs['coin'].reset();
    },
  },
  template: '#biased-coin-machine-template'
});


Vue.component('input-box', {
  props: {
    right: {type: Array},
    hints: {
      type: Array, 
      default: function(){ return ['Try again', 'Nope']; },
    },
  },
  computed: {
    cannedHint(){
      return this.hints[this.answers.length % this.hints.length];      
    },
    isYay: function(){
      const this_ = this;
      if (_.isArray(this.right)){
        return _.some(this.right.map(r => this_.isMatch(this_.val, r)));
      }
      return this.isMatch(this.val, this.right);
    },
    isNope: function(){
      return !this.isYay;
    },
    showYay(){
      return this.checkedAnswer && this.isYay;
    },
    showCannedHint(){
      return this.checkedAnswer && !this.hasSlot('hint') && this.isNope;
    },
    showHintSlot(){
      return (DEBUG || this.checkedAnswer) && this.hasSlot('hint') && this.isNope;
    }
  },
  data: function(){
    return {
      val: null,
      answers: [],

      checkedAnswer: false,
      calledNext: false,
    }
  },
  watch:{
    val(){
      this.checkedAnswer = false;
    }
  },
  methods: {
    isMatch(val, right){
      if (val === undefined || val === null){
        return false;
      }
      const exactMatch = val == right;
      const europeanCommaMatch = val.replace(',', '.') == right;
      var evalMatch;
      try {
        evalMatch = approx(eval(val), eval(right));
      } catch(err){
        evalMatch = false;
      }
      return exactMatch || europeanCommaMatch || evalMatch;
    },
    answerSubmit: async function(){
      this.checkedAnswer = true;
      this.answers.push(this.val);

      if (this.isYay){
        this.$root.play('yay');
        this.$emit('yay');

        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset && !this.calledNext){
          pset.next();
          this.calledNext = true;
        }
      } else {
        this.$root.play('nope');
      }

    },
    hasSlot: hasSlot,
  },
  template: '#input-box-template'
});


function firstAncestorOfComponent(node, componentName){
  while(node !== undefined){
    node = node.$parent;
    if (node !== undefined && node.$options.name === componentName){
      return node;
    }
  }
  return undefined;
}
function isDescendant(ancestor, maybeChild){

  // If maybeChild is a vue component
  var node = maybeChild.$parent;
  while(node){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }

  // If maybeChild is an HTML element
  var node = maybeChild.parentElement;
  while(node){
    if (node === ancestor){
      return true;
    }
    node = node.parentElement;
  }

  return false;
}

function hasSlot(name){
  return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
}

Vue.component('avatar', {
  props: {
    image: {type: String, default:'wizard.png'},
    text: {type: String, default: ''},
    sound: {type: String},
  },
  mounted: async function(){
    // Add a blink
    var this_ = this;
    if (this.sound){
      this.$root.play(this.sound);
      await wait(sounds[this.sound].duration || 500);
    }
  },
  computed: {
    cropCircleStyle: function(){
      return {'background-image': 'url("images/' + this.image + '")'};
    },
  },
  template: '#avatar-template'
});

// Just like a button, but with some special abilities.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.
    fontSize: {type: Number},
    scroll: {type: Boolean, default: true},
  },
  data: function(){
    return {
      clickedButton: false,
    }
  },
  computed: {
    nopeText: function(){
      if (this.nope){
        return this.nope;        
      }
      if (this.isNope){
        return 'Try again';
      }
    },
    // Returns true for: <buton nope> or <buton nope="why not">
    isNope: function(){
      return this.nope || this.nope==="";
    },
    isYay: function(){
      return 'yay' in this.$attrs;
    },
    buttonStyle: function(){
      const defaultFontSize = this.$slots.default[0].text.length > 40 ?16 : 20;
      return {'font-size': (this.fontSize || defaultFontSize) + 'px'};
    },
    showNopeText(){
      return (DEBUG || this.clickedButton) && this.isNope;
    },
    showYay(){
      return (DEBUG || this.clickedButton) && this.isYay;
    },
    showX(){
      return this.clickedButton && this.isNope;
    }, 
    xStyle(){
      return {left: (this.$refs['button'].clientWidth/2 - 5)+'px'};
    }
  },
  methods: {
    butonClicked: async function(){
      if (this.isYay){
        this.$root.play('yay');        
      } else if (this.isNope){
        this.$root.play('nope');
      } else{
        this.$root.play('buton');        
      }
      this.clickedButton = true;
      const avatar = firstAncestorOfComponent(this, 'avatar');

      // Tell those listening on the bus that the buton has been clicked... unless it's a buton within an input-box.
      if(!firstAncestorOfComponent(this, 'input-box')){
        // Don't emit again if this is the buton inside PS either.
        if (avatar && avatar.psButton !== this){
          bus.$emit('answer-submitted', this);        
        }
      }

      // Add yourself to parent butonGroup's clicked children
      // so it can show feedback.
      const butonGroup = firstAncestorOfComponent(this, 'buton-group');
      if (butonGroup){
        butonGroup.clickedChildren.push(this);
      }

      // Move the screen along.
      if (this.isYay){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }        
      }

      if (this.scroll){
        this.$root.scrollWindow();        
      }

    },
  },
  template: '#buton-template'
});


Vue.component('exp', {
  props: {
    base: {type: String },
    pow: {type: String },
  },
  template: '#exp-template'
});


Vue.component('frac', {
  props: {
    num: {type: String },
    den: {type: String },
  },
  template: '#frac-template'
});


Vue.component('big-frac', {
  props: {
    num: {type: String },
    den: {type: String },
  },
  template: '#big-frac-template'
});


// histogram example
// https://bl.ocks.org/d3noob/96b74d0bd6d11427dd797892551a103c
Vue.component('distribution', {
  props: {

    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    // Pass in outcomes directly.
    outcomes: {type: Array, default: function(){
      return [
        {x: 'tattoos', y: 0.2},
        {x: 'no tattoos', y: 0.8},
      ];
    }},
    chartHeight: {type: Number, default: 150},
    chartWidth: {type: Number, default: 200},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 50, left: 50};
      }
    },
  },
  computed: {
    xScale(){
      return d3.scaleBand()
          .domain(this.outcomes.map(d => d.x)).paddingInner(0.01).range([0, this.chartWidth]);
    },
    xScaleContinuous(){
      const domain = this.xScale.domain();
      const range = this.xScale.range();
      const bandwidth = this.xScale.bandwidth();
      return d3.scaleLinear().domain([domain[0], domain[domain.length-1]]).range([range[0] + bandwidth/2, range[1] - bandwidth/2]);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, 1]).range([this.chartHeight, 0]);
    },
    titleStyle(){
      return {'margin-left': this.margin.left + 'px', 'margin-right': this.margin.right + 'px'};
    },
    mean: function(){
      return _.sum(this.outcomes.map(outcome => outcome.x * outcome.y));
    },
  },
  data: function(){
    return {
      isCreated: false,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: function() {
    // Add the axis
    var xAxis = d3.axisBottom(this.xScale); //.ticks(8);
    var yAxis = d3.axisLeft(this.yScale).ticks(4);

    const chart = d3.select(this.$el).select('.container');
    chart.append('g').call(yAxis);
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);


    // x axis label
    chart.append("text")             
      .attr("transform",
            "translate(" + (this.chartWidth/2) + " ," + 
                           (this.chartHeight + this.margin.top + 20) + ")")
      .style("text-anchor", "middle")
      .text(this.xLabel);

    // y axis label
    chart.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - this.margin.left)
      .attr("x",0 - (this.chartHeight / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text(this.yLabel);    

  },
  template: '#distribution-template'
});


Vue.component('visual-ev-click', {
  props: {
    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
  },
  data: function(){
    return {
      isMouseover: false,

      mouseX: null,  // tracks mouse position always

      guessPx: null, // populated when user clicks
      guessReal: null, // populated when user clicks

      answerPx: null, // populated after delay when user clicks
      answerReal: null, // populated after delay when user clicks

      isMounted: false,
    };
  },

  watch:{
    answerReal(){
      this.$root.scrollWindow();
    }
  },

  computed: {
    trackerStyle: function(){
      return {
        left: (this.guessPx !== null ? this.guessPx : this.mouseX) + 'px'
      };
    },

    userDifference: function(){
      // Is close if it's less than X% away from the true answer
      var distribution_component = this.$refs['distribution'];
      const domain = distribution_component.xScale.domain();
      var total = domain[domain.length-1] - domain[0];

      return Math.abs(this.answerReal - this.guessReal);
    },

    feedbackString: function(){
      if (this.userDifference < .1){
        this.$root.play('yay');
        return 'spot on. Good work!';
      }
      if (this.userDifference < .3){
        this.$root.play('yay');
        return 'pretty close! Good job!';
      }
      this.$root.play('nope');
      return 'far off. Needs work.';
    },

    overlayStyle(){
       if(!this.isMounted){
          return;        
       }
       const d = this.$refs['distribution'];

       return {
          left: d.margin.left + 'px',
          height: d.chartHeight + d.margin.bottom + 'px',
          width: d.chartWidth + 'px'
       };
    }
  },

  mounted(){
    this.isMounted = true;
  },

  methods: {
    distributionClicked: async function(event){
      const distribution_component = this.$refs['distribution'];
      const distMean = distribution_component.mean;
      const xScale = distribution_component.xScaleContinuous; 

      this.guessPx = this.getRelativeMouseX(event);
      this.guessReal = xScale.invert(this.guessPx);

      // answerPx gets animated into the correct position.
      this.answerPx = this.guessPx;

      // Make the answer bar animate.
      await wait(300);
      this.answerPx = xScale(distMean);
      //debugger;

      // Make the text show.
      await wait(1300);
      this.answerReal = distMean;
    },

    getRelativeMouseX: function(event){
      // Find the parent element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'overlay'){
        refElement = refElement.parentElement;
      }
      return event.clientX - refElement.getBoundingClientRect().x;
    },

  },
  template: '#visual-ev-click-template',
});


Vue.component('triple-bayes', {
  props: {

    hypotheses: {type: Array}, // ['Nice', 'Evil']
        
    chartHeight: {type: Number, default: 160},
    chartWidth: {type: Number, default: 100},

    // Missing keys from config are not rendered.
    // {prior: {dist: [1, 4]}, likelihood: {isActive: true, isControllable: true, dist: [1, 10]}, posterior: {}}
    config: {type: Object},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '#ddd', dot: '#EF6D21'};
      }
    },
  },
  data: function(){
    return {
     conf: null,
     showFeedback: null,
    }
  },
  computed: {
    posteriorDist(){
      var distArr = _.zip(this.priorArr, this.likelihoodArr).map(x => _.reduce(x, _.multiply));
      if (_.max(distArr) > 9){ // Start attempting to simplify posterior when it gets too big.
        distArr = this.simplifiedArr(distArr);
      }
      return _.zipObject(this.hypotheses, distArr);
    },
    priorArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['prior'].dist || ones;
    },

    likelihoodArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['likelihood'].dist || ones;
    },
    allCorrect(){
      const keys = ['prior', 'likelihood', 'posterior'];
      const parts = keys.map(key => !this.conf[key] || !this.conf[key].correct || this.isEqual(this.conf[key].correct, this.conf[key].dist));
      return _.every(parts);
    }
  },
  created(){
    this.conf = _.cloneDeep(this.config);
  },
  methods: {
    isEqual(arr1, arr2){
      return _.isEqual(this.simplifiedArr(arr1), this.simplifiedArr(arr2));
    },
    xLabels(key){
      if (key == 'prior'){
        return this.hypotheses.map(x => 'P(' + x + ')');
      }
      if (key == 'likelihood'){
        return this.hypotheses.map(x => 'P(D|' + x + ')' );        
      }
      if (key == 'posterior'){
        return this.hypotheses.map(x => 'P(' + x + '|D)');        
      }
    },
    // simplifiedArr([3, 6]) => [1, 2]
    simplifiedArr(arr){
      var maxFactor = _.min(arr);
      for (var i=maxFactor; i>1; i--){
        var isDivisible = _.every(arr.map(function(x){
          return Math.abs(x/i - Math.floor(x/i)) < .0001;
        }));
        if (isDivisible){
          break;
        }
      }
      var result = arr.map(x => Math.floor(x / i));
      //console.log(result);
      return result;
    },
    title(key){
      if (this.conf[key].title !== undefined){
        return this.conf[key].title;
      }
      const defaultTitles = {
        'prior': 'Prior Belief',
        'likelihood': 'Likelihood Ratio',
        'posterior': 'Posterior Belief'
      };
      return defaultTitles[key];
    },
    subtitle(key){
      if (this.conf[key].subtitle !== undefined){
        return this.conf[key].subtitle;
      }
      const defaultTitles = {
        'prior': 'What you thought before',
        'likelihood': 'Likelihood ratio of the evidence',
        'posterior': 'What you think after the evidence'
      };
      return defaultTitles[key];
    },
    hasKey(key){
      return this.conf[key];
    },
    isActive(key){
      return this.conf[key] && this.conf[key].isActive;
    },
    isControllable(key){
      return this.conf[key] && this.conf[key].isControllable;      
    },
    arrToDist(arr){
      return _.zipObject(this.hypotheses, arr);
    },
    isCompRight(key){
      return this.showFeedback && this.conf[key] && this.conf[key].correct && this.isEqual(this.conf[key].correct, this.conf[key].dist);
    },
    compStyle(key){
      return {opacity: this.conf[key] && this.conf[key].isActive ? 1 : 0.5};
    },
    likelihoodChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.likelihood, 'dist', distArr);
      this.refreshPosterior();
    },
    priorChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.prior, 'dist', distArr);
      this.refreshPosterior();
    },
    refreshPosterior(){
      if (this.$refs['posterior-samples-chart']){
        this.$refs['posterior-samples-chart'].countsFromProps()         
      }
    },
    submitClicked(){
      this.showFeedback=true;
      if(this.allCorrect){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }
        this.$emit('yay');
      }
    }
  },
  template: '#triple-bayes-template'
});

Vue.component('samples-chart', {
  props: {

    xdomain: {type: Array}, // ['H', 'T']
    xLabels: {type: Array}, // ['P(H'), 'P(T)'] optional. Defaults to x-domain if not set.

    dist: {type: Object}, // {H: 3, T: 1}
        
    chartHeight: {type: Number, default: 100},
    chartWidth: {type: Number, default: 100},
    margin: {
      type: Object, 
      default: function(){
        return {top: 20, right: 10, bottom: 40, left: 10};
      }
    },

    isControllable: {type: Boolean, default: false}, 

    // Minimum number of bars in y direction.
    minNumInY: {type: Number, default: 10},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '', dot: ''};
      }
    },

  },
  computed: {
    xScale(){
      // Can only use for categorical domain.
      return d3.scaleBand()
          .domain(this.xdomain).paddingInner(.1).range([0, this.chartWidth]);
    },
    xText(){
      return this.xLabels || this.xdomain;
    },

    maxBinLength(){
      return Math.max.apply(this, _.values(this.dist));
    },

    numBarsInY(){
      return Math.max(this.minNumInY, this.maxBinLength);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, this.numBarsInY]).range([0, this.chartHeight]);
    },
    yScaleBandwidth(){
      return this.chartHeight / this.numBarsInY; 
    },
    view(){
      return this.maxBinLength < this.minNumInY ? 'discrete' : 'continuous';
    }
  },
  data: function(){
    return {
      yPadBetweenBars: 2,
      isCreated: false,
      counts: {},
    }
  },
  mounted: async function() {
    this.countsFromProps();
    this.isCreated = true;

    // Add the axis
    // Hack: for some reason axis needs to get added after a delay, or it doesn't show up.
    await wait(500);
    const this_ = this;
    var xAxis = d3.axisBottom(this.xScale).tickFormat(function(d, ind){
      return this_.xText[ind];
    }); //.ticks(8);
    const chart = d3.select(this.$el).select('.container');
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);
  },
  watch: {
    dist: {
      handler(){
        this.countsFromProps();        
      },
      deep: true
    },
    counts: {
      handler(){
        this.$emit('dist-changed', {dist: _.mapValues(this.counts, x => Number(x))});  
      },
      deep: true
    },
  },
  methods: {
    prob(x){
      const total = _.sum(_.values(this.counts));
      return this.$root.roundTo(this.counts[x]/total*100, 0);
    },
    countsFromProps(){
      // Can't modify props, so we reactively copy it here.
      if (this.dist){
        for (var key in this.dist){
          Vue.set(this.counts, key, this.dist[key]);
        }        
      }      
    },
  },
  template: '#samples-chart-template'
});

// Put a buton inside a once-group to ensure it is only clicked once.
Vue.component('once-group', {
  data: function(){
    return {
      isClicked: false
    }
  },
  methods: {
    childClicked: function(childComponent) {
      if (this.isClicked){
        return;
      }
      this.isClicked = true;
    }
  },
  template: '#once-group-template',
});

// Allows hints to be shown. Buttons within the group can be clicked multiple times.
Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  computed: {
    lastChild(){
      if (this.clickedChildren.length > 0){
        return this.clickedChildren[this.clickedChildren.length-1];
      }
    },
    showHint(){
      if (DEBUG){
        return true;
      }
      if (this.lastChild){
        return this.lastChild.isNope;
      }
      return false;
    }
  },
  data: function(){
    return {
      clickedChildren: [],
    }
  },
  template: '#buton-group-template'
});


Vue.component('bold', {
  template: '#bold-template'
});

function makeComponent(componentName){
  Vue.component(componentName, {
    data: function(){
      return {

        problemTuples: [], // [ ['problem1', true], ['problem2', false] ]
        memory: null, // A variable for dumping short term component state.

        chapters: chapters,

        // State for 'ev-story'
        positivityPoints: 0,
        jokes: jokes,
        jokeInd: 0,
        clubs: clubs,
        clubInd: 0,


      };
    },
    computed: {
      // 'fakeout1': [false, true]
      problemToCorrectness(){
        return _.mapValues(_.groupBy(this.problemTuples, d => d[0]), arr => arr.map(d => d[1]));
      }
    },
    mounted: async function(){
      var this_ = this;
      bus.$on('answer-submitted', async function(input){        
        // Respond only if the input is within the current component.
        if (!isDescendant(this_, input)){
          return;
        }

        var avatar = firstAncestorOfComponent(input, 'avatar');
        if (!avatar){
          return;
        }

        var problemKey = avatar.$vnode.data.key;
        if (input.isYay){
          this_.addCorrectness(problemKey, true);          
        } 
        if (input.isNope){
          this_.addCorrectness(problemKey, false);          
        } 
      });
    },
    methods: {
      addCorrectness(key, isCorrect){
        this.problemTuples.push([key, isCorrect]);
//        console.log('logging ' + key + ': ' + isCorrect);
      },

      // Got the correct answer once.
      got: function(key){
//        console.log('calling "got" for ' + key);
        // Return the latest value
        if (this.problemToCorrectness[key]){
          var answers = this.problemToCorrectness[key];
          return answers[answers.length-1];
        } else {
          console.warn('checking for correctness of ' + key + ' which did not exist');
          return false;
        }
      },

      // Got the correct answer every time.
      perfect: function(key){
        if(this.problemToCorrectness[key] && _.every(this.problemToCorrectness[key])){
          return true;
        }
        return false;
      },
      nextJoke(params){
        this.positivityPoints += params.payoff;
        this.jokeInd++;
//        console.log(this.jokeInd + ' ' + this.jokes.length);
        if (this.jokeInd >= this.jokes.length){
          this.next();
        }
      },
      next(){
        this.$refs['pset'].next();
      }
    },
    template: '#' + componentName + '-template'
  });
}
['intro-scene', 'coin-flips', 'wizard-flips', 'chain-rule', 'ev-story', 'risk-reward', 'intro-to-pvalues', 'bayes-rule', 'thanks'].forEach(x => makeComponent(x));


Vue.component('next', {
  methods: {
    next(){
      if ('nope' in this.$attrs){
        this.$root.play('nope');
      }
      const pset = firstAncestorOfComponent(this, 'pset');
      if (pset){
        pset.next();
      }      
    }
  },
  template: '#next-template'
});


Vue.component('tree-diagram', {
  template: '#tree-diagram-template'
});


Vue.component('ev-tree', {
  props:{
    outcomes: {type: Array, default: () => [
        {certainty: 0.5, payoff: -1}, 
        {certainty: 0.5, payoff: 3}
      ]
    },
  },
  methods: {
    prettyString(val){
      return val > 0 ? '+' + val : val;
    }
  },
  template: '#ev-tree-template'
});


Vue.component('tree-node', {
  props:{
    height: {type: Number, default: 100},
    width: {type: Number, default: 80},

    emojiHeight: {type: Number, default: 30},
    emojiWidth: {type: Number, default: 30},
    emojiPadding: {type: Number, default: 8}, // distance from emoji to line    

    linePadding: {type: Number, default: 20}, // distance from top/bottom

    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 50, left: 50};
      }
    },

    color: {
      type: String, default: '01' // which path to highlight
    },

  },
  computed: {
    lineX(){
      return this.width - this.emojiWidth - this.emojiPadding;
    }
  },
  template: '#tree-node-template'
});


Vue.component('fulcrum', {
  props: {
    width: {type: Number, default: 400},
    certainty: {type: Number, default: null},
  },

  data: function(){
    return {
      numLeftRows: 0, 
      numRightRows: 0, 
      shouldLeftWobble: false,
      shouldRightWobble: false,

      animationTime: 500,
      betweenAnimationTime: 200,
    };
  },
  computed: {
    percent: function(){
      if (!this.certainty){
        return '';
      }
      const params = this.$root.paramsFromCertainty(this.certainty);
      return params.percent;
    },
    fulcrumStyle: function(){
      const certainty = this.certainty || 0.5;
      return {left: (this.width*certainty - 50) + 'px'};
    }
  },
  methods: {
    wobble: async function(num_times){
      for (var i=0; i<num_times; i++){
        await this.leftWobble();
        await this.rightWobble();
      }
    },
    leftWobble: async function(){
      this.shouldLeftWobble = true;        
      await wait(this.animationTime);
      this.shouldLeftWobble = false;
      await wait(this.betweenAnimationTime);      
    },

    rightWobble: async function(){
      this.shouldRightWobble = true;        
      await wait(this.animationTime);
      this.shouldRightWobble = false;
      await wait(this.betweenAnimationTime);      
    }
  },

  template: '#fulcrum-template'
});

// Child slot should call next() on the parent to advance.
Vue.component('pset', {
  computed: {
    elms(){
      return this.$slots.default.filter(x => x.tag).map(x => x.elm);
    }
  },
  data: function(){
    return {
      ind: 0, // active index
    };
  },

  mounted: function(){
    // Hides elements initially.
    if (!DEBUG){
      for (var i=1; i<this.elms.length; i++){
        this.elms[i].style.display = 'none';
      }      
    }

    this.$root.report(0);
  },
  methods: {
    async next(){
      this.ind = this.ind + 1;
      if (this.ind >= this.elms.length){
        this.$emit('done');
        return;
      }

      // grey out previous indices
      for (var i=0; i<this.ind; i++){
        this.elms[i].style.opacity = 0.5;   
        this.elms[i].classList.add('disabled');  
      }

      // make current ind, fully visible
//      this.elms[this.ind].style.display = 'block';
      this.elms[this.ind].style.display = 'grid';

      this.$root.report(this.ind);

      await wait(200);
      this.$root.scrollWindow();
    }
  },
  template: '#pset-template'
});


const chapters = [
{
  component: 'intro-scene',
  image: 'scroll.png',
  title: 'The beginning',
},
{
  component: 'coin-flips',
  description: 'Independent events',
  image: 'milk.png',
},
{
  component: 'wizard-flips',
  description: 'What does randomness look like',
  image: 'wizard.png',
},
{
  component: 'chain-rule',
  description: 'Chain rule of probability',
  image: 'girl.png',
},
{
  component: 'ev-story',
  description: 'Expected value',
  image: 'wizard.png',
},
{
  component: 'intro-to-pvalues',
  description: 'P-values', 
  image: 'scientist.png',
},
{
  component: 'bayes-rule',
  description: 'Bayes Rule', 
  image: 'crow.png',
},
{
  component: 'thanks',
  image: 'wizard.png',
  title: 'The End', 
},

];


function formatPct(certainty){
  return roundTo(certainty*100, 0) + '%';
}

// round_to(2.777777, 0) -> 3
// round_to(2.777777, 2) -> 2.78
function roundTo(x, num_decimals){
  return parseFloat(x.toFixed(num_decimals));
}


// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {
    chapters: chapters,
    chapterInd: DEBUG ? 1 : 0,
    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    showTOC: false,
    hasVolume: true,

    isScrolling: false,

    elapsedMinutes: null,
    elapsedSeconds: null,


    activeLoops: [],
    // Doesn't need to be reactive so this is OK.
    soundToCount: {},
  },
  watch: {
    chapterInd(){
    	this.playChapterAudio();
      if (this.chapterInd == 7){
        // scroll to the top
        window.scrollTo(0, 0);
      }
    },
    showTOC(){
      if (this.showTOC){
        this.play('open');
      } else {
        this.play('close');
      }
    }
  },
  computed: {
    currentChapter: function(){
      return this.chapters[this.chapterInd];
    },
    visibleScreen: function(){
      return this.currentChapter.component;
    },
    componentStyle(){
      if (this.showTOC){
        return {
          position: 'absolute',
          left: '180px',
          top: '0px',
          width: 'calc(100% - 180px)'
        };
      }
    }
  },
  mounted(){
    const loadTime = Date.now();
    var this_ = this;
    setInterval(function(){
      const seconds = (Date.now() - loadTime) / 1000;
      this_.elapsedMinutes = Math.floor(seconds/60);
      this_.elapsedSeconds = this_.roundTo(seconds % 60, 0);
    }, 1000);
  },
  methods: {
    formatPct: formatPct,
    roundTo: roundTo,
    playChapterAudio(){
 	    this.silenceLoops();
      this.playLoop(this.chapters[this.chapterInd].component);
    },
    nextChapter: async function(){
      this.chapterInd = Math.min(this.chapters.length-1, this.chapterInd+1);
    },
    play: function(soundName){
      if(!this.hasVolume){
        return;
      }

      if (!sounds[soundName]){
        return;
      }

      const clip = sounds[soundName].clip;
      if (clip){
        this._playClip(clip);
        return;
      }

      const clips = sounds[soundName].clips;
      if (clips){
        if (!(soundName in this.soundToCount)){
          this.soundToCount[soundName] = 0;
        }

        const ind = this.soundToCount[soundName] % clips.length;
        this.soundToCount[soundName]++;
        this._playClip(clips[ind]);
      }
    },
    playLoop(soundName){
      if(!this.hasVolume){
        return;
      }

      if (!sounds[soundName]){
        return;
      }
      const loop = sounds[soundName];
      if (this.activeLoops.indexOf(loop) == -1){
        loop.play(); 
        loop.fade(0, volume[soundName] || 1, 1000);
        this.activeLoops.push(loop);
      }
    },
    silenceLoops(){
      this.activeLoops.forEach(function(loop){
        loop.fade(1, 0, 1000); 
        loop.stop();
      });
      this.activeLoops = [];
    },
    _playClip(clip){
      clip.play().catch(function(error){
        console.log(error.toString());
      });            
    },
    async scrollWindow(){
      if (this.isScrolling){
        return;
      }

      var minNumScrolls = 3;
      this.isScrolling = true;
      // Scroll down a little bit and see if we should keep scrolling.
      // Stop scrolling if we've reached the bottom, 
      // Or if we have somehow traveled up (i.e. user has moved the mouse)
      while (true){
        const startY = window.scrollY;
        if (this.lastStartY >= startY && minNumScrolls <= 0){

          // Hack: Wait and try one more time to scroll before exiting. 
          // Seems like there might be a delay to add stuff to the DOM?
          await wait(150);
          window.scrollBy(0, 10);
          if (this.lastStartY >= window.scrollY){
            break;
          }
        }
        this.lastStartY = startY;
        window.scrollBy(0, 10);
        minNumScrolls--;
        await wait(30);
      }
      this.isScrolling = false;
    }, 
    report(ind){
      const chapterName = this.currentChapter.component;
      console.log('reporting ' + chapterName + ' ' + ind);
      gtag('event', 'statsstory_v1', {
        'event_category': 'read',
        'event_label': 'statsstory_v1' + '-' + chapterName + '-' + ind,
        'value': 1
      });
    },
    toggleVolume(){
  		this.hasVolume = !this.hasVolume;
  		if (this.hasVolume){
  			this.playChapterAudio();
  		} else {
  			this.silenceLoops();			
  		}
    },
    mainClick(event){
      //console.log('click');
      // When you click on the margins, event.target is the "app" node. 
      //this.mouseEvent = event; 

      if (!isDescendant(this.$refs['toc'], event.target)){
        this.showTOC = false;
      }
    },
    toggleTOC(){
  		this.showTOC = !this.showTOC;
    },

  } // end methods
});

</script>