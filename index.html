<!doctype html>


<head>
<meta charset="utf-8" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=59181255"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', '59181255');
</script>


<!-- todo: strip and remove the unused -->
<link href="https://fonts.googleapis.com/css?family=Itim|Dokdo|Fira+Sans:300,700" rel="stylesheet">

<script src="js/lodash.min.js"></script>
<script src="js/d3.v5.min.js"></script>
<script src="js/d3-array.v2.min.js"></script>

<script src="js/vue.js"></script>
<script src="js/vuex.js"></script>
<script src="js/utils.js"></script>

<style>

html, body, #app{
  height: 100%;
}

ul {
  list-style-type: square;
}

li, li * {
  font-size: 16px;
  margin-bottom: 8px;
}

.ev-answer-bar{
  transition: all 1s ease;
}

.rainbow-text{
  background: linear-gradient(to right, orange , yellow, green, cyan, blue, violet);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
.samples-chart{
  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}

.bayes-comp{
  display: inline-block;
  position:relative;
  width: 120px;
  height: 270px;
  vertical-align: top;
  text-align: center;

  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}
.bayes-comp .label *{
  font-size: 14px;
  text-align: center;
}
.bayes-comp .rainbow{
  position:absolute; 
  left: 8px;
  width:90%; 
  opacity:0.5
}

.dot{
  border-radius: 50%;
  width: 12px;
  height: 12px;
  background-color: blue;
  cursor: ns-resize;
}

text{
  font-size: 13px;
/*  font-family: 'Schoolbell', cursive;*/
}

*{
  font-family: 'Fira Sans', sans-serif;
  font-size: 18px;
  font-weight: 300;
}

div{
  margin-bottom: 16px;
}

.normal-div, .normal-div div{
  margin-bottom: 0px;
}
/* font-family: 'Gaegu', cursive; -- cute child like handwriting */
/* font-family: 'Dokdo', cursive; -- funky */
/* font-family: 'Bungee Shade', cursive; -- pop art caps */
h4{
  font-size: 18px;
  font-weight: 500;
}
a{
  color: #337ab7; /* bootstrap blue */
  text-decoration: none;
  cursor: pointer;
}
.note, .note *{
  color:#999;
  cursor: pointer;
}
.note .word{
  font-weight: 700;
}
.note:hover .word{
  text-decoration: underline;
}


img{
  max-width: 400px;
}
.handwriting, .handwriting *{
font-family: 'Itim';
}
.dialog-text, .dialog-text *{
font-family: 'Itim';
  font-size: 20px;
  width: 340px;
}
.small-dialog-text, .small-dialog-text *{
font-family: 'Itim';
  font-size: 22px;
}
.centered, .centered *{
  font-size: 22px;
}
button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px; 
  padding: 8px 16px;
  margin: 8px;
  max-width: 180px;
  display: inline-block;
}
.question button:hover, .question .clicked-button{
  color: white;
  background-color: black;
}
.bold{
  font-weight: 700;
}
.centered{
  display: grid;
  grid-template-columns: 1fr 500px 1fr;
  grid-template-rows: 1fr auto 1fr;
  grid-template-areas: 
    ". . ."
    ". centered-content ."
    ". . .";
  height: 500px;
}
.centered-content {
  grid-area: centered-content;
}
.centered button{
  margin: 0 auto;
  margin-bottom: 8px;
}
.hidden-at-first{
  opacity: 0;
  transition: opacity 1s;
}
.spin-and-pulse{
  position: absolute;
  animation: spin-and-pulse 5s ease 0s 1;
}
@keyframes spin-and-pulse {
  0% {
    transform: rotate(1turn);
  }
  5% {
    transform: rotate(0turn);
  }
  7% {
    transform: scale(1);
  }
  10% {
    transform: scale(1.2);
  }
  13% {
    transform: scale(1);
  }
  15% {
    transform: scale(1.1);
  }
  18% {
    transform: scale(1);
  }
}
.wobble{
  position: absolute;
  animation: wobble 5s ease 0s infinite;
}
@keyframes wobble {
  0% {
    transform: rotate(0turn);
  }
  5% {
    transform: rotate(0.003turn);
  }
  10% {
    transform: rotate(0turn);
  }
  12% {
    transform: rotate(0.003turn);
  }
  15% {
    transform: rotate(0turn);
  }
}
.bounce{
  position: absolute;
  animation: bounce 5s ease 0s infinite;
}
@keyframes bounce {
  0% {
    transform: translateY(20px);
  }
  3% {
    transform: translateY(-30px);
  }
  6% {
    transform: translateY(10px);
  }
  10% {
    transform: translateY(-10px);
  }
  12% {
    transform: translateY(0px);
  }
}
@keyframes mad-bounce {
  0% {
    transform: translateY(20px);
  }
  1% {
    transform: translateY(-30px);
  }
  2% {
    transform: translateY(10px);
  }
  3% {
    transform: translateY(-10px);
  }
  4% {
    transform: translateY(0px);
  }
}
.mad-bounce{
  position: absolute;
  animation: bounce 4s ease 0s infinite;  
}
.walk-drift{
  position: absolute;
  transition: left 3s;
}
.walk-bounce{
  position: absolute;
  animation: walk-bounce 0.8s ease 0s infinite;
}
@keyframes walk-bounce {
  0% {
    transform: translateY(0px);
  }
  25%{
    transform: translateY(-12px);    
  }
  50% {
    transform: translateY(0px);
  }
  75%{
    transform: translateY(-12px);    
  }
  100% {
    transform: translateY(0px);
  }
}
@keyframes fallover{
  100% {
    transform: rotate(0.3turn);
  }
}
.fallover{
  position: absolute;
  animation: fallover 1s ease-in 0s 1; /* to not stand back up:  normal forwards;  */
}
.point-container{
  width: 350px;
  display:flex; 
  justify-content:space-between; 
  margin: 0 auto;
}
.point{
  display: inline-block;
  width: 12px;
  height: 12px;
/*  border-radius: 50%;*/
  border: 2px solid black;
  margin-top: 4px;
  transition: all .5s ease;
}
.active-point{
  background-color: black;
  width: 20px;
  height: 20px;
  margin-top: 0px;
}
.circle{
  border-radius: 50%;
  width: 14px;
  height: 14px;
}
.circle.active-point{
  width: 20px;
  height: 20px;  
}
:not(.circle).active-point{
  width: 18px;
  height: 18px;
  margin-top: 1px;
}


.point:hover{
  background-color: #333;
}
.has-tooltip{
  position: relative;
}
.has-tooltip span{
  display: none;
  position:absolute;
  font-size: 10px;
  top: 24px;
  white-space: nowrap;
  background-color: rgba(0,0,0,0.5);
  padding: 8px;
  border-radius: 8px;
  color: white;
}
.has-tooltip:hover span{
  display: inline-block;
}
.extra-info, .extra-info *{
/*  font-size: 14px;*/
}
.smaller-children, .smaller-children *{
  font-size: 16px;
}
/* https://w3bits.com/rainbow-text/
.rainbow-text {
  background-image: repeating-linear-gradient(45deg, violet, indigo, blue, green, orange, red, violet);
  text-align: center;
  background-size: 800% 800%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow 4s ease infinite;
}
@keyframes rainbow { 
    0%{background-position:0% 50%}
    50%{background-position:100% 25%}
    100%{background-position:0% 50%} */
}
.fade-enter-active, .fade-leave-active {
  transition: opacity 1s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}
.slide-fade-enter-active, .slide-fade-leave-active {
  transition: all .3s ease;
}
.slide-fade-enter, .slide-fade-leave-to {
  transform: translateY(-300px);
  opacity: 0;
}
.story-point-silhouette{
  -webkit-filter: contrast(0%) brightness(90%);
  filter: contrast(0%) brightness(90%);
  cursor: pointer;
}
.story-point-silhouette:hover{
  -webkit-filter: none;
  filter: none;
}
.cropcircle{
    width: 100px;
    height: 100px;
    border-radius: 100%;
/*    background: #000 no-repeat center;*/
    background-size: cover;
    border: 4px solid black;
}

.small-avatar{
  width: 80px;
}
.coin{
  display: inline-block;
  width: 120px;
  cursor: pointer;
  vertical-align: top;
  word-wrap: break-word;

  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}

/* https://forum.vuejs.org/t/add-transitions-to-slide-up/27446/4 */
.slide-up-enter-active {
  transition: all .6s ease;
}
.slide-up-leave-active {
  transition: all .6s cubic-bezier(1.0, 0.5, 0.8, 1.0);
}
.slide-up-enter, .slide-fade-leave-to {
  transform: translateY(100vh);
  opacity: 0;
}


.intro-to-distributions .distribution{
  display: inline-block;
}

.intro-to-distributions .icon{
  width: 50px;
}

.question-table td:nth-child(2){
  width: 200px;
}

.sideways{
  transform: translateX(-50%) translateY(-50%) rotate(-90deg);
  position: absolute;
  top: 50%;
  left: 50%;
}

.font16, .font16 *{
  font-size: 15px;
}

.toc-chapter{
  display: grid;
  grid-template-columns: 50px auto;
}

.toc-chapter:hover{
  background-color: #ddd;
}

.toc-chapter:hover img{
    -webkit-filter: none;
  filter: none;
}

.hint, .hint *{
  font-size: 15px;
  margin: 8px;
  color: #777;
}

.ps, .ps *{  
  font-size: 15px;
  margin: 8px;
}


</style>
</head>


<body>


<div id="app" style="position:relative;left: 60px;width:calc(100% - 60px);" @click="mainClick($event)">

  <div ref="toc"
  :style="{'background-color': showTOC ? '#777' : '#ddd', 'color': showTOC ? 'white': 'black'}"
  style="width:60px;position: fixed; top:0px; left:0px; height: 100%; text-align: center; padding-top:8px"
  :style="{}">
    <img v-if="!showTOC" src="images/menu.png" style="cursor: pointer" @click="showTOC = !showTOC">
    <img v-if="showTOC" src="images/x.png" style="cursor: pointer" @click="showTOC = !showTOC">
    <span class="sideways handwriting" style="white-space: nowrap;" v-if="currentChapter.name">Chapter{{chapterInd}}: {{currentChapter.name}}</span>


<!--    <div v-for="(chapter, ind) in chapters"
         @click="chapterInd = ind"
         style="display:inline-block;">
      <img :class="{'story-point-silhouette': currentChapter !== chapter}"
          :src="'images/' + chapter.image" 
          style="width:50px">
      <span style="top:60px;">{{chapter.name}}</span>
    </div> -->
  </div> 
  <div v-if="showTOC" class="normal-div" style="position:fixed; z-index:1; width:200px;top:0px; left:60px; top:0;
    bottom:0;
overflow-y:scroll;padding-top:8px; background-color: #eee;">
    <div v-for="(chapter, ind) in chapters"
         @click="showTOC = false; chapterInd = ind"
         class="toc-chapter"
         style="padding:4px">
      <img :class="{'story-point-silhouette': currentChapter !== chapter}"
          :src="'images/' + chapter.image" 
          style="max-width:50px; max-height:100px">
      <span style="top:60px; font-size:12px; display: inline-block; margin:8px;"><bold style="font-size:12px">Chapter {{ind}}</bold><br> {{chapter.description}}</span>
    </div>
  </div>


<!--
<transition name="slide-fade">
<div v-if="show" style="background-color: blue; width:200px; height:200px;"></div>
</transition>
  <button @click="show = !show">
    Toggle render
  </button>
<button class="rainbow-text">Test</button>
<story :visible="true">
Are you here?
If so, you are in the <a @click="show('waiting')">right place</a>.
What is the probability that you will succeed?
</story>
<once-group>
<once-button>1/2</once-button>
<once-button>1/4</once-button>
<once-button>1/8</once-button>
</once-group>
<story ref="waiting">
I have been <a @click="show('changing')">waiting</a> for you. 
</story>
<story ref="changing">
The times are changing.
The prophecies are unclear, but the times are changing.
This planet is <a @click="show('new-world')">changing</a>.
</story>
<story ref="new-world">
<div>
You are going to bring us into this new world of <span class="animated infinite jello" style="display:inline-block">uncertainty</span>.
</div>-->


<keep-alive>
  <component v-bind:is="visibleScreen"></component>
</keep-alive>



</div> <!-- end #app -->


<script type="text/x-template" id="glitch-template">
  <div>
    <img v-if="showStart" :src="'images/'+start" style="width:100%">
    <img v-if="!showStart" :src="'images/'+end" style="width:100%">
  </div>
</script>


<script type="text/x-template" id="intro-to-pvalues-template">
<pset>

<avatar image="scroll.png">
  <div>
    This is a flashback to the recent past in which Elena was still with us...
  </div>
  <next>Next</next>
</avatar>

<avatar 
  text="Elena, my crow friend is really smart.">
  <next>Next</next>
</avatar>


<avatar 
  text="I'm going to get her evaluated by Wei the Scientist to see if her intelligence is statistically significant.">
  <next>Next</next>
</avatar>


<avatar image="scientist.png"
  text="My my, what a pretty little bird.">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw caw!">
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="I can certainly design an intelligence test worthy of this lovely creature.">
  <next>Next</next>
</avatar>

<avatar image="scientist.png">
  <div>
    Although, I guess the default belief is that you're just an average crow.
  </div>
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Cawwww (Don't insult my intelligence, human).">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    Another name for default belief is <bold>null hypothesis</bold>.
  </div>
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png">
  <div>My apologies, clever crow. I'm just trying to explain what a p-value is. A <bold>p-value</bold> is the probability that you'll see as extreme a result if the null hypothesis is true.</div>
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png"
  text="I ran Elena through my first battery of intelligence tests, and got a p-value of 0.6.">

  <div>
    What does a p-value of 0.6 mean?
  </div>

  <buton-group>
    <buton nope>There's a 60% chance that Elena is smarter than the average crow</buton>
    <buton nope>There's a 60% chance that Elena is an average crow</buton>
    <buton yay>There's a 60% chance of observing as extreme a result even if Elena is just an average crow</buton>

    <template v-slot:hint>
    P-values only speak about the probability of obtaining the results if the null hypothesis is true. It isn't the probability of the null hypothesis being correct, or the alternative hypothesis ("Elena is smarter than an average crow") being correct.
    </template>
  </buton-group>

</avatar>

<avatar image="scientist.png">
  <div>
    Correct. A P-value assumes the null hypothesis (aka that Elena is just an average crow) and says how extreme the results are under this assumption.
  </div>
  <next>Next</next>
</avatar>

<avatar  image="scientist.png"
  text="I ran Elena through a different intelligence test and got a p-value of 0.01. What does a p-value of 0.01 mean?">

  <buton-group>
    <buton yay>There's a 1% chance of observing as extreme a result even if Elena is just an average crow</buton>
    <buton nope>There's a 1% chance that Elena is an average crow</buton>
    <buton nope>There's a 1% chance that the results are due to chance</buton>

    <template v-slot:hint>
    P-values only speak about the probability of obtaining the results if the null hypothesis is true. It isn't the probability of the null hypothesis being correct, or the alternative hypothesis being correct.
    </template>
  </buton-group>
</avatar>

<avatar 
  image="scientist.png"
  text="For one of my experiments, what would be a more exciting result? A p-value of 0.01 or 0.001? ">

  <buton-group>
    <buton nope>0.01</buton>
    <buton yay>0.001</buton>

    <template v-slot:hint>
    A p-value of 0.01 would mean that there's a 1% chance that we would observe as extreme a result if the potion didn't work. While that's nice, it would be nicer if there were only a 0.1% chance that the result would occur.
    </template>
  </buton-group>
</avatar>

<avatar image="scientist.png">
  <div>
    Yes! We're hoping that Elena is smarter than an average crow, so a lower p-value is better. 
  </div>
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="Oh interesting...">
  <next>What?</next>
</avatar>

<avatar image="scientist.png"
  key="trap"
  text="Some other scientists have been testing crows as well. And found crows that tested more intelligently at a p-value of 0.05 or p-value of 0.1. Which crow do you think is smarter?">

  <buton-group>
    <buton nope>0.05</buton>
    <buton nope>0.1</buton>
    <buton yay>Not enough info</buton>
  </buton-group>

</avatar>


<avatar image="brain.png">
  <div>
    {{ got('trap') ? "Correct! There's not enough info." : 'Good attempt, but not quite.' }}  
  </div>

   <div>
    The surprising thing about p-values is that they don't say anything about <bold>effect size</bold>. A p-value just tells you how likely something is under the null hypothesis. 
  </div>
  <next>Next</next>
</avatar>


<avatar image="scientist.png">
  <div>
    The two other crows scored as such. Which one do you think is the smarter bird?
  </div>

<div style="margin-bottom:24px;">
<bold>Bird A</bold>
<div>Scores compared to average:
  <div style="font-size:14px">+2% +0% +6% +6% +8% +3% +4% +0% +9% +4% +7% +5% +9% +9% +4% +3% +7% +7% +1% +8% +3% +9% +5%</div>
</div>
<div>Average effect size: 5%</div>
<div>P-value: 0.05</div>
</div>


<div>
<bold>Bird B</bold>
<div>Scores compared to average:
  <div style="font-size:14px">+47% +46% +6% +0% -7% -3% +13% +0% -10% +28% -4% +30% +1% +48% +37% +26% +47% +46% -13% +15% +33% +33% +26% </div>
</div>
<div>Average effect size: 11% </div>
<div>P-value against placebo: 0.1</div>
</div>

<once-group>
  <next>Bird A</next>
  <next>Bird B</next>
</once-group>
</avatar>

<avatar image="brain.png" text="It's hard to say, right? It's possible to have a greater average effect size but a less compelling p-value.">
<next>Next</next>
</avatar>

<avatar text="I don't care about these other birds. What is Elena's p-value?">
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="Well, based on the exxperiments I've run so far... Elena's p-value is 0.14.">

  <next>Next</next>
</avatar>

<avatar text="WHAT!">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="CAW!??! (WHAT!??!)">
  <next>Next</next>
</avatar>

<avatar 
  image="scientist.png">

  <div>
    Scienitific journals usually require a p-value of 0.05 or smaller to publish. If a p-value is less than 0.05, it is called <bold>statistically significant</bold>. Experimenting with another battery of tests yielded a p-value of 0.14. Which is...
  </div>

  <buton nope>Statistically significant</buton>
  <buton yay>Not statistically significant</buton>
</avatar>


<avatar text="I DO NOT accept this!!!!">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Cawwww!! (Indeed, what a gross miscalculation!!)">
  <next>Next</next>
</avatar>


<avatar image="scientist.png">
  <div>
    Well "statistically significant" sounds really important, but it's just the scientific name for p-value less than a threshold. It's up to the domain expert to determine if the result is meaningful or not.
  </div>
  <next>Next</next>
</avatar>

<avatar text="I am SO OFFENDED (on Elena's behalf).">
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png"
  text="How should a p-value of 0.14 be interpreted?">

  <buton nope>Weak evidence that Elena is the same as an average crow</buton>
  <buton yay>Weak evidence that Elena is smarter than an average crow</buton>
  <buton nope>Strong evidence that Elena is the same as an average crow</buton>
  <buton nope>Strong evidence that Elena is smarter than an average crow</buton>

</avatar>

<avatar image="scientist.png">
  <div>
    Correct. Although a p-value of 0.14 does not meet the threshold for "statistical significance", it is still weak evidence that the results may be unusual under the null hypothesis (aka default world view). There was only a 14% chance that we would observe as extreme a result. 
  </div>

  <next>Next</next>
</avatar>

<avatar image="scientist.png">
  <div>
    When you get a borderline p-value like 0.14 it is worth investigating further, perhaps redesigning part of the experiment to better capture signal from the noise. But you have to be careful not to p-hack like in the xKCD green jelly bean case.
  </div>
  <next>Next</next>
</avatar>

<avatar text="Well, I don't need a p-value to tell me that Elena is no average bird.">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw... (Sad...)">
  <next>Next</next>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>
  <ul>
    <li>The <bold>null hypothesis</bold> is the default belief (e.g. it's not possible to learn by drinking a potion).</li>
    <li>You learned that a <bold>p-value</bold> is the chance of witnessing as extreme an outcome under the null hypothesis.</li>
    <li>p-values below a threshold of 0.05 are called <bold>statistically significant</bold> but that does not mean it is necesarrily useful.</li>
    <li>A smaller p-value does not imply a larger effect size.</li>
  </ul> 

  <div>
  If you liked this section, you may like the book, <a href="https://smile.amazon.com/p-value-Stories-Actually-Understand-Statistics/dp/0321629302">What is a P-Value Anyways?</a>
  </div>

  <buton @click="$root.nextChapter()">Next chapter</buton>

</avatar>


</pset>
</script>


<script type="text/x-template" id="intro-to-distributions-template">
<div style="width:600px; margin: 0 auto;" class="intro-to-distributions">


<div class="point-container" style="width: 300px">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="pointClass(point)"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>

<avatar key="intro"
  v-if="show('intro')"
  image="cop.png"
  text="Hm. The Bad Wizard is appearing a lot recently.">
  <buton @click="set('2')">Next</buton>
</avatar>

<avatar key="2"
  v-if="show('2')"
  image="cop.png"
  text="In the past, I've employed a variety of strategies to handle bad guys.">

<pre>
Professor Grubby was vanquished by nicely asking them to go away.
Grimy Man was vanquished by nicely asking them to go away.
Agent Horrible was vanquished by giving them an unsolved math problem.
Mighty Starlet was vanquished by giving them an unsolved math problem.
Master Rapid Arsonist was vanquished by challenging them to a duel.
Ruthless Swan was vanquished by challenging them to a duel.
</pre>

<buton @click="set('3')">Next</buton>
</avatar>

<avatar key="3"
  v-if="show('3')"
  image="cop.png"
  text="If we plot all the methods we used to vanquish bad guys in the past, we get this frequency plot.">

<div class="handwriting">Ways Commando Gauss has vanquished bad guys</div>

<samples-chart 
:xdomain="['Ask to go away', 'Give an unsolved math problem', 'Challenge to a duel', 'Reason with them']"
:samples="['Ask to go away', 'Ask to go away', 'Ask to go away', 'Challenge to a duel', 'Challenge to a duel', 'Challenge to a duel', 'Challenge to a duel', 'Give an unsolved math problem', 'Give an unsolved math problem', 'Reason with them']"
:chartHeight="150" :chartWidth="600" />

<div>
  What was the most likely method of vanquishing? 
</div>

<table class="question-table">
  <tr>
    <td>How many more times more likely is a foe to have been vanquished by "challenging them to a duel" than by "reasoning with them"?</td>
    <td><input-box :right="4">&nbsp;&nbsp;</input-box></td>
  </tr>

  <tr>
    <td>How many times more likely is a foe to have been vanquished by "asking them to go away" than by "giving them an unsolved math problem"?</td>
    <td><input-box :right="1.5">&nbsp;&nbsp;</input-box></td>
  </tr>

  <tr>
    <td>What is the probability that a vanquished foe was vanquished by asking them to go away?</td>
    <td><input-box :right="30">%</input-box></td>
  </tr>

  <tr>
    <td>What is the probability that a vanquished foe was vanquished by challenging them to a duel?</td>
    <td><input-box :right="40">%</input-box></td>
  </tr>
</table>



</avatar>

<avatar key="4"
  v-if="show('4')"
  image="cop.png">
  <template v-slot:text>
    An easier way to answer these questions about probabilities, is to convert the frequency chart to create a *distribution*.
  </template>


  <samples-chart 
:xdomain="['Ask to go away', 'Give an unsolved math problem', 'Challenge to a duel', 'Reason with them']"
:samples="['Ask to go away', 'Ask to go away', 'Ask to go away', 'Challenge to a duel', 'Challenge to a duel', 'Challenge to a duel', 'Challenge to a duel', 'Give an unsolved math problem', 'Give an unsolved math problem', 'Reason with them']"
:chartHeight="150" :chartWidth="600" />

  <div>
    A distribution has:
    - outcomes on the x-axis.
    - probabilities on the y-axis.
  </div>

  <div>
    To create the distribution, sum up all the counts and divide each value by the sum. 
  </div>

  <div>
    // would be great to figure out a way to get people to do this??
  </div>

  <buton @click="set('5')">Next</buton>
</avatar>

<avatar key="5"
  v-if="show('5')"
  image="cop.png"
  text="Once you have a distribution, you can answer questions like ___?">

  Relative probabilities.
</avatar>

<avatar key="6"
  v-if="show('6')"
  image="wizard.png"
  text="Oh boy! Is this the lesson on distributions?! Can I play??!">
  <buton yay>Yes</buton>
  <buton>No</buton>
</avatar>

<avatar key="7"
  v-if="show('7')"
  image="wizard.png"
  text="That sure isn't a way to make friends! I don't need your permission to show you my EVIL PLAN distribution.">

  CHECK THIS OUT:


  What is the probability that ____? 
  How many more times likely is it to ___?
</avatar>

<avatar key="8"
  v-if="show('8')"
  image="wizard.png"
  text="Now checkout my WORLD CHAOS distribution. ">

  What is the average amount of chaos I unleash on the world?

  Pro tip: ___.
</avatar>

<avatar key="9"
  v-if="show('9')"
  image="wizard.png"
  text="Aren't distributions useful??">

  CONGRATS 

  You learned: ___.
</avatar>

</div>
</script>


<script type="text/x-template" id="once-group-template">
<div :class="{disabled: isClicked}"><slot></slot></div>
</script>


<script type="text/x-template" id="intro-scene-template">
<div style="width:600px; margin: 0 auto;">

<div key="intro"
  v-if="show('intro')"
  style="text-align:center;">

  <div class="handwriting" style="font-size:48px;">The Evil Wizard's Guide to Statistics</div>

  <img src="images/wizard.png" style="width:300px">

  <div style="max-width:500px; margin: 0 auto">
    <div>
    Not really motivated by a normal statistics class, but you'll get out of bed to save the world?
    </div>

    <div>
    Learn probability and statistics to stop the Evil Wizard.
    </div>
  </div>

  <buton @click="$root.nextChapter()">PLAY</buton>
</div> <!-- end intro -->

</div>
</script>


<script type="text/x-template" id="next-template">
  <buton @click="next()"><slot></slot></buton>
</script>


<script type="text/x-template" id="coin-flips-template">
<pset>


<!-- why is calc 50% being so large?? 
<avatar key="HH"
  image="monster.png" 
  text="What is the probability that I toss a fair coin twice and get HH?">

  <buton nope="1/2 is the probability of tossing a single coin and getting H. Getting two heads in a row is rarer than that.">1/2</buton>
  <buton yay>1/4</buton>
  <buton nope="Assume it is a fair coin that lands on heads with 50% probability.">Not enough info</buton>

</avatar>-->


<avatar>
  <p>
    Not too long ago, I was just like you. Just a regular nerdy wizard on the internet.
  </p>
  <p>
    But one day, it dawned on me that humans really don't understand probability and statistics.
  </p>

  <p>
    And that was when I realized... I could do good... by doing evil... if I could cause mischief in the world that everyone would be forced to notice probability in their daily life.
  </p>

  <p style="font-style:italic">
    And that is where you come in.
  </p>

  <next>Oh dear</next>
</avatar>


<avatar
  text="Bobby the Green Monster was unkind to me before I got my wizarding powers. Let's see if my evil plan has worked.">
  <next>Next</next>
</avatar>


<avatar 
  image="monster_cry.png"
  text="Ugh! Peanut butter and jelly again?">
  <next>What's wrong?</next>
</avatar>

<avatar image="monster.png" 
  text="Every day my mom packs me lunch by flipping a coin. If it lands tails, I get a peanut butter jelly sandwich. If it lands heads, I get my favorite -- a deluxe fried potato & cream cheese roll. ">
  <next>Is that good?</next>
</avatar>

<avatar image="monster_yay.png" 
  text="Duh it's good. You're missing out if you've never had it before.">
  <next>Next</next>
</avatar>


<avatar key="HH"
  image="monster.png" 
  text="What is the probability that after my mom flips a fair coin twice, I'll be eating peanut butter and jelly two days in a row?">

  <buton nope="1/2 is the probability of tossing a single coin and getting H. Getting two heads in a row is rarer than that.">1/2</buton>
  <buton yay>1/4</buton>
</avatar>

<avatar image="brain.png"
  key="HH-explanation">
  <div>
    Right. Coin flips are <bold>independent</bold>. Knowing the result of one event does not give you information about the other events, because coins have no memory. 
  </div>
  <div>
    To calculate the probability that multiple independent events will occur together, you can multiply them. todo: show picture
  </div>
</avatar> 

<avatar key="HHH"
  image="monster_cry.png" 
  text="Well, truth is I've been eating peanut butter and jelly a LOT. What is the probability that after my mom tosses a fair coin three times, I'll be eating peanut butter and jelly three days in a row?">

  <buton-group>
    <buton nope>1/2</buton>
    <buton nope>1/3</buton>
    <buton yay>1/8</buton>

    <template v-slot:hint>
      <div>
        By the same logic as before, coin flips are independent events (i.e. a result doesn't affect the next result). The probabilities of the joint event: seeing X AND Y can be combined with multiplication. The chance of getting HHH is 1/2 x 1/2 x 1/2.
      </div>

      <div>
        todo: show the picture
      </div>
    </template>
  </buton-group>
</avatar>

<avatar key="HHHHH"
  image="monster.png" 
  text="If I got peanut butter and jelly the last five days in a row, am I more likely to get peanut butter and jelly OR potato cream cheese today?">

  <buton-group>
    <buton @click="memory='userSaidT'" nope>Peanut butter & jelly</buton>
    <buton @click="memory='userSaidH'" nope>Potato & cream cheese</buton>
    <buton yay>It's 50-50</buton>

    <template v-slot:hint>
      <div v-if="memory == 'userSaidT'">
        <div>That's the Gambler's Fallacy... a common misconception that events that haven't occured are more likely to occur.</div>

        <div>Coins have no memory, so just because tails came up a lot, doesn't mean that heads is more likely to come up in the future.</div>
      </div>

      <div v-if="memory == 'userSaidH'">
        <div>That's the Hot Hand Fallacy... a common misconception that events that have occurred recently are "hot" and more likely to come up.</div>

        <div>Coins have no memory, so just because tails came up a lot, doesn't mean that tails is any more likely to come up in the future.</div>
      </div>

    </template>
  </buton-group>
</avatar>

<avatar image="monster.png" 
  text="Yeah! If mom's coin is fair, I still have a 50-50 chance to get potato & cream cheese since coins have no memory.">
  <next>Next</next>
</avatar>


<avatar key="100H"
  image="monster.png" 
  text="Okay, but if I told you my mom's coin doomed me to peanut butter and jelly the last 100 days, what do you think I would get today?">

  <buton-group>
    <buton>Peanut butter and jelly</buton>
    <buton yay>Potato and cream cheese</buton>
    <buton>It's 50-50</buton>
  </buton-group>
</avatar>

<avatar image="brain.png">
  <div>
   {{got('100H') ? 'Yeah!': 'Not quite.'}} The probability of seeing 100 tails in a row on a fair coin is so tiny... 1/<exp base="2" pow="100"/>. If all the <exp base="2" pow="80"/> atoms in the universe were flipping coins, it still would only have a 1 in million chance of happening. 
 </div>

   <next>How many days have you been eating PB&J?</next>
</avatar>

<avatar image="monster.png"
  text="I've been eating PB&J for the last 10 days. Poor me. Do you think mom's coin is fair?">


  <next>Yes</next>
  <next>No</next>
  <next>I don't know</next>
</avatar>

<avatar image="monster.png"
  text="Well, I guess the probability of getting 10 PB&J sandwiches in a row is...">
  <input-box/>
</avatar>

<avatar image="monster.png"
  text="So, this should happen every how many days or so?">
  <input-box/>
</avatar>

<avatar image="monster.png"
  text="Mom has been packing lunch for me for 1540 days, so I guess this was bound to happen.">
  <next>Er...</next>
</avatar>

<avatar image="monster_cry.png"
  text="I guess I'll wait a few more days to see if I get a potato & cream cheese sandwich.">
  <next>Er...</next>  
</avatar>


<avatar image="brain.png">
  <ul>
    <li>You learned about <bold>independent events</bold></li>
    <li>You learned to calculate the <bold>joint probability</bold> of independent events.</li>
    <li>You learned that there are <exp base="2" pow="80"/> atoms in the universe.</li>
  </ul> 


  <next @click="$root.nextChapter()">Accept Quest</next>
</avatar>

<avatar>
Haha! That was great... Bobby's gonna be stuck eating peanut butter and sandwiches. 
</avatar>

</pset>
</script>

<script type="text/x-template" id="wizard-flips-template">
<pset>

<avatar  
  text="By the way, have you met my crow friend Elena?">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>

<avatar text="Elena found some hilarious coins. They say H on one side, and A on the other. Let's play with them! ">
  <next>Next</next>
</avatar>

<avatar 
  text="Of these 3 coins, 2 are fair and 1 is unfair. Let's see if you can find the unfair one.">

  <div>Click the coins to flip them at least 10 times each.</div>
  <div>When you have enough info, submit your guess.</div>

  <coin></coin>
  <coin></coin>
  <coin :bias="0.7"></coin>

  <div class="handwriting">The unfair coin is:</div>

  <buton-group>
    <buton nope>A</buton>
    <buton nope>B</buton>
    <buton yay>C</buton>

    <template v-slot:hint>
      Hint: One coin has a tendency to land on one side more than the other.
    </template>
  </buton-group>

</avatar>

<avatar >

  {{ perfect('3coins') ? 'Oh. You got me. That coin was biased to land on H, 70% of the time.' : "HAAAHHAA! It's pretty hard to find the biased coin, right? And that was when the coin was biased to land on H, 70% of the time!"}} What is the weakest bias with which you can easily tell that the coin is biased?

  <biased-coin-machine></biased-coin-machine>
  <next>Done with this</next> 

</avatar>

<avatar 
  text="HAHA this is fun. I again have 3 coins. 2 are fair, 1 is unfair. Find the unfair coin.">

  <div>Click the coins to flip them.</div>
  <div>When you have enough info, submit your guess.</div>

  <coin></coin>
  <coin pattern="haha"></coin>
  <coin></coin>

  <div class="handwriting">The unfair coin is:</div>

  <buton-group>
    <buton nope>A</buton>
    <buton yay>B</buton>
    <buton nope>C</buton>

    <template v-slot:hint>
      Hint: Look at the pattern of coin flips. The wizard may be having a joke at your expense.
    </template>
  </buton-group>
</avatar>


<avatar 
  text="HAHA yes, that coin always says HAHA. It lands on heads 50% of the time, but it's unfair because I know what's coming next. Genius, isn't it??">

  <next>Next</next>
</avatar>


<avatar 
  text="OKOK last one. Find the unfair coin.">

  <div>Click the coins to flip them.</div>
  <div>When you have enough info, submit your guess.</div>

  <coin></coin>
  <coin pattern="human"></coin>
  <coin></coin>

  <div class="handwriting">The unfair coin is:</div>

  <buton-group>
    <buton nope>A</buton>
    <buton yay>B</buton>
    <buton nope>C</buton>

    <template v-slot:hint>
      Hint: Look at the pattern of coin flips. One of these coins is a bit shy.
    </template>
  </buton-group>
</avatar>


<avatar 
  text="You got it. Interesting isn't it. This coin never has long streaks of one thing or the other. Humans tend to generate 'random' sequences like this. But they aren't random, because nature doesn't mind having long streaks.">

  <next>Next</next>
</avatar>


<avatar 
  text="HAHAHA. Aren't these coins great? Isn't Elena great? ">
  <next>Yes</next>
</avatar>

<avatar text="Elena is my only friend actually. Bobby and the other kids at school aren't nice to me.">
  <next>Oh</next>
</avatar>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>

<avatar text="Bobby isn't actually a green monster by the way. I just drew him like that... because I could.">
  <next>Oh</next>
</avatar>

<avatar text="You wanna see this other monster that I cursed?">
</avatar>


<avatar image="brain.png">
  <div>
    Well, at least you learned
  </div>
  <ul>
    <li>What real randomness feels like</li>
  </ul> 

  <buton @click="$root.nextChapter()">Next Story</buton>
</avatar>

</pset>
</script>


<script type="text/x-template" id="bayes-rule-template">
<pset>

<avatar text="Elena??? Where's Elena??">
  <next>NEXT?</next>
</avatar>

<avatar text="Oh noooo my one and only friend!">
  <next>NEXT?!?!!</next>
</avatar>

<avatar image="brain.png"
        text="Calm down calm down CALM DOWN.">
  <next>Breathe</next>
</avatar>

<avatar text="Wait... does this have to do with the scientist??">
  <next>Next</next>
</avatar>

<avatar text="Do you think Elena was offended by her p-value?">
  <next>Possibly</next>
</avatar>


<avatar text="But Elena is a very clever self sufficient crow. Chances are that she's okay.">
  <next>Next</next>
</avatar>


<avatar text="But then again, I've never seen Elena so ruffled before.">
  <next>Next</next>  
</avatar>

<avatar text="There's too much conflicting info!! Is Elena okay or not??">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    You learned about this in school... use <bold>Bayes Rule</bold>.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
  P(A|B) = <big-frac style="position:relative; top:12px">
    <template v-slot:num>
      P(B|A) × P(A)
    </template>
    <template v-slot:den>
      P(B)
    </template>
  </big-frac> ?
  </div>
  <next>Next</next>
</avatar>


<avatar image="brain.png"
        text="No... use the more useful form of Bayes Rule...">
    <next>Next</next>
</avatar>

<avatar>
  <div>
  P(H|D) = <big-frac style="position:relative; top:12px">
    <template v-slot:num>
      P(D|H) × P(H)
    </template>
    <template v-slot:den>
      P(D)
    </template>
  </big-frac>
  </div>

  <div>
    The same formula as above, but where H is hypothesis and D is data?
  </div>
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  Yes, if you remove the normalization constant P(D), you get:
  </div>

  <div>P(H|D) <span style="font-size:28px">∝</span> P(D|H) × P(H)</div>

  <div>
  <span style="font-size:28px">∝</span> means proportional to.
  </div>


  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
    This tells you how to incoporate new information into your belief:
  </div>
  <div>
    Your belief after seeing the data  P(H|D)
  </div>

  <div>
    is proportional to your prior belief P(H)
  </div>

  <div>
    multiplied by
  </div>

  <div>
    the likelihood of the evidence under your prior belief P(D|H)
  </div>
  <next>Next</next>
</avatar>

<avatar text="Hm... what is my prior belief on Elena being okay?">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Elena is a very self-sufficient bird, so 80% of the times she's disappeared on me, she has been okay.
  </div>

  <div>Drag the bars to show the odds that Elena is okay. This is called your <bold>prior belief</bold>.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [1, 1], correct: [4, 1], isActive: true, isDraggable:true}}">
  </triple-bayes>

</avatar>

<avatar image="brain.png">
  <div>
    Now need to take into account the data that Elena was last seen visibly ruffled. 
  </div>
  <div>
    To incorporate this data, Bayes Rule says to look at the likelihood of the data under each hypothesis P(D|H). 
  </div>

  <div>
    We need to compute the ratio of
  </div>

  <div>
    P(Ruffled|OK) vs P(Ruffled|Not OK).
  </div>
</avatar>


<avatar>
  <div>
    Out of 100 OK birds, I imagine 10 of them might be ruffled.
    Out of 100 Not OK Birds, probably 80 are ruffled.
  </div>

  <div>
    Drag the bars to reflect the <bold>likelihood ratio of the evidence</bold>.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [4, 1]}, likelihood: {dist: [1, 1], correct: [1, 8], isActive: true, isDraggable: true}}">
  </triple-bayes>

</avatar>

<avatar 
  text="Bayes Rule says our belief after seeing the evidence is our prior belief multiplied by the likelihood ratio.">

  <div>
    The belief after we have considered the evidence is called the <bold>posterior belief</bold>.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [4, 1]}, likelihood: {dist: [1, 8]}, posterior: {isActive: true}}">
  </triple-bayes>

  <div>
    Looking at the posterior belief, what is the probability that Elena is OK?
  </div>
  <buton yay>33%</buton>
  <buton nope>40%</buton>
  <buton nope>80%</buton>
</avatar>

<avatar text="That's not great odds.">
  <next>Oh no</next>
</avatar>


<avatar text="The other thing is she didn't leave a note.">
  <div>
  50 out of 100 OK people don't leave a note when they are ruffled.<br>
  90 out of 100 Not OK people don't leave a note when they are ruffled.
  </div>

  <div>
  Use this information to create a likelihood ratio.<br>
  </div>

  <triple-bayes 
    :hypotheses="['Ok', 'Not OK']" 
    :config="{prior: {dist: [4, 8]}, likelihood: {dist: [1, 1], correct: [5, 9], isActive: true, isDraggable: true}, posterior: {isActive:true}}">
  </triple-bayes>
</avatar>

<avatar text="Oh no!!! Only a 22% chance she's okay??">
  <next>Next</next>
</avatar>

<avatar text="Wait I hear a cacophony of crows!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    What's the probability that I'd hear a cacophony of crows under each hypothesis?
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png"
  text="Get out of your head and follow the noise!">
  <next>Next</next>
</avatar>

<avatar text="ELENA!!!">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="CAWW (HELP)">
  <next>Next</next>
</avatar>

<avatar text="There you are Elena!">
  <next>Next</next>
</avatar>

<avatar text="Was I right to infer that there was a 78% chance you were in trouble?">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="CAWW CAWW (HELP HELP)">
  <next>Next</next>
</avatar>

<avatar text="You get away from her, mean crows!">
  <next>Next</next>
</avatar>

<avatar text="Thank you for helping me find Elena.">
  <next>Next</next>
</avatar>

<avatar text="Elena, I hope that p-value nonsense didn't cause you to run away.">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="...">
  <next>Next</next>
</avatar>

<avatar text="Not only are you the cleverest crow I know, you're my best friend.">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="c... aw...">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  While this is all touching, let's take another look at Bayes Rule that saved the day.
  </div>
  <next>Next</next>
</avatar>

<avatar image="brain.png"
      text="This is the Taxi-cab problem by psychologists Kahneman & Tversky.">

  <div style="max-width: 350px; margin:0 auto; margin-bottom: 16px; line-height:1.4em; text-align: justify" class="smaller-children">
  30% of the cabs in the city are Blue and 70% are Green.
  A cab was involved in a hit and run, and the witness identified the cab as Blue. 
  The court tested the reliability of the witness under the circumstances that existed on the night of the accident, and concluded that the witness correctly identified each one of the two colors 80% of the time and failed 20% of the time.
  What is the probability that the cab involved in the accident was Blue?
  </div>

  <div>
    Use the widget to solve the problem.
  </div>

  <triple-bayes 
    :hypotheses="['B guilty', 'G guilty']" 
    :config="{prior: {dist: [1, 1], correct: [3, 7], isActive: true, isDraggable: true}, likelihood: {dist: [1, 1], correct:[4, 1], isActive:true, isDraggable: true}, posterior: {isActive: true}}">

    <template v-slot:yay>
      <buton @click="set('bayes-rule')">Next</buton>
    </template>

    <template v-slot:hint>

      <div>
      <div><bold>Prior</bold></div>
      Ignoring the eye witness evidence, and just considering the base rate of cabs in the city gets the prior.
      </div>

      <div>
      <div><bold>Likelihood Ratio</bold></div>
      The likelihood ratio of the data P(D|H) given that the eyewitness saw a blue cab consists of
      </div>
      <big-frac>
        <template v-slot:num>
          P(Saw blue|Blue guilty)
          </template>
          <template v-slot:den>
          P(Saw blue|Green guilty)
        </template>
      </big-frac>
    </template>
  </triple-bayes>

</avatar>


<avatar>
  <div>
    <div>
      So even though there is pretty accurate eyewitness testimony pointing to Blue cabs, given the low base rate of Blue cabs, it's still pretty uncertain which cab company was at fault.
    </div>
    <next>Next</next>
  </div>
</avatar>

<avatar image="brain.png"
  text="Congrats, you solved a problem that <X% of people get correct todo: find number. By using both the prior and likelihood of evidence, you avoided the human tendency to just use one or the other.">

  <next>Next</next>
</avatar>

<avatar text="Hey... are you my friend? ">
  <next>Next</next>
</avatar>

<avatar text="I feel like we've hit the three tenets of friendship from Chapter 4.">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    We have consistency — you've hung out with me for {{$root.elapsedMinutes}} minutes and {{$root.elapsedSeconds}} seconds.
  </div>
  <next>Next</next>
</avatar> 

<avatar text="And positivity — you look like you're having fun.">
  <next>Next</next>
</avatar>

<avatar text="And vulnerability — you know that I don't have friends.">
  <next>Next</next>
</avatar>

<avatar>
  <div>
  So... final question... I guess we're friends now? 
  </div>

  <next>Yes</next><next>No</next>
</avatar>

</pset>
</script>

<script type="text/x-template" id="pset-template">
  <div class="pset">
    <slot></slot>
  </div>
</script>

<script type="text/x-template" id="coin-template">
  <div @click="flip" class="coin normal-div">
    <img v-if="isShowingH" src="images/coin_heads.png" style="width:100px">
    <img v-if="!isShowingH" src="images/coin_tails.png" style="width:100px">
    <div ref="flip-string" style="font-size:13px;" :style="flipStringStyle">{{flipString}}</div>
    <samples-chart v-if="flips.length > 8" :xdomain="xDomain" :samples="samples"></samples-chart>
  </div>
</script>


<script type="text/x-template" id="biased-coin-machine-template">
<div>
  <div>Adjust the bias, and click coin to flip.</div>
  <span>Lands H with {{$root.formatPct(bias)}} probability:</span>
  <input v-model="slider" type="range" min="0" max="100" style="width:200px">

  <div>
  <coin ref="coin" :bias="bias" style="width:300px"></coin>
  </div>
</div>
</script>


<script type="text/x-template" id="chain-rule-template">

<pset>

<avatar text="I liked Veronica but she didn't like me back.">
  <next>Next</next>
</avatar>

<avatar 
  image="girl.png" 
  text="I'm Veronica and I only date monsters that are tall and have beards.">

  <next>Next</next>
</avatar>


<avatar 
  text="So I cast a spell to cause many monsters to be unable to grow beards...">
  <next>Oh</next>
</avatar>


<avatar image="girl.png"
  text="Is that why it's so hard to find someone I like?">
  <next>Next</next>
</avatar>

<avatar image="girl_happy.png"
  text="Naw, I don't think that's it. I'm just waiting for my Mister Right.">
  <next>Next</next>
</avatar>


<avatar 
  image="girl.png" 
  text="1/2 of all monsters are tall and 1/4 of monsters have beards.">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    Let's write what Veronica told us in math language.
  </div>

  <div>
    The probability of a monster having a beard can be written as:
  </div>

  <div>
    P(beard) = 1/4
  </div>

  <div>
    This is pronounced as, "the probability of a beard is 1/4".
  </div>

  <div>
    Veronica also told us
  </div>

  <div>
    P(tall) = 1/2
  </div>
</avatar>
<avatar key="fakeout1"
  image="girl.png" 
  text="What is the probability that a random monster is datable? i.e. What is P(tall AND beard)?">

  <buton-group>
    <next>1/8</next>
    <buton nope="Hm... 1/3 doesn't make sense. Try again.">1/3</buton>
    <buton nope="Although 1/4 is the number of monsters have beard, it's not clear that all bearded monsters are tall. Try again.">1/4</buton>
    <buton nope="There aren't even that many tall monsters! Try again.">3/4</buton>
    <buton yay>Not enough info</buton>

    <template v-slot:hint>
      Not quite. It is only valid to compute the joint probability by multiplication if being tall and having a beard are <bold>independent</bold> — like coin flips.
    </template>

  </buton-group>
</avatar>


<avatar image="brain.png">

  <div>
    {{got('fakeout1') ? "Right! It's not possible to say." : "Nice try, but there's a catch." }}
  </div>

  <div>
    It is only valid to multiply two probabilities to calculate the joint probability if the two events are <bold>independent</bold> — like coin flips.
  </div>

  <div>
     In our case, independence occurs if a monster's height <bold>does not provide any information</bold> on the greatness of a monsters hair. 
  </div>

  <div>
    So knowing the monster is tall or short, cannot make it any more or less likely that they have a beard. If this is the case, then it's safe to say that having a beard and being tall are independent.
  </div>

  <next>Next</next>
</avatar>


<avatar image="girl.png" 
        text="I guess I do see some correlation between being tall and having a beard, so they're not independent. If I know a monster is tall, there's a 1/3 chance that they have a beard.">
</avatar>



<avatar image="brain.png">

  <div>
  Veronica told us a <bold>conditional probability</bold> when she said:
  </div>

  <div>
   The probability a monster has a beard is 1/3 <bold>given</bold> that we know the monster is tall. 
  </div>

  <div>
    Conditional probabilities are written like P(X|Y). The bar "|" is  pronounced as "given", and P(X|Y) indicates the probability of X given that we know Y to be true.
  </div>


  <div>
    Veronica told us P(beard|tall) = 1/3.
  </div>


  <div>
   This is read as "the probability a monster has a beard given that we know the monster is tall is 1/3". 
  </div>


  <next>Next</next>
</avatar>


<avatar  image="brain.png">

  <div>
    We can use the conditional probability to calculate P(tall AND beard) without assuming independence:
  </div>

  <div>
    P(tall AND beard) = P(tall) x P(beard|tall)
  </div>

  <div>
    The formula says to get the probability of finding a tall monster with a beard = (probability of finding a tall monster) x (probability that a tall monster has a beard).
  </div>

  <next>Try it</next>
</avatar>


<avatar key="tall-hair" 
        image="girl.png" 
        text="Okay so what is the probability that a random monster is datable?">

  <div>What is P(tall AND beard)?</div>

  <div class="extra-info">Facts from before:
  <ul>
    <li>P(tall) = 1/2</li>
    <li>P(beard) = 1/4</li>
    <li>P(beard | tall) = 1/3</li>
  </ul>
  </div>

  <buton-group>
    <buton yay>1/6</buton>
    <buton nope="We said that being tall and having a beard are not independent, so we can't just multiply 1/2 x 1/4.">1/8</buton>
    <buton nope="Are you just multiplying things together? Try again.">1/24</buton>
    <buton nope="The answer isn't always 'Not enough info'...">Not enough info</buton>
  </buton-group>
</avatar>


<avatar image="girl_happy.png" text="Kyaaa!! Thank you for your help so far. But I forgot... ">
  <next>Yes?</next>
</avatar>


<avatar key="fakeout2"
        image="girl.png"
        text="I also want my monster to have tattoos. 1/5 of monsters have tattoos.">

  <div>In math speak, P(tattoos) = 1/5.</div>
  <div>What is P(tall, beard, tattoos)? <span style="color:#777"><- Note: This is a more compact way of writing P(tall AND beard AND tattoos). The comma is pronounced "and".</span></div>

  <div class="extra-info">Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(beard) = 1/4</li>
      <li>P(beard|tall) = 1/3</li>
      <li>You calculated P(beard, tall) = 1/6</li>
    </ul>
  </div>

  <buton-group>
    <buton coy>1/30</buton>
    <buton nope="Remember, we want to use P(beard|tall), not P(tall).">1/40</buton>
    <buton nope="Wait, are you just blindly multiplying numbers? Stop that.">1/120</buton>
    <buton yay>Not enough info</buton>
  </buton-group>
</avatar>


<avatar 
    image="brain.png">

  <div>
    {{ got('fakeout2') ? 'Right.': 'Not quite.' }} Again, it's not possible to say!
  </div>

  <div>
    To get P(tattoo, beard, tall), we can't just multiply
    P(tattoo) x P(beard, tall) without assuming independence.
  </div>

  <div>
    We need another conditional probability.
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    And this brings us to the <bold>Chain Rule of Probability</bold>.
  </div>

  <div class="smaller-children">
    P(tattoo, beard, tall) = <br>
    <span style="color:#7570b3">P(tall)</span> x <span style="color:#1b9e77">P(beard | tall)</span> x <span style="color:#d95f02">P(tattoo | beard AND tall)</span>
  </div>

  <div class="smaller-children" style="margin-left: 16px;">
    <div>
      First, consider the <span style="color:#7570b3">probability of the monster being tall</span>.
    </div>

    <div>
      Then, consider the <span style="color:#1b9e77">probability of a tall monster having a beard</span>.
    </div>

    <div>
      Then, consider the <span style="color:#d95f02">probability that a tall monster with a beard, would have a tattoo</span>.
    </div>

    <div>
      Multiply together to get monsters that are tall and have a beard and have tattoos.
    </div>
  </div>

  <div>
    Basically, the Chain Rule says that when bringing a new item to the joint probability, condition on all the events that already exist.
  </div>

  <next>Try it</next>
</avatar>


<avatar key="problem3" 
        image="girl.png" 
        text="Ooh yes, I've heard of the Chain Rule. Here are the numbers that you'll need.">

  <div>
  What is P(tall, beard, tattoos)?
  </div>

  <div class="extra-info">
  Facts from before:
  <ul>
    <li>P(tall) = 1/2</li>
    <li>P(beard) = 1/4</li>
    <li>P(beard|tall) = 1/3</li>
    <li>You calculated P(beard AND tall) = 1/6</li>
    <li>P(tattoos) = 1/5</li>
    <li>P(tattoos|tall) = 1/6</li>
    <li>P(tattoos|tall AND beard) = 1/7</li>
  </ul>
  </div>

  <div>
  P(tall, beard, tattoos) =  1/<input-box :right="42" @yay="set('problem4')">
    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So P(tall, beard, tattoos) = P(tall) x P(beard | tall) x P(tattoos | beard AND tall). 
      </div>
    </template>
  </input-box>
  </div>

</avatar>


<avatar key="problem4" 
        image="girl.png" 
        text="Yes, thank you! But silly us! We forgot to include that these tall, bearded, tattooed monsters also need to be... around my age and single.">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(beard) = 1/4</li>
      <li>P(beard|tall) = 1/3</li>
      <li>You calculated P(beard AND tall) = 1/6</li>
      <li>P(tattoos) = 1/5</li>
      <li>P(tattoos|tall) = 1/6</li>
      <li>P(tattoos|tall AND beard) = 1/7</li>
      <li>You calculated P(beard, tall, tattoos) = 1/42</li>
      <li>P(around her age | tall, beard, tattoos) = 1/5</li>
      <li>P(single | tall, beard, tattoos, around her age) = 1/2</li>
    </ul>
    </div>


    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So in the case of four events, P(tall, beard, tattoos, single) = P(tall) x P(beard | tall) x P(tattoos | beard AND tall) * P(beard AND tall AND tattoos | single). 
      </div>
      <div>
        What is it for five events?
      </div>
    </template>

    <div>
    P(tall, beard, tattoos, around her age, single) =
    </div>

    1/<input-box :right="420"/>
</avatar>


<avatar image="girl_shock.png"
        text="That's not very many people!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Even though each individual criteria may not seem picky, requiring that a monster have all the traits leaves Veronica with a very small dating pool. Ha-ha!
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>But hey, at least Veronica's pickiness taught you the Chain Rule.</div>

  <next>Next</next>
</avatar>

<avatar 
    image="brain.png"
    key="decompose" >

  <div>
    We had been decomposing:
  </div>

  <div style="font-size:16px">
    P(tall, beard, tattoos) = P(tall) x P(beard|tall) x P(tattoos | tall AND beard).
  </div>

  <div>
    But notice... that we can also decompose it as:
  </div>

  <div style="font-size:16px">
    P(tall AND beard and tattoos) = P(beard) x P(tattoos | beard) x P(tall | tattoos AND beard).
  </div>

  <div>
    We can decompose it in any order we choose to, depending on what information we have on hand.
  </div>

  <div>
    How many different ways are there to decompose P(tall, beard, tattoos) using the Chain Rule?
  </div>
  <input-box :right="6" :feedback="true"/>
</avatar>


<avatar image="wizard.png"
        text="Aw... you foiled my plan by showing Veronica how picky she was. But....">
  <ul>
    <li>You learned about independence</li>
    <li>You learned about Chain Rule</li>
    <li>You learned to not be too picky ❤️</li>
  </ul> 

  <next>Are you doing this all for revenge?</next>
</avatar>


<avatar text="I have a lot of free time because I don't have any friends.">
  <next>Surely you must have some friends though?</next>
</avatar>

<avatar text="No, I really don't.">
  <next>Let's get you friends</next>
</avatar>

<avatar text="Uh... it might be harder than you think...">
  <buton @click="$root.nextChapter()">Next chapter</buton>
</avatar>

</pset>

</script>

<script type="text/x-template" id="ev-story-template">
<pset>


<avatar text="How do I make friends?">
  <next>Next</next>
</avatar>

<avatar image="brain.png">

<div>The <a target="_blank" href="//www.youtube.com/watch?v=hmJyWreER7A">internet</a> claims that the 3 tenets of friendships are...</div>

<ul>
  <li>positivity</li>
  <li>consistency</li>
  <li>vulnerability</li>
</ul>
<next>Thanks internet</next>
</avatar>

<avatar>
  <div>To become friends, interactions need to be positive. That makes sense.</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    I'm pretty good at telling jokes. I'll memorize some jokes from the <a target="_blank" href="//www.rd.com/funny-stuff/short-jokes/">internet</a> and make people laugh.
  </div>
  <next>Next</next>
</avatar>

<avatar text="Hm... but jokes don't always hit. A bad joke might actually be a negative.">
  <next>Next</next>
</avatar>

<avatar text="Take this joke for instance... should I tell it?">
  <div>
  40% of the time it lands favorably<br>
  60% of the time it fails<br>
  </div>

  <next>Uh...</next>
</avatar>

<avatar image="brain.png"
        text="The answer depends on the payoffs.">
  <div>
    If the wizard get +1 positivity point when it lands.<br>
    And -1 positivity point when it fails<br>
  </div>

  <div>
    Then it seems like a bad deal, because on average the wizard loses -0.2 positivity points each time I tell the joke. 
  </div>

  <div>
    This average is called the <bold>expected value</bold>.
  </div>

  <next>Next</next>
</avatar>


<avatar>
  <div>
    Hm... everyone already thinks I'm weird.
  </div>

  <div>
    I feel like, if the joke fails I might lose 1 point. But if the joke lands, I'll gain 5 points because there's nowhere to go but up for my reputation. Ha-ha!
  </div>

  <div>
    So I need to calculate the expected value of:
  </div>

  <div>
    40% joke lands favorably, +5 points.<br>
    60% jake fails, -1 point.<br>
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    To calculate the expected value, multiply the probability of each outcome occuring with the reward for the outcome, and add everything together.  
  </div>

  <div>The expected value of the joke in question is?</div>

  <input-box :right="1.4"/>
</avatar>


<avatar>
  <div>So, I should tell the joke?</div>
  <buton-group>
    <buton yay>Yes</buton>
    <buton nope>No</buton>

    <template v-slot:hint>
      The wizard should tell the joke because it has positive expected value, given that there aren't options that are higher in expected value.
    </template>
  </buton-group>
</avatar>

<avatar text="Okay... here goes...">
  <next>Next</next>
</avatar>

<avatar text="Where are average things manufactured?">
  <next>Next</next>
</avatar>

<avatar>
  <div><bold>The satisfactory!</bold></div>
  <next @click.native="memory='haha'; positivityPoints+=5">Ha-ha!</next> 
  <next @click.native="memory='eh'; positivityPoints-=1">Eh...</next>
</avatar>

<avatar>
  <div v-if="memory=='haha'">
    Yay!! That joke landed! So I gain 5 positivity points.
  </div>
  <div v-if="memory=='eh'">
    Aw... it seems like that joke didn't land. So I lost 1 positivity point. I'm still glad I told the joke, because it was positive expected value.
  </div>
</avatar>

<avatar>
  <div>
Help me decide whether to tell each joke or not, by calculating their expected value.
</div>
<next>Next</next>
</avatar>

<div>
  <ev-joke 
    v-for="(joke, index) in jokes" 
    v-if="index <= jokeInd" 
    :joke="joke"
    :key="joke.lead"
    @done="nextJoke"
   />
</div>

<avatar image="brain.png">
  <div>
Okay, I think that's enough for positivity. The second tenet of friendship is consistency... you need to find a structure to make people repeatedly hangout with you.
</div>
<next>Next</next>
</avatar>

<avatar text="Hm... I could join a CLUB.">
  <next>Next</next>
</avatar>

<avatar text="todo: come up with acrostic for CLUB">
  <next>Next</next>  
</avatar>

<avatar text="But which club should I join to maximize the number of interactions?">
  <next>Next</next>
</avatar>

<avatar>

  <div>
    I could join the fencing club...
  </div>

  <next>Next</next>
</avatar>

<avatar>
  <div>I've plotted the average number of interactions other people have experienced from joining the fencing club.</div>

  <distribution :outcomes="[{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.3},{x: 4, y: 0.4},]" xLabel="Number of interactions" yLabel="Probability" title="Fencing Club 💖" />

  <div>This type of plot with possibilities on the x-axis, and probabilities on the y-axis is called a <bold>distribution</bold>.</div>
</avatar>

<avatar>
  <div>
    Hm... I wonder how many interactions I would get from joining the fencing club?
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  Just like before, you can take the expected value. Once the data is plotted as a distribution is the same as finding the balance point (where would the distribution balance on your finger if it were made of cardboard).
  </div>

  <visual-ev-click 
    :outcomes="clubs[0].outcomes"
    :title="clubs[0].name + ' 💖'"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="That's not a bad number of interactions. What about the math team?">

  <visual-ev-click 
    :outcomes="clubs[1].outcomes"
    :title="clubs[1].name + ' 💖'"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="What about Biology Olympiad?">
  <visual-ev-click 
    :outcomes="clubs[2].outcomes"
    :title="clubs[2].name + ' 💖'"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="The other club I was considering was the Knitting Circle.">
  <visual-ev-click 
    :outcomes="clubs[3].outcomes"
    :title="clubs[3].name + ' 💖'"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar>
  <div>
    Okay, so which club should I join? 
  </div>

  <buton-group>
    <buton nope>Fencing Club</buton>
    <buton nope>Math Team</buton>
    <buton yay>Bio Olympiad</buton>
    <buton nope>Knitting Circle</buton>

    <template v-slot:hint>
      Join the club with the maximum expected number of interactions.
    </template>
  </buton-group>
</avatar>

<avatar>
  <div>
Cool, so now I'm a member of Bio Olympiad. And I have {{positivityPoints}} positivity points. What's next?
</div>
<next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
For the final ingredient in making friends... you need to be vulnerable.
</div>
<next>Next</next>
</avatar>

<avatar>
  <div>
Eh... I'm not going there. Who needs friends anyways?
</div>
<next>Next</next>
</avatar>

<avatar>
  <div>
Why bother... I have Elena. 
</div>
<next>Next</next>
</avatar>

<avatar image="" text="(silence)">
  <next>Next</next>
</avatar>

<avatar text="Elena??? Where's Elena??">
  <buton @click="$root.nextChapter()">Next chapter</buton>
</avatar>

</pset>
</script>


<script type="text/x-template" id="visual-ev-click-template">

<div>

<div>
Click where you think the balance point is...
</div>


<div style="position:relative">

<distribution ref="distribution" 
  :outcomes="outcomes"
  :title="title"
  :xLabel="xLabel"
  :yLabel="yLabel" ></distribution>

<div style="position:absolute; top:0px; z-index:1"   
  class="overlay"
  :style="overlayStyle"
  @mousemove="mouseX = getRelativeMouseX($event)"
  @mouseenter="isMouseover = true"
  @click.once="distributionClicked">

  <!-- tracks the user mouseover and user answer -->
  <div v-if="isMouseover" 
       style="border-left:2px solid #7570b3; width:1px; height:200px; position:absolute; bottom: -48px; pointer-events:none;"
       :style="trackerStyle"></div>

  <!-- show the real answer -->
  <div ref="answer-marker"
       v-if="answerPx" 
       class="ev-answer-bar"
       :style="{left: answerPx + 'px'}"
       style="border-left:2px solid #1b9e77; width:1px; height:200px; position:absolute; bottom: -48px; pointer-events:none;"></div>
</div>


<div v-if="answerReal" class="smaller-children">
  <div>
  You <span style="color:#7570b3">guessed {{$root.roundTo(guessReal, 1)}}</span>. The <span style="color:#1b9e77">true answer of  {{$root.roundTo(answerReal,1)}}</span> was {{isUserClose  ? 'pretty close!' : 'far off.'}} {{ isUserClose ? 'Good job!' : 'Needs work.' }}
  </div>

  <buton @click.native="$emit('done')">Next</buton>
</div>


</div>
</div>
</script>

<script type="text/x-template" id="ev-joke-template">
<div>
<avatar>
  <div>So, I should tell the joke?</div>

  <div v-for="outcome in joke.outcomes">
    {{outcome.certainty*100}}% chance joke {{outcome.present}}, {{outcome.payoff}} points
  </div>

  <buton @click.native="userAnswer='Yes'">Yes</buton>
  <buton @click.native="userAnswer='No'">No</buton>
</avatar>


<avatar v-if="ev > 0 && userAnswer == 'No'">
  <div>Oh, what's wrong with this joke? It seems like positive expected value to me: </div>
  <div>{{evCalculation}}</div>
</avatar>

<avatar v-if="ev < 0 && userAnswer == 'Yes'">
  <div>Hmm... I'm not sure if this is a good idea: </div>
  <div>{{evCalculation}}</div>
</avatar>

<avatar v-if="ev < 0 && userAnswer == 'No'">
  Good call... that joke has negative expected value so I probably shouldn't tell it.
  <next @click.native="finish(0)">Next</next>
</avatar>

<avatar v-if="ev === 0 && userAnswer !== null">
  <div>
    The expected value is 0, so you could go either way on this one. 
  </div>

  <next v-if="userAnswer == 'Yes'"  
        @click.native="forceTell=true">Next</next>

  <next v-if="userAnswer == 'No'"  
        @click.native="finish(0)">Next</next>
</avatar>

<pset v-if="(ev > 0 && userAnswer == 'Yes') || forceTell">
<avatar text="Okay... here goes...">
  <next>Next</next>
</avatar>

<avatar :text="joke.lead">
  <next>Next</next>
</avatar>

<avatar>
  <div><bold>{{joke.punchline}}!</bold></div>
  <next>{{chosenOutcome.payoff > 0 ? 'Ha-ha!' : 'Eh...'}}</next>
</avatar>


<avatar v-if="userAnswer !== null && chosenOutcome.payoff < 0">
  <div>
    Aw... it seems like that joke {{chosenOutcome.past}}. So I lost {{chosenOutcome.payoff}} positivity points. I'm still glad I told the joke, because it was positive expected value.
  </div>

  <div>
    {{evCalculation}} points in expectation.
  </div>

  <next @click.native="finish(chosenOutcome.payoff)">Next</next>
</avatar>

<avatar v-if="userAnswer !== null && chosenOutcome.payoff > 0">
  <div>
    Yay!! That joke {{chosenOutcome.past}}! So I gain {{chosenOutcome.payoff}} positivity points.
  </div>
  <next @click.native="finish(chosenOutcome.payoff)">Next</next>
</avatar>

</pset>

</div>
</script>

<script type="text/x-template" id="risk-reward-template">
<div>

<!-- jump to a diferent problem -->
<div class="point-container" style="width:220px">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="pointClass(point)"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>


<!--<transition name="fade" mode="out-in">-->

<avatar key="intro"
  v-if="show('intro')"
  image="bear.png" 
  text="Do you dare play with a bear???">
  <buton @click="set('ev')">Yes</buton>
</avatar>

<avatar key="ev"
  v-if="show('ev')"
  image="bear.png" 
  text="What would you rather? (a) I pay you 1 coin or... (b) I pay you 4 coins with 20% certainty, and 80% of the time you get nothing.">
  <buton @click="set('ev-right')" yay>(a) 1 coin with certainty</buton>
  <buton @click="set('ev-wrong')" nope>(b) 4 coins with 20% certainty</buton>
</avatar>

<avatar key="ev-right"
  v-if="show('ev-right')"
  image="bear.png" 
  text="Well, that's correct.">

  <div>
   On average, the 4 coins with 20% probability is only worth 0.8 coins on average, so the 1 coin with certainty is worth more.
  </div>

  <buton @click="set('100')">Next</buton>
</avatar>

<avatar key="ev-wrong"
  v-if="show('ev-wrong')"
  image="bear_money.png" 
  text="Heh heh ."
  animation="spin-and-pulse">

  <template v-slot:overlay>
    <div>
      Player! Your answer was incorrect.
    </div>

    <div>
      On average, the 4 coins with 20% certainty is only worth 0.8 coins.
    </div>

    <div>
      AND it's riskier because the payout isn't guaranteed.
    </div>

    <div>
      By the risk-reward tradeoff, you ought to be compensated for extra risk with higher average reward.
    </div>

    <div style="font-size: 10px">
      The bear offered a bum deal because 4 coins with 20% probability was higher risk and lower average reward.
    </div>

    <buton @click="set('100')">Next</buton>
  </template>
</avatar>

<avatar key="100"
  v-if="show('100')"
  image="bear.png" 
  text="What if I offered you the chance to pick one choice and play 100 times? Which would you pick?">
  <buton @click="set('100-right');" yay>(a) 1 coin with certainty</buton>
  <buton @click="set('100-wrong')" nope>(b) 4 coins with 20% certainty</buton>
</avatar>


<avatar key="100-right"
  v-if="show('100-right')"
  image="bear.png" 
  text="Yeah, that's correct.">

  <div>
   Playing 100 times doesn't change the fact that 4 coins with 20% probability has the lower expected value.
  </div>

  <buton @click="set('100-chart')">Next</buton>
</avatar>

<avatar key="100-wrong"
  v-if="show('100-wrong')"
  image="bear_money.png" 
  text="Heh. Wrong."
  animation="spin-and-pulse">

  <div>
   Playing 100 times doesn't change the fact that 4 coins with 20% probability has the lower expected value.
  </div>

  <buton @click="set('100-chart')">Next</buton>
</avatar>

<centered key="100-chart"
  v-if="show('100-chart')">
  <div>
  Running a simulation where a computer really executes the 4 coins with 20% probability deal 100 times, yields... (chart)
  </div>
  
  <div>
    We see the average result is near 80, although random variation resulted in totals near 60 and 100. But in __% of casses, taking the guaranteed 100 coins would have been a better choice.
  </div>

  <div>
    This is a sneak peak of the Binomial Distribution which you will see later in this adventure. Statisticians have invented distributions to model many common scenarios. 
  </div>

  <buton @click="set('congrats')">Stats is cool</buton>
</centered>

<centered key="congrats"
  v-if="show('congrats')">
  
  <ul>
    <li>You learned about expected value (the average)</li>
    <li>You got a sneak peak of the usefulness statistical distributions</li>
  </ul> 

  <buton @click="finish()">Next section</buton>
</centered>

<!--</transition> -->
</div>
</script>


<!-- begin templates -->
<script type="text/x-template" id="bold-template">
<span class="bold"><slot></slot></span> 
</script>


<script type="text/x-template" id="distribution-template">
<div class="distribution" style="display:inline-block">
<div v-if="title" style="text-align: center; font-size: 16px; text-transform:capitalize" :style="titleStyle">{{title}}</div>

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
      <rect v-for="outcome in outcomes"
          :x="xScale(outcome.x)"
          :y="yScale(outcome.y)"
          :width="xScale.bandwidth()"
          :height="chartHeight - yScale(outcome.y)"
          :key="outcome.x"
          fill="#EA27A2"/>

      <!-- top of bar 
      <text v-for="outcome in outcomes" 
        :x="xScale(outcome.x) + xScale.bandwidth()/2 - 8"
        :y="yScale(outcome.y) - 2">
        {{ outcome.y }}
      </text>-->
    </g>
</svg>
</div>
</script>

<!-- <triple-bayes 
  :hypotheses="['Nice', 'Evil']" 
  :config="{prior: {dist: [1, 1], correct: [1, 2], isActive: true, isDraggable:true}, likelihood: {dist: [10, 1], isActive: true, isDraggable: true}, posterior: {}}"></triple-bayes> -->
<script type="text/x-template" id="triple-bayes-template">
<div style="display:inline-block">

<div v-if="hasKey('prior')" class="bayes-comp" :style="compStyle('prior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('prior')}}</div>
    <div>{{subtitle('prior')}}</div>
  </div>

  <samples-chart 
  :xdomain="hypotheses"
  :dist="arrToDist(priorArr)"
  :isDraggable="isDraggable('prior')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :showRatio="true"
  :colors="colors"
  @dist-changed="priorChanged" /> 
</div>


<div v-if="hasKey('likelihood')" class="bayes-comp" :style="compStyle('likelihood')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('likelihood')}}</div>
    <div>{{subtitle('likelihood')}}</div>
  </div>
  <samples-chart
  :xdomain="hypotheses"
  :dist="arrToDist(likelihoodArr)"
  :isDraggable="isDraggable('likelihood')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  @dist-changed="likelihoodChanged" /> 
</div>

<div v-if="hasKey('posterior')" class="bayes-comp" :style="compStyle('posterior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('posterior')}}</div>
    <div>{{subtitle('posterior')}}</div>
  </div>
  <samples-chart 
  :xdomain="hypotheses"
  :dist="posteriorDist"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :showRatio="true"
  :colors="colors"
  ref="posterior-samples-chart" /> 
</div>

<div v-if="showFeedback && !allCorrect" class="handwriting">
  <div>Not quite. Try again!</div>
  <slot name="hint"></slot>
</div>


<div v-if="showFeedback && allCorrect" class="handwriting">
  <div>Correct!</div>
  <slot name="yay"></slot>
</div>

<div v-if="(isDraggable('prior') || isDraggable('likelihood')) && !(showFeedback && allCorrect)">
<buton @click="submitClicked">Submit</buton>
</div>

  </div>
</script>

<script type="text/x-template" id="samples-chart-template">
<div style="position:relative; display:inline-block" class="samples-chart">

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated && counts" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
<!--      <rect v-for="(count, x) in counts"
          :x="xScale(x)"
          :y="chartHeight - yScale(count)"
          :width="xScale.bandwidth()"
          :height="yScale(count)"
          :key="x"
          fill="#D1D9E0"/>  -->

        <g v-for="x in xdomain">
          <rect v-for="countInd in counts[x]"
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x]) + yScaleBandwidth*(countInd-1)+2"
          :width="xScale.bandwidth()"
          :height="yScaleBandwidth-2"
          :key="x + countInd"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="Math.max(0, chartHeight - yScale(counts[x]) - (isDraggable ? 8 : 2))">
        {{ counts[x] }}
      </text>

      <text v-if="showRatio"
        v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 8"
        :y="chartHeight + 40"
        fill="#999">
        {{ prob(x) }}%
      </text>

    </g>
</svg>

  <div v-for="x in xdomain" 
      v-if="isDraggable && counts"
      class="dot"
      style="position:absolute"
      draggable="true"
      @dragstart="dragstart(x)"
      @dragend="dragend"
      @drag="drag(x, $event)"
      :style="dotStyle(x)"></div>


</div>
</script>

<script type="text/x-template" id="avatar-template">
<div style="position: relative; width:600px; margin:0 auto; margin-top:16px">

 <div class="cropcircle" :style="cropCircleStyle" style="display:inline-block; vertical-align:top">
 </div>


<div style="display:inline-block; width:400px">
    <div>{{text}}<slot name="text"></slot></div>

    <slot></slot>
</div>

</div>
</script>



<script type="text/x-template" id="live-text-template">
  <div>
    <transition-group name="fade" tag="span">
      <span v-for="(token, i) in visibleTokens" :key="i" v-html="token">
      </span>
    </transition-group>
  </div>
</script>


<script type="text/x-template" id="monk-head-template">
<div class="handwriting normal-div"
      style="display:inline-block; position:relative; white-space: nowrap;">
  <img src="images/monk_head.png" style="width:80px;">

  <!-- speech pointing to left -->
  <div v-if="hasSlot('lhs')">
    <div style="width:22px; border:1px solid black; transform:rotate(50deg); position:absolute; top:-14px; left:10px;"></div>
    <div style="position:absolute; top: -40px; left:0px;">
      <slot name="lhs"></slot>
    </div>
  </div>

  <!-- speech pointing to right -->
  <div v-if="hasSlot('rhs')">
    <div style="width:24px; border:1px solid black; transform:rotate(310deg); position:absolute; top:-14px; left:50px;"></div>
    <div style="position:absolute; top: -40px; left: 60px;">
      <slot name="rhs"></slot>
    </div>
  </div>

</div>
</script>

<script type="text/x-template" id="note-template">
<span class="note" @click="showExpansion=!showExpansion">
<span class="word"><slot></slot>
</span> 
<span v-if="showExpansion" class="text">({{text}}<slot name="text">)</slot></span>
</span>
</script>


<script type="text/x-template" id="exp-template">
<var>{{base}}<sup>{{pow}}</sup></var>
<!--<span>{{base}}<sup>{{pow}}</sup></span>-->
</script>


<script type="text/x-template" id="big-frac-template">
<div style="display: inline-block; text-align:center" class="normal-div">
    <div style="border-bottom:1px solid">{{num}}<slot name="num"></slot></div>
    <div>{{den}}<slot name="den"></slot></div>
  </td>
</div>
</script>

<script type="text/x-template" id="frac-template">
<var><sup>{{num}}</sup>&frasl;<sub>{{den}}</sub></var>
</script>

<script type="text/x-template" id="buton-template">
<span style="margin-bottom:0px; position:relative; display:inline-block; vertical-align:top" class="normal-div">
  <div style="display:inline-block">
    <div v-if="showX" 
         class="handwriting" 
         style="display:inline-block; position:absolute; color:#999; font-size: 48px; top:-4px"
         :style="xStyle">X</div>
    <button 
      ref="button"
      @click="butonClicked()" v-on="$listeners" 
      :class="{'clicked-button': clickedButton}" 
      class="handwriting"
      :style="buttonStyle"
      style="margin-bottom:4px"><slot></slot>
    </button>
  </div>

  <div v-if="showNopeText" class="hint" style="margin-left:12px">
    {{nopeText}}
  </div>
  <div v-if="showRainbow" class="rainbow-text" style="font-size:15px; margin:8px">
    Yay
  </div>

</span>
</script>

<script type="text/x-template" id="buton-group-template">
<div>
  <slot></slot>
  <div v-if="showHint" class="hint"><slot name="hint"></slot></div>
</div>
</script>

<script type="text/x-template" id="input-box-template">
<div style="display:inline-block; position:relative;">
  <input v-model="val" placeholder="?" style="width:50px; display:inline" v-on:keyup.enter="answerSubmit">
  <slot></slot>
  <buton style="display:inline" @click="answerSubmit">Go</buton>

  <transition name="fade">
    <span v-if="showCannedHint" class="hint">
      {{cannedHint}}
    </span>

    <span v-if="showYay" class="rainbow-text">
      Yay!
    </span>

    <div v-if="showHintSlot" class="hint">
      <slot name="hint"></slot>
    </div>

  </transition>
</div>
</script>


<!-- end templates -->


<script>
var DEBUG = false;


const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();


const store = new Vuex.Store({
  state: {
    flipStringHeight: 20,
  },
  // sync // store.commit('name', payload)
  mutations: {
    flipStringHeight(state, height){
      state.flipStringHeight = height;
    },
  },
  // async  // state.dispatch('name', payload);
  actions: {
  }, 
  // Put shared logic 
  getters: {
  }
});


var sounds = {
  'coin': {clip: new Audio('sounds/gold1.wav')},
  'heads': {clip: new Audio('sounds/gold0.wav')},
  'tails': {clip: new Audio('sounds/gold1.wav')},

  'speech': {clip: new Audio('sounds/speech_louder.wav')},
  //'speech': {clip: new Audio('sounds/drums_text.wav')},

  'buton': {clip: new Audio('sounds/button.wav')},
  'wrong': {clip: new Audio('sounds/wrong.wav')},
  'chimes': {clip: new Audio('sounds/chimes.wav')},
  // 'right': {clip: new Audio('sounds/right_soft.wav'), duration: 1000},
  'glitch': {clip: new Audio('sounds/glitch.wav')},
  'spell': {clip: new Audio('sounds/spell.wav')},
  'coy': {clip: new Audio('sounds/laugh.wav')},
  'right': {clip: new Audio('sounds/swish1.wav')},
  'curious': {clip: new Audio('sounds/curious.wav')},
  'achievement': {clip: new Audio('sounds/achievement.wav')},
};


const jokes = [
{
  outcomes: [
    // Order matters -- index is used to determine ?????
    {present: 'fails', past: 'failed', certainty: 0.5, payoff: -1}, 
    {present: 'lands', past: 'landed', certainty: 0.5, payoff: 2}
  ],
  lead: "Did you hear about the mathematician who's afraid of negative numbers?",
  punchline: "He'll stop at nothing to avoid them",
},

{
  outcomes: [
    {present: 'fails', past: 'failed', certainty: 0.6, payoff: -1}, 
    {present: 'lands', past: 'landed', certainty: 0.4, payoff: 1}
  ]
},

{
  outcomes: [
    {present: 'fails', past: 'failed', certainty: 0.6, payoff: -1}, 
    {present: 'lands', past: 'landed', certainty: 0.4, payoff: 4}
  ],
  lead:"Why don't scientists trust atoms?",
  punchline:"Because they make up everything"
},


// {
//   outcomes: [
//     {present: 'fails': past: 'failed', certainty: 0.7, payoff: -1}, 
//     {present: 'lands': past: 'landed', certainty: 0.3, payoff: 4}
//   ],
//   lead:"Where are average things manufactured?",
//   punchline:"The satisfactory"
// },

{
  outcomes: [
    {present: 'fails', past: 'failed', certainty: 0.8, payoff: -1}, 
    {present: 'lands', past: 'landed', certainty: 0.2, payoff: 5}
  ],
  lead:   "How many times can you substract 10 from 100?",
  punchline: "Once. The next time you would be subtracting 10 from 90"
},

{
  outcomes: [
    {present: 'fails', past: 'failed', certainty: 0.8, payoff: -2}, 
    {present: 'lands', past: 'landed', certainty: 0.2, payoff: 5}
  ]
},


// EV = 0.
{
  outcomes: [
    {present: 'fails', past: 'failed', certainty: 0.8, payoff: -1}, 
    {present: 'lands', past: 'landed', certainty: 0.2, payoff: 4}
  ],
  lead: "The numbers 19 and 20 got into a fight.",
  punchline: "21"
},
];

const clubs = [
  {
    name: 'fencing club',
    outcomes: [{x: 1, y: 0.2},{x: 2, y: 0.3},{x: 3, y: 0.3},{x: 4, y: 0.2},]
  },
  {
    name: 'math team',
    outcomes: [{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.3},{x: 4, y: 0.4},]
  },
  {
    name: 'biology olympiad',
    outcomes: [{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.1},{x: 4, y: 0.6},]
  },
  {
    name: 'knitting circle',
    outcomes: [{x:1, y: 0}, {x: 2, y: 0.5},{x: 3, y: 0.3},{x: 4, y: 0.2},]
  },
];

// pull the dialog into a new component?? 
const copIntro = {
  'trainee': {
    dialog: "Hey! You're the new trainee, right?",
    buttons: ['Er...', 'Yes'],
  },
'honor': {
    dialog: "I still remember my first day with the Statistics Police... What an honor to be chosen to help people with their statistics problems.",
    buttons: ['Next'],
  },
'understaffed': {
    dialog: "Anyways, I'm glad you're here. We are massively understaffed. And there are reports of some mysterious --",
    buttons: ['Chase'],  
  }
};


Vue.component('coin', {
  props: {
    bias: {type: Number, default: 0.5},
    pattern: {type: String},
  },
  data: function(){
    return {
      flips: [], //true, false, true, true], 
    }
  },
  computed: {
    flipString: function(){
      return this.samples.join('');
    },
    flipStringStyle: function(){
      console.log('reading new flipStringHeight in computed: ' + store.state.flipStringHeight);
      return { 'min-height': store.state.flipStringHeight + 'px'};
    },
    isShowingH: function(){
      if (this.flips.length == 0){
        return true;
      }
      return this.render(this.last) == 'H';
    },
    last: function(){
      return this.flips[this.flips.length-1];
    },

    xDomain(){
      return ['H', 'A'];
    },
    // ['H', 'A', 'H', 'A']
    samples(){
      return this.flips.map(this.render);
    },
  },
  watch: {
    flipString(){
      const height = this.$refs['flip-string'].clientHeight;
//      console.log('height: ' + height);
      if (height > store.state.flipStringHeight){
        console.log('updating height to: ' + height);
//        store.commit('flipStringHeight', height);
      }
    }
  },
  methods: {
    render: function(flip){
      return flip ? 'H' : 'A';
    },
    append: function(flip){
      this.$root.play(flip ? 'heads' : 'tails');
      this.flips.push(!!flip);
    },
    reset: function(){
      this.flips = [];
    },
    flip: function(){
      // Always repeats as HAHA.
      if (this.pattern == 'haha'){
        if (this.flips.length == 0){
          this.append(1);
        } else {
          this.append(Math.abs(this.last - 1));
        }

        // Early return.
        return;
      }

      // Prevents long streaks from happening.
      if (this.pattern == 'human'){
        const maxStreak = 3;
        if (this.flips.length > maxStreak){
          const slice = this.flips.slice(-maxStreak);
          if(_.every(slice) || _.every(slice, x => !x)){ 
            // If the last ones have all been of a type, the new one must be opposite.
            this.append(Math.abs(this.last - 1));
          } 

          // Fallthrough.
        }
      }

      // True coin flip.
      this.append(Math.random() < this.bias); 
    }
  },
  template: '#coin-template'
});



// outcomes = [
//  {certainty: 0.4, hp: 15, caption: 'warmth'}, 
//  {certainty: 0.6, hp: 0, caption: 'you fail to start the fire'}
// ]
// outcomes is a list of {certainty: __}
function drawFromOutcomes(outcomes){
  var ind = drawIndFromOutcomes(outcomes);
  return outcomes[ind];
}

function drawIndFromOutcomes(outcomes){
  var certainties = _.map(outcomes, 'certainty');
  if (!approx(sum(certainties), 1.0)){
    debugger;
    console.error('certainties for outcomes did not sum to 1: ' + outcomes);
  }

  var rand = Math.random();
  var cumsum_certainties = cumulativeSum(certainties);
  var cumsum_ind = 0;
  while (cumsum_certainties[cumsum_ind] < rand){
    cumsum_ind++;
  }
  return cumsum_ind;
}

Vue.component('ev-joke', {
  props: {
    joke: {type: Object},
  },
  computed: {
    ev(){
      return sum(this.joke.outcomes.map(outcome => outcome.certainty * outcome.payoff));
    },
    evCalculation(){
      return this.joke.outcomes.map(outcome => outcome.certainty + ' × ' + outcome.payoff).join(' + ') + ' = ' + this.ev;
    },
    chosenOutcome(){
      return this.joke.outcomes[this.chosenOutcomeInd];
    }
  },
  mounted(){
   this.chosenOutcomeInd = drawIndFromOutcomes(this.joke.outcomes);
  },
  data: function(){
    return {
      stage: 0,
      userAnswer: null,
      forceTell:null,
    }
  },
  methods: {
    finish(payoff){
      this.$emit('done', {payoff: payoff});
    }
  },
  template: '#ev-joke-template'
});


Vue.component('biased-coin-machine', {
  data: function(){
    return {
      slider: '50',
    }
  },
  computed: {
    bias: function(){
      return +this.slider / 100;
    },
  },
  watch:{
    bias: function(){
      this.$refs['coin'].reset();
    },
  },
  template: '#biased-coin-machine-template'
});


// You're the trainee right?
// This causes the buttons to show up
// User clicking the buton advances the state -- 
Vue.component('glitch', {
  props: {
    start: {type: String},
    end: {type: String},
  },
  data: function(){
    return {
      showStart: true,
    }
  },
  methods: {
    glitch: async function(){
      await wait(1000);
      this.showStart = false;
      this.$root.play('glitch');
      await wait(200);
      this.showStart = true;
      await wait(200);
      this.showStart = false;
      this.$root.play('glitch');
      await wait(200);
      this.showStart = true;
      await wait(200);
      this.showStart = false;
      this.$root.play('glitch');
    }
  },
  template: '#glitch-template'
});

Vue.component('input-box', {
  props: {
    right: {type: Number, default: 0},
    hints: {
      type: Array, 
      default: function(){ return ['Try again', 'Nope']; },
    },
    // replaced with yay@
    // onRight: {
    //   type: Function,
    //   default: function(){},
    // },

    // Default to no feedback bc avatar takes care of it, but sometimes we want to use this as a standalone component.
    feedback: {type: Boolean, default: true},
  },
  computed: {
    cannedHint(){
      return this.hints[this.answers.length % this.hints.length];      
    },
    isYay: function(){
      return this.val == this.right;
    },
    isNope: function(){
      return !this.isYay;
    },
    showYay(){
      return this.checkedAnswer && this.isYay;
    },
    showCannedHint(){
      return this.checkedAnswer && !this.hasSlot('hint') && this.isNope;
    },
    showHintSlot(){
      return (DEBUG || this.checkedAnswer) && this.hasSlot('hint') && this.isNope;
    }
  },
  data: function(){
    return {
      val: null,
      answers: [],

      checkedAnswer: false,
    }
  },
  watch:{
    val(){
      this.checkedAnswer = false;
    }
  },
  methods: {
    answerSubmit: async function(){
      this.checkedAnswer = true;
      this.answers.push(this.val);
      // if (this.feedback){
      //   this.showFeedback = true;
      //   await wait(500);
      // }

      //bus.$emit('answer-submitted', this);
      // look at the value in the input.
      if (this.isYay){
//        await wait(1000);
        this.$emit('yay'); //onRight();

        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }
      } 

    },
    hasSlot: hasSlot,
  },
  template: '#input-box-template'
});


function firstAncestorOfComponent(node, componentName){
  while(node !== undefined){
    node = node.$parent;
    if (node !== undefined && node.$options.name === componentName){
      return node;
    }
  }
  return undefined;
}
function isDescendant(ancestor, maybeChild){

  // If maybeChild is a vue component
  var node = maybeChild.$parent;
  while(node !== undefined){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }

  // If maybeChild is an HTML element
  var node = maybeChild.parentElement;
  while(node !== null){
    if (node === ancestor){
      return true;
    }
    node = node.parentElement;
  }

  return false;
}

function hasSlot(name){
  return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
}

Vue.component('avatar', {
  props: {
    image: {type: String, default:'wizard.png'}, // 'girl.png'
    text: {type: String, default: ''},
    textAlign: {type: String, default: 'right'},
    animation: {type: String, default: 'wobble'},
    sound: {type: String},
  },
  data: function(){
    return {
      showQuestion: false,
      showMiniDialog: false,
      showLiveText: false,
      showHint: false,
      showRainbow: false,
      showFall: false,
      reactionImage: null,
      nopeText: null,
      showPS: false,
      psButton: null,

      maxLen: 180,
    };
  },
  mounted: async function(){
    // Add a blink
    var this_ = this;
    if (this.sound){
      this.$root.play(this.sound);
      await wait(sounds[this.sound].duration || 500);
    }
    await wait(500);
    this_.showLiveText = true;
    bus.$on('avatar-react', function(params){
      this_[params.key] = params.value;
    });
    bus.$on('answer-submitted', function(input){
      this_.reactToInput(input);
    });
    bus.$on('chapter-changed', function(){
      this_.showRainbow = false;
    });
    // setInterval(async function(){
    //   // change it to the blink
    //   console.log('blinking');
    //   this_.reactionImage = 'monster_blink.png';
    //   await wait(100);
    //   this_.reactionImage = null;
    // }, 3000);
  },
  computed: {
    cropCircleStyle: function(){
      return {'background-image': 'url("images/' + this.image + '")'};
    },
    imgClasses: function(){
      var classes = {fallover: this.showFall};
      classes[this.animation] = true;
      return classes;
    },
    imgSrc: function(){
      return 'images/'+ (this.reactionImage || this.image);
    },
    imgStyle(){
      const height = 330;
      if (this.useSmallFont){
        return {'height' : _.clamp(lerp(this.textLength, 180, 300, .6, 1), .5, 1) * height + 'px'};
      }
      return {'height' : _.clamp(lerp(this.textLength, 60, 180, .5, 1), .5, 1) * height + 'px'};
    },
    textLength(){
      var lengths = [this.text.length];
      if (this.hasSlot('dialog') && this.$slots['dialog'][0].text){
        lengths.push(this.$slots['dialog'][0].text.length);
      }
      if (this.hasSlot('dialog') && this.$slots['dialog'][0].children && this.$slots['dialog'][0].children[0].text){
        lengths.push(this.$slots['dialog'][0].children[0].text.length); 
      }
      return _.max(lengths);
    },
    useSmallFont(){
      return this.textLength > this.maxLen;
    }, 
    dialogClass: function(){
      return {'small-dialog-text': this.useSmallFont};
    }
  },
  methods: {
    hasSlot: hasSlot,
    // For some reason, this need to be a separate fn, rather than inside the bus.
    // when the player clicks on a nope button, if the button has nope text, that is rendered.
    // otherwise, if the avatar has a hint slot that is shown.     
    reactToInput: function(input){
      // when the player clicks on a nope button, if the button has nope text, that is rendered.
      // otherwise, if the avatar has a hint slot that is shown. 
      if (input.nopeText){  
        this.nopeText = input.nopeText;
      } else if(input.isNope && this.hasSlot('hint')){
        this.showHint = true;
      }
    },
    clickpsButton(){
      this.psButton.butonClicked();
    }
  },
  template: '#avatar-template'
});
// Just like a button, but with some special abilities.
// When clicked it looks at it's parent to see if it's a buton-group.
// Executes the onClick event if so.
// e.g.
// <buton-group onClick="doSomethingSecond">
//   <buton @click="doSomethingFirst">Click me</buton>
// </buton-group>
// However, if the buton is a nope buton the buton-group does not get triggered.
// <buton nope="stop and think">Tricked ya</buton>
// <buton nope>Tricked ya</buton>
// Buttons may also have a yay attribute.
// Which causes the button to turn rainbow-text after it gets clicked.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.
    // moved to attr
    //yay: {type: Boolean, default:false}, // Causes cool animation to happen when clicked.
  },
  data: function(){
    return {
//      showX: false,
      clickedButton: false,
//      showRainbow: false,
    }
  },
  computed: {
    nopeText: function(){
      if (this.nope){
        return this.nope;        
      }
      if (this.isNope){
        return 'Nope';
      }
    },
    // Returns true for: <buton nope> or <buton nope="why not">
    isNope: function(){
      return this.nope || this.nope==="";
    },
    isYay: function(){
      return 'yay' in this.$attrs;
    },
    buttonStyle: function(){
      return {'font-size': this.$slots.default[0].text.length > 40 ? '16px' : '20px'};
    },
    showNopeText(){
      return (DEBUG || this.clickedButton) && this.isNope;
    },
    showRainbow(){
      return (DEBUG || this.clickedButton) && this.isYay;
    },
    showX(){
      return this.clickedButton && this.isNope;
    },
    xStyle(){
      return {left: (this.$refs['button'].clientWidth/2 - 10)+'px'};
    }
  },
  methods: {
    butonClicked: async function(){
      this.$root.play('buton');
      this.clickedButton = true;
      const avatar = firstAncestorOfComponent(this, 'avatar');

      // Tell those listening on the bus that the buton has been clicked... unless it's a buton within an input-box.
      if(!firstAncestorOfComponent(this, 'input-box')){
        // Don't emit again if this is the buton inside PS either.
        if (avatar && avatar.psButton !== this){
          bus.$emit('answer-submitted', this);        
        }
      }

      // Add yourself to parent butonGroup's clicked children
      // so it can show feedback.
      const butonGroup = firstAncestorOfComponent(this, 'buton-group');
      if (butonGroup){
        butonGroup.clickedChildren.push(this);
      }

      // Move the screen along.
      if (this.isYay){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }        
      }
      this.$root.scrollWindow();

    },
  },
  template: '#buton-template'
});

Vue.component('note', {
  props: {
    text: {type: String },
  },
  data(){
    return {
      showExpansion: false,
    }
  },
  template: '#note-template'
});

Vue.component('exp', {
  props: {
    base: {type: String },
    pow: {type: String },
  },
  template: '#exp-template'
});


Vue.component('frac', {
  props: {
    num: {type: String },
    den: {type: String },
  },
  template: '#frac-template'
});


Vue.component('big-frac', {
  props: {
    num: {type: String },
    den: {type: String },
  },
  template: '#big-frac-template'
});


// histogram example
// https://bl.ocks.org/d3noob/96b74d0bd6d11427dd797892551a103c
Vue.component('distribution', {
  props: {

    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    // Pass in outcomes directly.
    outcomes: {type: Array, default: function(){
      return [
        {x: 'tattoos', y: 0.2},
        {x: 'no tattoos', y: 0.8},
      ];
    }},
    chartHeight: {type: Number, default: 150},
    chartWidth: {type: Number, default: 200},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 50, left: 50};
      }
    },
  },
  computed: {
    xScale(){
      return d3.scaleBand()
          .domain(this.outcomes.map(d => d.x)).paddingInner(0.01).range([0, this.chartWidth]);
    },
    xScaleContinuous(){
      const domain = this.xScale.domain();
      const range = this.xScale.range();
      const bandwidth = this.xScale.bandwidth();
      return d3.scaleLinear().domain([domain[0], domain[domain.length-1]]).range([range[0] + bandwidth/2, range[1] - bandwidth/2]);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, 1]).range([this.chartHeight, 0]);
    },
    titleStyle(){
      return {'margin-left': this.margin.left + 'px', 'margin-right': this.margin.right + 'px'};
    },
    mean: function(){
      return sum(this.outcomes.map(outcome => outcome.x * outcome.y));
    },
  },
  data: function(){
    return {
      isCreated: false,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: function() {
    // Add the axis
    var xAxis = d3.axisBottom(this.xScale); //.ticks(8);
    var yAxis = d3.axisLeft(this.yScale).ticks(4);

    const chart = d3.select(this.$el).select('.container');
    chart.append('g').call(yAxis);
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);


    // x axis label
    chart.append("text")             
      .attr("transform",
            "translate(" + (this.chartWidth/2) + " ," + 
                           (this.chartHeight + this.margin.top + 20) + ")")
      .style("text-anchor", "middle")
      .text(this.xLabel);

    // y axis label
    chart.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - this.margin.left)
      .attr("x",0 - (this.chartHeight / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text(this.yLabel);    

  },
  template: '#distribution-template'
});


Vue.component('visual-ev-click', {
  props: {
    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
  },
  data: function(){
    return {
      isMouseover: false,

      mouseX: null,  // tracks mouse position always

      guessPx: null, // populated when user clicks
      guessReal: null, // populated when user clicks

      answerPx: null, // populated after delay when user clicks
      answerReal: null, // populated after delay when user clicks

      isMounted: false,
    };
  },

  computed: {
    trackerStyle: function(){
      return {
        left: (this.guessPx !== null ? this.guessPx : this.mouseX) + 'px'
      };
    },

    isUserClose: function(){
      // Is close if it's less than X% away from the true answer
      var distribution_component = this.$refs['distribution'];
      const domain = distribution_component.xScale.domain();
      var total = domain[domain.length-1] - domain[0];

      var difference = Math.abs(this.answerReal - this.guessReal);
      return difference / total < .1;
    },

    overlayStyle(){
       if(!this.isMounted){
          return;        
       }
       console.log('here');
       const d = this.$refs['distribution'];

       return {
          left: d.margin.left + 'px',
          height: d.chartHeight + d.margin.bottom + 'px',
          width: d.chartWidth + 'px'
       };
    }
  },

  mounted(){
    this.isMounted = true;
  },

  methods: {
    distributionClicked: async function(event){
      const distribution_component = this.$refs['distribution'];
      const distMean = distribution_component.mean;
      const xScale = distribution_component.xScaleContinuous; 

      this.guessPx = this.getRelativeMouseX(event);
      this.guessReal = xScale.invert(this.guessPx);

      // answerPx gets animated into the correct position.
      this.answerPx = this.guessPx;

      // Make the answer bar animate.
      await wait(300);
      this.answerPx = xScale(distMean);
      //debugger;

      // Make the text show.
      await wait(1300);
      this.answerReal = distMean;
    },

    getRelativeMouseX: function(event){
      // https://stackoverflow.com/questions/5921413/difference-between-e-target-and-e-currenttarget
      // e.target is what triggers the event dispatcher to trigger and e.currentTarget is what you assigned your listener to.

      // Find the 'dist' element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'overlay'){
        refElement = refElement.parentElement;
      }

      // console.log(event.target.className + ' ' + event.clientX + '      ' + refElement.className + JSON.stringify(refElement.getBoundingClientRect()));        
      return event.clientX - refElement.getBoundingClientRect().x;
    },

  },
  template: '#visual-ev-click-template',
});



Vue.component('triple-bayes', {
  props: {

    hypotheses: {type: Array}, // ['Nice', 'Evil']
        
    chartHeight: {type: Number, default: 160},
    chartWidth: {type: Number, default: 100},

    // Missing keys from config are not rendered.
    // {prior: {dist: [1, 4]}, likelihood: {isActive: true, isDraggable: true, dist: [1, 10]}, posterior: {}}
    config: {type: Object},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '#ddd', dot: '#EF6D21'};
      }
    },
  },
  data: function(){
    return {
     conf: null,
     showFeedback: null,
    }
  },
  computed: {
    posteriorDist(){
      var distArr = _.zip(this.priorArr, this.likelihoodArr).map(x => _.reduce(x, _.multiply));
      if (_.max(distArr) > 9){ // Start attempting to simplify posterior when it gets too big.
        distArr = this.simplifiedArr(distArr);
      }
      return _.zipObject(this.hypotheses, distArr);
    },
    priorArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['prior'].dist || ones;
    },

    likelihoodArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['likelihood'].dist || ones;
    },
    allCorrect(){
      const keys = ['prior', 'likelihood', 'posterior'];
      const parts = keys.map(key => !this.conf[key] || !this.conf[key].correct || this.isEqual(this.conf[key].correct, this.conf[key].dist));
//      console.log(parts);
      return _.every(parts);
    }
  },
  created(){
//    console.log('mounted');
    this.conf = _.cloneDeep(this.config);
  },
  methods: {
    isEqual(arr1, arr2){
      return _.isEqual(this.simplifiedArr(arr1), this.simplifiedArr(arr2));
    },
    // simplifiedArr([3, 6]) => [1, 2]
     simplifiedArr(arr){
      var maxFactor = _.min(arr);
      for (var i=maxFactor; i>1; i--){
        var isDivisible = _.every(arr.map(function(x){
          return Math.abs(x/i - Math.floor(x/i)) < .0001;
        }));
        if (isDivisible){
          break;
        }
      }
      var result = arr.map(x => Math.floor(x / i));
      //console.log(result);
      return result;
    },
    title(key){
      if (this.conf[key].title !== undefined){
        return this.conf[key].title;
      }
      const defaultTitles = {
        'prior': 'Prior Belief',
        'likelihood': 'Likelihood Ratio',
        'posterior': 'Posterior Belief'
      };
      return defaultTitles[key];
    },
    subtitle(key){
      if (this.conf[key].subtitle !== undefined){
        return this.conf[key].subtitle;
      }
      const defaultTitles = {
        'prior': 'What you thought before',
        'likelihood': 'Likelihood ratio of the evidence',
        'posterior': 'What you think after the evidence'
      };
      return defaultTitles[key];
    },
    hasKey(key){
      return this.conf[key];
    },
    isActive(key){
      return this.conf[key] && this.conf[key].isActive;
    },
    isDraggable(key){
      return this.conf[key] && this.conf[key].isDraggable;      
    },
    arrToDist(arr){
      return _.zipObject(this.hypotheses, arr);
    },
    isCompRight(key){
      return this.showFeedback && this.conf[key] && this.conf[key].correct && this.isEqual(this.conf[key].correct, this.conf[key].dist);
    },
    compStyle(key){
      return {opacity: this.conf[key] && this.conf[key].isActive ? 1 : 0.5};
    },
    likelihoodChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.likelihood, 'dist', distArr);
      this.refreshPosterior();
    },
    priorChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.prior, 'dist', distArr);
      this.refreshPosterior();
    },
    refreshPosterior(){
      if (this.$refs['posterior-samples-chart']){
        this.$refs['posterior-samples-chart'].countsFromProps()         
      }
    },
    submitClicked(){
      this.showFeedback=true;
      if(this.allCorrect){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }
        this.$emit('yay');
      }
    }
  },
  template: '#triple-bayes-template'
});

Vue.component('samples-chart', {
  props: {

    xdomain: {type: Array}, // ['H', 'T']

    // Specify either samples or dist
    samples: {type: Array}, // ['H', 'H', 'H', 'T']

    dist: {type: Object}, // {H: 3, T: 1}
        
    chartHeight: {type: Number, default: 100},
    chartWidth: {type: Number, default: 120},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 40, left: 10};
      }
    },

    showRatio: {type: Boolean, default: false}, 
    isDraggable: {type: Boolean, default: false}, 
    maxCounts: {type: Number, default: 15},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '', dot: ''};
      }
    },

  },
  computed: {
    xScale(){
      // Can only use for categorical domain.
      return d3.scaleBand()
          .domain(this.xdomain).paddingInner(.1).range([0, this.chartWidth]);
    },
    sumCounts(){
      //return _.sum(_.values(this.counts));
      return this.maxCounts;
    },
    yScale(){
      // const maxHeight = sumCounts == 1 ? this.xScale.bandwidth() : this.chartHeight;
      return d3.scaleLinear()
          .domain([0, this.sumCounts]).range([0, this.chartHeight]);
    },
    yScaleBandwidth(){
      return this.chartHeight / this.sumCounts;
    },
  },
  data: function(){
    return {
      isCreated: false,
      counts: null,
      draggedDot: null,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: async function() {
    this.countsFromProps();

    // Add the axis
    // Hack: for some reason axis needs to get added after a delay, or it doesn't show up.
    await wait(500);
    var xAxis = d3.axisBottom(this.xScale); //.ticks(8);
//    var yAxis = d3.axisLeft(this.yScale);

    const chart = d3.select(this.$el).select('.container');
//    chart.append('g').call(yAxis);
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);
  },
  watch: {
    samples(){
      this.countsFromProps();
    },
    dist(){
      this.countsFromProps();
    },
  },
  methods: {
    prob(x){
      const total = _.sum(_.values(this.counts));
      return this.$root.roundTo(this.counts[x]/total*100, 0);
    },
    dragstart(x){
      this.draggedDot = x;
    },
    dragend(){
      this.draggedDot = null; 
    },
    countsFromProps(){
      if (this.dist){
        this.counts = _.cloneDeep(this.dist);
      } else {
        const bins = _.groupBy(this.samples);
        this.counts = _.zipObject(this.xdomain, this.xdomain.map(function(x){
            return x in bins ? bins[x].length : 0;
          }));
      }
    },
    dotStyle(x){
      return {
        left: this.xScale(x)+ this.xScale.bandwidth()/2+ 4 + 'px', 
        bottom: this.yScale(this.counts[x]) + 24 + 'px',
        'background-color': this.colors.dot,
      };
    },
    drag(x, event){
      //console.log('dragging');
      //debugger;
      const distanceFromTop = this.getRelativeMouseY(event);
      if (distanceFromTop < 0){
        return;
      }
      const height = this.chartHeight - distanceFromTop;

      const numBars = Math.max(1, Math.floor(height / this.yScaleBandwidth));

      const isNewNumBars = this.counts[x] && this.counts[x] !== numBars;
      Vue.set(this.counts, x, numBars);

      if (isNewNumBars){
          this.$emit('dist-changed', {dist: this.counts});
      }
    },
    getRelativeMouseY: function(event){
      // https://stackoverflow.com/questions/5921413/difference-between-e-target-and-e-currenttarget
      // e.target is what triggers the event dispatcher to trigger and e.currentTarget is what you assigned your listener to.

      // Find the 'dist' element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'samples-chart'){
        refElement = refElement.parentElement;
      }
      return event.clientY - refElement.getBoundingClientRect().y;
    },

  },
  template: '#samples-chart-template'
});

// Put a buton inside a once-group to ensure it is only clicked once.
Vue.component('once-group', {
  data: function(){
    return {
      isClicked: false
    }
  },
  methods: {
    childClicked: function(childComponent) {
      if (this.isClicked){
        return;
      }
      this.isClicked = true;
    }
  },
  template: '#once-group-template',
});


Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  computed: {
    lastChild(){
      if (this.clickedChildren.length > 0){
        return this.clickedChildren[this.clickedChildren.length-1];
      }
    },
    showHint(){
      if (DEBUG){
        return true;
      }
      if (this.lastChild){
        return this.lastChild.isNope;
      }
      return false;
    }
  },
  data: function(){
    return {
      clickedChildren: [],
    }
  },
  template: '#buton-group-template'
});

Vue.component('bold', {
  template: '#bold-template'
});


function makeComponent(componentName, points, reactions){
  var reactions = reactions || {};
  Vue.component(componentName, {
    data: function(){
      return {

        actives: ['intro'],
        lastActive: 'intro',
        points: points, // jump points in the story
        problemToCorrectness: {}, // 'fakeout1': [false, true]
        memory: null, // A variable for dumping short term component state.

        chapters: chapters,


        // State for 'ev-story'
        positivityPoints: 0,
        jokes: jokes,
        jokeInd: 0,
        clubs: clubs,
        clubInd: 0,


      };
    },
    computed: {
      activeOrLastKnownPoint: function(){
        if (this.isKnownPoint(this.active)){
          return this.active;
        }  
        return this.lastActive;
      },
      active: function(){
        if (this.actives.length > 0){
          return this.actives[this.actives.length-1];
        }
        return 'intro';
      }
    },

    mounted: async function(){
      var this_ = this;
      bus.$on('answer-submitted', async function(input){
        // Respond only if the input is within the current component.
        if (!isDescendant(this_, input)){
          return;
        }
        // Have avatar react based on buton attributes.
        var avatar = firstAncestorOfComponent(input, 'avatar');
        if (!avatar){
          // The buton was not used within an avatar, but something else.
          return;
        }
        var problemKey = avatar.$vnode.data.key;
        // If there's a yay.
        if (input.isYay){
          avatar.reactionImage = reactions.yay;
          this_.addCorrectness(problemKey, true);          
          // If the user got it on their first try, show a rainbow.
          if (this_.perfect(problemKey)){
            this_.react('showRainbow', true);
          }
        } else {
          // this_.addCorrectness(problemKey, false);          
        }
        
        // just a naked <buton nope>
        if (input.isNope){
          avatar.reactionImage = reactions.nope;
          this_.addCorrectness(problemKey, false);          
        } 
        if ('coy' in input.$attrs){
          avatar.reactionImage = reactions.coy;
          this_.$root.play('coy');
        }
      });
    },
    methods: {
      addCorrectness(key, isCorrect){
        if(!(key in this.problemToCorrectness)){
          this.problemToCorrectness[key] = [];
        }
        this.problemToCorrectness[key].push(isCorrect);
      },
      isKnownPoint: function(point){
        return points && points.map(d => d.key).indexOf(point) > -1;
      },
      react: function(k, v){
        bus.$emit('avatar-react', {key: k, value: v});
      },
      print: function(thing){
        console.log(thing);
      },
      show: function(key){
        return true;
//        return this.actives.indexOf(key) > -1;
      }, 
      got: function(key){
        // Return the latest value
        if (this.problemToCorrectness[key]){
          var answers = this.problemToCorrectness[key];
          return answers[answers.length-1];
        } else {
          console.warn('checking for correctness of ' + key + ' which did not exist');
          return false;
        }
      },
      set: async function(key, optionalDelay){
        // Only update the lastActive point if the point is a known point.
        if (this.isKnownPoint(this.active)){
          this.lastActive = this.active;          
        }
        console.log('setting: ' + key);
        if (optionalDelay !== undefined){
          await wait(optionalDelay);        
        }
        this.actives.push(key);
      },
      perfect: function(key){
        // All answers to this problem were correct.
        if(this.problemToCorrectness[key] && _.every(this.problemToCorrectness[key])){
          return true;
        }
        return false;
      },
      pointStyle: function(point){
        var style = {};
        if (this.perfect(point.key)){
          style['background-image'] = "url('images/rainbow.png')";
          style['background-size'] = 'cover';
        }
        return style; 
      },
      pointClass: function(point){
        return {
          'active-point': point.key == this.activeOrLastKnownPoint,
          'circle': point.problem
        };
      },
      finish: async function(){
        this.$root.play('achievement');
        await wait(1500);
        this.$root.nextChapter();
      },
      nextJoke(params){
        this.positivityPoints += params.payoff;
        this.jokeInd++;
        if (this.jokeInd >= this.jokes.length){
          const pset = firstAncestorOfComponent(this, 'pset');
          if (pset){
            pset.next();
          }      
        }
      },
      next(){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }      
      }
    },
    template: '#' + componentName + '-template'
  });
}
['intro-scene', 'coin-flips', 'wizard-flips', 'chain-rule', 'ev-story', 'risk-reward', 'intro-to-pvalues', 'bayes-rule'].forEach(x => makeComponent(x));


Vue.component('next', {
  methods: {
    next(){
      const pset = firstAncestorOfComponent(this, 'pset');
      if (pset){
        pset.next();
      }      
    }
  },
  template: '#next-template'
});

// Can be used to delay logic
// <delay></delay>
Vue.component('delay', {
  props: {
    ms: {type: Number, default: 500},
    visible: {type: Boolean, default: false},
  },
  data: function(){
    return {
      shouldTrigger: false,
    }
  },
  computed: {
    compStyle: function(){
      if (this.visible){
        return {};
      } else {
        return {'display': 'none'};
      }
    }
  },
  mounted: function(){
    var this_ = this;
    setTimeout(function(){
      this_.shouldTrigger = true;
    }, this.ms);
  },
  template: `<span v-if="shouldTrigger" style="compStyle"><slot></slot></span>`,
});


/*
How should this work:
- split the text into words
- inject the words in via setinterval
- add a transition component that makes it fade in when it is injected
*/
Vue.component('live-text', {
  props: {
    interval: {type: Number, default: 1000},
  },
  render: function (createElement) {
    var data = [];
    for (var i=0; i<this.$slots.default.length; i++){
      var vnode = this.$slots.default[i];
      if (vnode.tag){
        data.push([vnode.tag, vnode.data, vnode.children]);
      } else if (vnode.text){
        var tokens = vnode.text.split(' ').filter(token => token);
        data = _.concat(data, tokens.map(token => ['span', {}, token + ' ']));
      }
    }
    var vnodes = data.map(function(tuple, i){
      const tag = tuple[0];
      const nodeData = tuple[1];
      const children = tuple[2];
      const meta = {
        ref: i, 
        class: { 'hidden-at-first': true }
      };
      return createElement(tag, _.merge(meta, nodeData), children);
    });
    return createElement(
      'div',   // tag name
      vnodes, 
    )
  },
  data: function(){
    return {
      visibleTokens: [],
      length: 0,
    };
  },
  mounted: function(){
    console.log('mounting live text');
    this.animate();
  },
  methods: {
    animate: async function(){
      var elts = _.values(this.$refs);

      this.length = _.sum(elts.map(elt => elt.textContent.length));

      function pauseDuration(text){
        const short = 100;
        const med = 500;
        const long = 1000;
        if (!text){
          return short;
        }
        if (text.includes('.') || text.includes('?') || text.includes('!')){
          return long;
        }
        if (text.includes(')')){
          return med;
        }
        return short;
      }
      this.$root.play('speech');
      for (var i=0; i<elts.length; i++){
        var elt = elts[i];
        elt.style.opacity = 1;
        // Pause.
        var duration = pauseDuration(elt.textContent);
        if (duration == 1000){
          this.$root.pause('speech');
        }
        await wait(duration);
        if (duration == 1000){
          this.$root.play('speech');
        }
      }
      this.$root.pause('speech');
      this.$emit('live-text-complete');
    },
  },
  template: '#live-text-template'
});

// Child slot should call next() on the parent to advance.
Vue.component('pset', {
  computed: {
    elms(){
      return this.$slots.default.filter(x => x.tag).map(x => x.elm);
    }
  },
  data: function(){
    return {
      ind: 0, // active index
    };
  },

  mounted: function(){
    // Hides elements initially.
    // for (var i=1; i<this.elms.length; i++){
    //   this.elms[i].style.display = 'none';
    // }

    this.$root.report(0);
  },
  methods: {
    next(){
      this.ind = this.ind + 1;
      if (this.ind >= this.elms.length){
        this.$emit('done');
        return;
      }

      // grey out previous indices
      for (var i=0; i<this.ind; i++){
        this.elms[i].style.opacity = 0.5;        
      }

      // make current ind, fully visible
      this.elms[this.ind].style.display = 'block';

      this.$root.report(this.ind);
      this.$root.scrollWindow();
    }
  },
  template: '#pset-template'
});

const chapters = [
{
  component: 'intro-scene',
  image: 'scroll.png',
  description: 'The beginning'
},
{
  component: 'coin-flips',
  description: 'Independent events',
  image: 'monster.png',
},
{
  component: 'wizard-flips',
  description: 'What does randomness look like',
  image: 'wizard.png',
},
{
  component: 'chain-rule',
  description: 'Chain rule of probability',
  image: 'girl.png',
},
{
  component: 'ev-story',
  description: 'Expected value',
  image: 'wizard.png',
},
{
  component: 'intro-to-pvalues',
  description: 'P-values', 
  image: 'scientist.png',
},
{
  component: 'bayes-rule',
  description: 'Bayes Rule', 
  image: 'crow.png',
},
];

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {
    chapters: chapters,
    chapterInd: 6,
    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    //soundNameToCount: {},
    show: false,
    isPlaying: false,
    showTOC: false,

    isScrolling: false,

    elapsedMinutes: null,
    elapsedSeconds: null,
  },
  computed: {
    currentChapter: function(){
      return this.chapters[this.chapterInd];
    },
    visibleScreen: function(){
      return this.currentChapter.component;
    }
  },
  mounted(){
    const loadTime = Date.now();
    var this_ = this;
    setInterval(function(){
      const seconds = (Date.now() - loadTime) / 1000;
      this_.elapsedMinutes = Math.floor(seconds/60);
      this_.elapsedSeconds = this_.roundTo(seconds % 60, 0);
    }, 1000);
  },
  watch:{
    chapterInd(){
      // Remove the rainbow
      bus.$emit('chapter-changed');
    }
  },
  methods: {
//    show: show, 
    formatPct: formatPct,
    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,
    nextChapter: async function(){
      // this.play('achievement');
      // await wait(1500);
      this.chapterInd = Math.min(this.chapters.length-1, this.chapterInd+1);
    },
    // // Given 0.8 --> returns {}
    // paramsFromCertainty: function(certainty){
    //   if (certainty == 1.0){
    //     return {
    //       numLoseIfWrong: 10000000, 
    //       numWinIfRight: 1,
    //       certainty: certainty,
    //       percent: '100%',
    //     };
    //   }
    //   return {
    //     numWinIfRight: 1, 
    //     numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
    //     certainty: certainty,
    //     percent: this.formatPct(certainty)
    //   };      
    // },
    // paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
    //   var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
    //   return this.paramsFromCertainty(certainty);
    // },
    play: function(soundName){
//      console.log('playing ' + soundName);
      var sound = sounds[soundName].clip;
      sound.play().catch(function(error){
        console.log(error.toString());
      });    
    },
    pause: function(soundName){
 //     console.log('pausing');
      var sound = sounds[soundName].clip;
      sound.pause();
      sound.currentTime = 0;      
    },
    async scrollWindow(){
//      console.log('scrollWindow');
      if (this.isScrolling){
        return;
      }

      this.isScrolling = true;
      // Scroll down a little bit and see if we should keep scrolling.
      // Stop scrolling if we've reached the bottom, 
      // Or if we have somehow traveled up (i.e. user has moved the mouse)
      while (true){
        const startY = window.scrollY;
//        console.log('lastStartY: ' + this.lastStartY + ' startY: ' + startY);
        if (this.lastStartY >= startY){

          // Hack: Wait and try one more time to scroll before exiting. 
          // Seems like there might be a delay to add stuff to the DOM?
          await wait(100);
          window.scrollBy(0, 10);
          if (this.lastStartY >= window.scrollY){
//            console.log('break');
            break;
          }
        }
        this.lastStartY = startY;
        window.scrollBy(0, 10);
//        console.log('scrolling');
        await wait(30);
      }
      this.isScrolling = false;
    }, 
    report(ind){
      const chapterName = this.currentChapter.component;
      console.log('reporting ' + chapterName + ' ' + ind);
      gtag('event', 'evilwizard_v1', {
        'event_category': 'read',
        'event_label': chapterName,
        'value': ind
      });
    },
    mainClick(event){
      console.log('click');
      // When you click on the margins, event.target is the "app" node. 
      //this.mouseEvent = event; 

      if (!isDescendant(this.$refs['toc'], event.target)){
        this.showTOC = false;
      }
    },

  } // end methods
});
</script>