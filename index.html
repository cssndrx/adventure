<!doctype html>


<head>
<meta charset="utf-8" />
<!--<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,400,700,900" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet">-->

<!--
font-family: 'VT323', monospace;
font-family: 'Princess Sofia', cursive;
font-family: 'Indie Flower', cursive;
font-family: 'Dokdo', cursive;
font-family: 'East Sea Dokdo', cursive;
font-family: 'Creepster', cursive;
font-family: 'Bungee Hairline', cursive;
font-family: 'Bungee', cursive;
font-family: 'Bungee Shade', cursive;
font-family: 'Bungee Inline', cursive;
font-family: 'Cormorant Garamond', serif;
-->

<!-- todo: strip and remove the unused -->
<link href="https://fonts.googleapis.com/css?family=Dokdo|Fira+Sans:300,800,900" rel="stylesheet">

<link href="css/animate.css" rel="stylesheet" type="text/css">
<script src="js/lodash.min.js"></script>
<script src="js/d3.v4.min.js"></script>

<script src="js/vue.js"></script>
<script src="js/jquery-1.9.1.js"></script>

<script src="js/utils.js"></script>

<style>

*{
  font-family: 'Fira Sans', sans-serif;
  font-size: 18px;
  font-weight: 300;
}

div{
  margin-bottom: 16px;
}
.normal-div, .normal-div div{
  margin-bottom: 0px;
}

/* font-family: 'Gaegu', cursive; -- cute child like handwriting */
/* font-family: 'Dokdo', cursive; -- funky */
/* font-family: 'Bungee Shade', cursive; -- pop art caps */

ul{
  margin-top: 0px;
}

h4{
  font-size: 18px;
  font-weight: 500;
}

a{
  color: #337ab7; /* boostrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}

.nope{
  color:red; 
  font-size: 14px; 
}

.handwriting, .handwriting *{
  font-family: 'Dokdo', cursive;    
}

.dialog-text, .dialog-text *{
  font-family: 'Dokdo', cursive;  
  font-size: 32px;
  width:350px;
}

.smaller-dialog-text, .smaller-dialog-text *{
  font-family: 'Dokdo', cursive;  
  font-size: 24px;
}

.centered, .centered *{
  font-size: 22px;
}

button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;

  font-size: 28px;
  font-weight: 900;
  margin-bottom: 8px; 
  padding: 8px 16px;
  margin: 8px;
}

.question button:hover, .question .clicked-button{
  color: white;
  background-color: black;
}


.bold{
  font-weight: 900;
}

.centered{
  display: grid;
  grid-template-columns: 1fr 500px 1fr;
  grid-template-rows: 1fr auto 1fr;
  grid-template-areas: 
    ". . ."
    ". centered-content ."
    ". . .";
  height: 500px;
}

.centered-content {
  grid-area: centered-content;
}

.centered button{
  margin: 0 auto;
  margin-bottom: 8px;
}


.hidden-at-first{
  opacity: 0;
  transition: opacity 1s;
}

.spin-and-pulse{
  position: absolute;
  animation: spin-and-pulse 5s ease 0s 1;
}

@keyframes spin-and-pulse {
  0% {
    transform: rotate(1turn);
  }
  5% {
    transform: rotate(0turn);
  }
  7% {
    transform: scale(1);
  }
  10% {
    transform: scale(1.2);
  }
  13% {
    transform: scale(1);
  }
  15% {
    transform: scale(1.1);
  }
  18% {
    transform: scale(1);
  }
}

.wobble{
  position: absolute;
  animation: wobble 5s ease 0s infinite;
}

@keyframes wobble {
  0% {
    transform: rotate(0turn);
  }
  5% {
    transform: rotate(0.003turn);
  }
  10% {
    transform: rotate(0turn);
  }
  12% {
    transform: rotate(0.003turn);
  }
  15% {
    transform: rotate(0turn);
  }
}

.bounce{
  position: absolute;
  animation: bounce 5s ease 0s infinite;
}

@keyframes bounce {
  0% {
    transform: translateY(20px);
  }
  3% {
    transform: translateY(-30px);
  }
  6% {
    transform: translateY(10px);
  }
  10% {
    transform: translateY(-10px);
  }
  12% {
    transform: translateY(0px);
  }
}

@keyframes mad-bounce {
  0% {
    transform: translateY(20px);
  }
  1% {
    transform: translateY(-30px);
  }
  2% {
    transform: translateY(10px);
  }
  3% {
    transform: translateY(-10px);
  }
  4% {
    transform: translateY(0px);
  }
}
.mad-bounce{
  position: absolute;
  animation: bounce 4s ease 0s infinite;  
}

.walk-drift{
  position: absolute;
  transition: left 3s;
}

.walk-bounce{
  position: absolute;
  animation: walk-bounce 0.8s ease 0s infinite;
}

@keyframes walk-bounce {
  0% {
    transform: translateY(0px);
  }
  25%{
    transform: translateY(-12px);    
  }
  50% {
    transform: translateY(0px);
  }
  75%{
    transform: translateY(-12px);    
  }
  100% {
    transform: translateY(0px);
  }
}

@keyframes fallover{
  100% {
    transform: rotate(0.3turn);
  }
}

.fallover{
  position: absolute;
  animation: fallover 1s ease-in 0s 1; /* to not stand back up:  normal forwards;  */
}

.active-point{
  background-color: black;
}

.point-container{
  width: 350px;
  display:flex; 
  justify-content:space-between; 
  margin: 0 auto;
}

.point{
  display: inline-block;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: 2px solid black;
}

.point:hover{
  background-color: #333;
}

.has-tooltip{
  position: relative;
}

.has-tooltip span{
  display: none;
  position:absolute;
  font-size: 10px;
  top: 24px;
  white-space: nowrap;

  background-color: rgba(0,0,0,0.5);
  padding: 8px;
  border-radius: 8px;
  color: white;
}

.has-tooltip:hover span{
  display: inline-block;
}


.extra-info, .extra-info *{
/*  font-size: 14px;*/
}

.smaller-children, .smaller-children *{
  font-size: 16px;
}

/* https://w3bits.com/rainbow-text/ */
.rainbow-text {
  background-image: repeating-linear-gradient(45deg, violet, indigo, blue, green, orange, red, violet);
  text-align: center;
  background-size: 800% 800%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow 4s ease infinite;
}

@keyframes rainbow { 
    0%{background-position:0% 50%}
    50%{background-position:100% 25%}
    100%{background-position:0% 50%}
}

.fade-enter-active, .fade-leave-active {
  transition: opacity 1s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}

.slide-fade-enter-active, .slide-fade-leave-active {
  transition: all .3s ease;
}
.slide-fade-enter, .slide-fade-leave-to {
  transform: translateY(-300px);
  opacity: 0;
}


.story-point-silhouette{
  -webkit-filter: contrast(0%) brightness(50%);
  filter: contrast(0%) brightness(50%);
  cursor: pointer;
}

.story-point-silhouette:hover{
  -webkit-filter: none;
  filter: none;
}


.cropcircle{
    width: 100px;
    height: 100px;
    border-radius: 100%;
/*    background: #000 no-repeat center;*/
    background-size: cover;
    border: 4px solid black;
}


</style>

<body>

<div class="handwriting normal-div" style="font-size:48px; text-align:center">The story so far</div>


<div id="app" style="position:relative">
  <div style="text-align: center">
    <div v-for="(storyPoint, ind) in storyPoints"
         @click="storyPointInd = ind"
         class="has-tooltip"
         style="display:inline-block;">
      <img :class="{'story-point-silhouette': currentStoryPoint !== storyPoint}"
          :src="'images/' + storyPoint.image" 
          style="width:50px">
      <span style="top:60px;">{{storyPoint.name}}</span>
    </div>
  </div>
<!--

<transition name="slide-fade">
<div v-if="show" style="background-color: blue; width:200px; height:200px;"></div>
</transition>

  <button @click="show = !show">
    Toggle render
  </button>


<button class="rainbow-text">Test</button>


<story :visible="true">
Are you here?

If so, you are in the <a @click="show('waiting')">right place</a>.

What is the probability that you will succeed?
</story>

<once-group>
<once-button>1/2</once-button>
<once-button>1/4</once-button>
<once-button>1/8</once-button>
</once-group>


<story ref="waiting">
I have been <a @click="show('changing')">waiting</a> for you. 
</story>

<story ref="changing">
The times are changing.

The prophecies are unclear, but the times are changing.

This planet is <a @click="show('new-world')">changing</a>.
</story>

<story ref="new-world">
<div>
You are going to bring us into this new world of <span class="animated infinite jello" style="display:inline-block">uncertainty</span>.
</div>-->


<!-- <div style="width: 150px; position:absolute; left: 0px; text-align: left; padding-left: 16px">

  <div v-for="storyPoint in storyPoints"
      @click="currentStoryPoint = storyPoint"
      style="margin-bottom: 4px;"
      :style="storyPointStyle(storyPoint)">
    <a :class="[storyPoint === currentStoryPoint ? 'active-tab': 'inactive-tab']">{{storyPoint.name}}</a>
  </div>

</div> -->


<keep-alive>
  <component v-bind:is="currentStoryPoint.component"></component>
</keep-alive>



</div> <!-- end #app -->

<script type="text/x-template" id="glitch-template">
  <div>
    <img v-if="showStart" :src="'images/'+start" style="width:100%">
    <img v-if="!showStart" :src="'images/'+end" style="width:100%">
  </div>
</script>

<script type="text/x-template" id="intro-scene-template">
<div style="width:700px; height:200px; margin-bottom: 100px; position:relative; margin:0 auto;" class="normal-div" >

  <div v-if="showCop" style="position:absolute; bottom:0px; left:0px;" ref="cop">
    <img src="images/cop.png" style="width:100px" >

    <span v-if="showExclamation" style="font-size:48px; position:absolute; bottom:110px; left:50px">!</span>

    <div v-if="showDialog" style="position:absolute; width:200px; left: 100px; top:20px;">
      <img src="images/dialog.png" style="width:200px; height:100px;">

      <live-text ref="cop-dialog" :key="state" class="handwriting" style="position:absolute; left:16px; top:4px;" @live-text-complete="liveTextComplete()">
        {{copDialog}}
      </live-text>
    </div>
  </div>

  <div v-if="showButons" style="position:absolute; left: 400px; bottom:0px">
    <buton v-for="butonValue in butonValues" :key="butonValue" @click="advance()">{{butonValue}}</buton>
  </div>

  <img v-if="showWizard" 
    ref="wizard" :src="'images/' + wizardImg" class="walk-drift" style="width:100px;position:absolute;left:0px;">

  <glitch ref="monster" v-if="showMonster" start="monster.png" end="monster_fuzzy.png" style="width:80px; position:absolute; left: 200px;bottom:0px;" ></glitch>
</div>
</script>

<script type="text/x-template" id="coin-flips-template">
<div>

<!-- jump to a diferent problem -->
<div class="point-container">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="{'active-point': point.key == activeOrLastKnownPoint}"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>

<<<<<<< HEAD
=======
<intro-scene key="intro" v-if="show('intro')" @scene-complete="set('intro1')">
</intro-scene>

>>>>>>> parent of 231cb36... Removed bus in favor of vuex

<!-- <transition name="fade" mode="out-in">-->
<avatar key="intro1"
  v-if="show('intro1')"
  image="monster_fuzzy.png"
  text="Please help me, I think I've been cursed!">


  <template v-slot:dialog>
    Oh my goodness.
  </template>

  <buton @click="set('intro2')">Next</buton>
</avatar>

<avatar key="intro2"
  v-if="show('intro2')"
  image="monster_fuzzy.png" 
  text="I'm stuck here giving math problems until someone can answer them all correctly.">
  <buton @click="set('intro3')">I'll help</buton>
</avatar>

<avatar key="intro3"
  v-if="show('intro3')"
  image="monster_fuzzy.png" 
  text="Are you sure? If you answer wrong, you might get cursed too.">
  <buton @clik="set('HHHHH')" yay>Yes</buton>
  <buton @click="set('police-help')" nope>No</buton>
</avatar>

<avatar key="police-help"
  v-if="show('police-help')"
  image="cop.png" 
  text="Kid, you can do it. I'll help you if you get stuck.">
  <buton @click="set('HHHHH')">Next</buton>
</avatar>

<avatar key="HHHHH"
  v-if="show('HHHHH')"
  image="monster_fuzzy.png" 
  text="I tossed a coin 5 times and it landed HHHHH. What do you think it will land the 6th time?">

  <template v-slot:hint>
    <div v-if="memory == 'userSaidT'">
      <div>Nope, that's the Gambler's Fallacy... a common misconception that events that haven't occured are more likely to occur.</div>

      <div>Coins have no memory, so just because H came up a lot, doesn't mean that T is more likely to come up in the future.</div>
    </div>

    <div v-if="memory == 'userSaidH'">
      <div>Nope, that's the Hot Hand Fallacy... a common misconception that events that have occurred recently are "hot" and more likely to come up.</div>

      <div>Coins have no memory, so just because H came up a lot, doesn't mean that H is any more likely to come up in the future.</div>
    </div>

  </template>


  <buton @click="memory='userSaidH'" nope>H</buton>
  <buton @click="memory='userSaidT'" nope>T</buton>
  <buton @click="set('HHHHH-finale')" yay>It's 50-50</buton>
</avatar>

<avatar key="HHHHH-finale"
  v-if="show('HHHHH-finale')"
  image="monster_fuzzy_happy.png" 
  sound="right"
  text="Yeah! The correct answer is that there's no way to tell.">
  <buton @click="set('independence')">Next</buton>
</avatar>

<interstitial 
    image="monster.png"
    key="independence" 
    v-if="show('independence')">
  <div>
    Coin flips are <bold>independent events</bold>.
  </div>

  <div>
    Meaning that knowing the result of one event does not give you information about the other events. Which of these is another example of an independent event?
  </div>

  <buton nope>Landing a job</buton>
  <buton @click="set('HH')" yay>Rolling dice</buton>
  <buton nope>Winning at games</buton>
  <buton nope>Having a good day</buton>
</interstitial>

<avatar key="HH"
  v-if="show('HH')"
  image="monster_fuzzy.png" 
  text="What is the probability that I toss a coin twice and get HH?">
  <buton nope="1/2 is the probability of tossing a single coin and getting H. Getting two heads in a row must be less than that.">1/2</buton>
  <buton @clik="set('HH-explanation')" yay>1/4</buton>
  <buton nope="It is possible to say if you assume it is a fair coin.">Can't say</buton>
</avatar>

<interstitial 
  key="HH-explanation" 
  v-if="show('HH-explanation')">
  <div>
    The probability of multiple independent events all occuring can be calculated by multiplication. This is called the probability of the <bold>joint event</bold>. So, the chance of getting HH is 1/2 x 1/2.
  </div>

  <div>
    Another way to see this is that there are 4 possible outcomes:

    <div style="margin-top:16px">
    HH<br>
    HT<br>
    TH<br>
    TT<br>
    </div>

    If we only care about the HH outcome, our probability of getting it is 1/4.
  </div>
  <buton @click="set('HHH')">Next</buton>
</interstitial> 

<avatar key="HHH"
  v-if="show('HHH')"
  image="monster_fuzzy.png" 
  text="What is the probability that I toss a coin three times and get HHH?">
  <buton nope>1/2</buton>
  <buton nope>1/3</buton>
  <buton @clik="set('10H')" yay>1/8</buton>
  <buton nope>Can't say</buton>

  <template v-slot:hint>
    <div>
      By the same logic as before, coin flips are independent events (i.e. a result doesn't affect the next result). The probabilities of the joint event: seeing X AND Y can be combined with multiplication. The chance of getting HHH is 1/2 x 1/2 x 1/2.
    </div>

    <div>
      Another way to see this is that there are 8 possible outcomes:

      HHH
      HHT
      HTH
      HTT
      THH
      THT
      TTH
      TTT

      If we only care about the HHH outcome, our probability of getting it is 1/8.
    </div>
  </template>
</avatar>


<avatar key="10H"
  v-if="show('10H')"
  image="monster_fuzzy.png" 
  text="What is the probability that I toss a coin 10 times and get HHHHHHHHHH?">
  <buton @clik="set('10HT')" yay>1/<exp base="2" pow="10"></exp></buton>
  <buton nope>1/2</buton>
  <buton nope>1/10</buton>
  <buton nope>1/20</buton>
  <buton nope>Can't say</buton>

  <template v-slot:hint>
    <div>
      Remember that independent events can be combined with multiplication.
    </div>

    <div>
      So the chance of getting HHHHHHHHHH is ....

      (big fraction) approx .01%
    </div>
  </template>
</avatar>


<avatar key="10HT"
  v-if="show('10HT')"
  image="monster_fuzzy.png" 
  text="What is the probability that I toss a coin 10 times and get HHHTHHTTTT?">
  <buton @clik="set('10HT-interstitial')" yay>1/<exp base="2" pow="10"></exp></buton>
  <buton nope>1/2</buton>
  <buton nope>1/10</buton>
  <buton nope>1/20</buton>
  <buton nope>Can't say</buton>
</avatar>

<interstitial 
    image="monster.png"
    key="10HT-interstitial" 
    v-if="show('10HT-interstitial')">
  <div>
    The chance of getting HHHTHHTTTT is the same as the probability of getting HHHHHHHHHH.
  </div>

  <div>
    Because both involve computing the probability of 10 independent coin flips.
  </div>

  <div>
    Isn't it cool that it's the same probability as before?
  </div>

  <buton @click="set('100H')">Next</buton>
</interstitial>


<avatar key="100H"
  v-if="show('100H')"
  image="monster_fuzzy.png" 
  text="I have one final question. The other day I tossed a coin 100 times and it landed heads all 100 times! What do you think it will land on the 101-st time?">

  <buton-group :onClick="() => react('showNewText', true)">
    <buton yay>H</buton>
    <buton>T</buton>
    <buton>I don't know</buton>
  </buton-group>

<!-- <exp base="2" pow="100"></exp> -->
<!-- <exp base="2" pow="80"></exp>-->
  <template v-slot:new-text>
   {{got('100H') ? 'That was a trick question but you got it!': 'Har-har! That was a trick question.'}} The probability of this happening on a fair coin is 1/2^100. If all the 2^80 atoms in the universe were flipping coins, this still probably wouldn't happen. So the coin must not be fair. 
  </template>

  <template v-slot:new-question>
    <buton @click="set('congrats')">Next</buton>
  </template>
</avatar>


<! -- Teehee thanks for playing with me! -->
<centered key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about <bold>independent events</bold> (two events that don't affect each other)</li>
    <li>You learned how to calculate the <bold>joint probability</bold> of independent events (you multiply)</li>
    <li>You learned that there are <exp base="2" pow="80"></exp> atoms in the universe.</li>
  </ul> 

  <buton @click="finish()">Next section</buton>
</centered>

<!-- </transition> -->

</div>
</script>

<script type="text/x-template" id="chain-rule-template">

<div>

<!-- jump to a diferent problem -->
<div class="point-container" style="width:400px">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="{'active-point': point.key == activeOrLastKnownPoint}"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>

<!--<transition name="fade" mode="out-in">-->

<avatar key="intro"
  v-if="show('intro')"
  image="girl_fuzzy.png" 
  text="Hello! I'm Veronica and I only date monsters that are tall and have great hair.">
  <buton @click="set('fakeout1')">Next</buton>
</avatar>

<avatar key="fakeout1"
  v-if="show('fakeout1')" 
  image="girl.png" 
  text="If 1/2 of all monsters are tall and 1/4 of monsters have great hair... What is the probability that a random monster is datable?">

  <div>
    In math language, P(tall) = 1/2. P(great hair) = 1/4. What is P(tall AND great hair)?
  </div>

  <buton-group :onClick="() => set('fakeout1-inter')">
    <buton coy>1/8</buton>
    <buton nope="Why 1/3? Try again.">1/3</buton>
    <buton nope="That doesn't make sense. 3/4 is more than the number of monsters that are tall. Try again.">3/4</buton>
    <buton yay>Can't say</buton>
  </buton-group>

</avatar>


<interstitial 
    image="girl.png"
    key="fakeout1-inter" 
    v-if="show('fakeout1-inter')">

  <div v-if="got('fakeout1')">
    Right! It's not possible to say. 
  </div>
  <div v-else>
    It's actually not possible to say.
  </div>

  <div>
    It is only valid to compute P(tall AND great hair) by multiplying P(tall) and P(great hair) if being tall and having great hair are independent -- like coin flips.
  </div>

  <div>
     Put another way, independence occurs if a monster's height does not provide any information on the greatness of a monsters hair. 
  </div>

  <buton @click="set('conditional1')">Next</buton>
</interstitial>



<avatar key="conditional1" 
        v-if="show('conditional1')"
        image="girl.png" 
        text="It turns out that being tall and having great hair are slightly correlated. About 1/3 of tall monsters have great hair.">

  <div>
    In math language, Veronica just told us a conditional probability. 
  </div>

  <div>
    We can use this information to calculate P(tall AND great hair).
  </div>

  <buton @click="set('conditional2')">Next</buton>
</avatar>



<interstitial 
    image="girl.png"
    key="conditional2" 
    v-if="show('conditional2')">

  <div>
    A conditional probability tells us the probability of something, if we know something else to be true.
  </div>

  <div>
    For instance, Veronica told us that the probability that a tall monster would have great hair is 1/3. 
  </div>

  <div>
    In math speak, she told us P(great hair|tall) -- the probability of great hair GIVEN the monster is tall.
  </div>

  <buton @click="set('conditional3')">Next</buton>

</interstitial>


<interstitial 
    image="girl.png"
    key="conditional3" 
    v-if="show('conditional3')">
  <div>
    Using a conditional probability, we can calculate P(tall AND great hair) without assuming independence.
  </div>

  <div>
    P(tall AND great hair) = P(tall) x P(great hair|tall)
  </div>

  <div>
    The formula makes logical sense. It says, first consider the chance that the monster is tall. Then multiply by the chance that a random tall monster would have great hair.
  </div>

  <buton @click="set('tall-hair')">Try it</buton>
</interstitial>


<avatar key="tall-hair" 
        v-if="show('tall-hair')"
        image="girl.png" 
        text="Okay so what is the probability that a random monster is datable?">

  <div>What is P(tall AND great hair)?</div>

  <div class="extra-info">Facts from before:
  <ul>
    <li>P(tall) = 1/2</li>
    <li>P(great hair) = 1/4</li>
    <li>P(great hair | tall) = 1/3</li>
  </ul>
  </div>

  <buton-group :onClick="() => set('fakeout2')">
    <buton yay>1/6</buton>
    <buton nope="We said that being tall and having great hair are not independent, so we can't just multiply 1/2 x 1/4.">1/8</buton>
    <buton nope="Are you just multiplying things together? Try again.">1/24</buton>
    <buton nope="The answer isn't always 'Can't say'...">Can't say</buton>
  </buton-group>

<!--  
todo: add a review slot.

  <template v-slot:overlay>
    <div>
      Right!
    </div>

    <div>
      P(great hair AND tall) = P(tall) * P (great hair | tall)
    </div>

    <buton @click="set('problem2')">Next</buton>
  </template> -->
</avatar>


<avatar key="fakeout2"
        v-if="show('fakeout2')"
        image="girl.png"
        text="Oh thank you for your help so far. But I forgot... I also want them to have tattoos. 1/5 of monsters have tattoos.">

  <div>In math speak, P(tattoos) = 1/5.</div>
  <div>What is P(tall, great hair, tattoos)?</div>

  <div class="extra-info">Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
      <li>You calculated P(great hair AND tall) = 1/6</li>
    </ul>
  </div>

  <buton-group :onClick="() => set('chainruleinter1')">
    <buton coy>1/30</buton>
    <buton nope="Remember, we want to use P(great hair|tall), not P(tall).">1/40</buton>
    <buton nope="Wait, are you just blindly multiplying numbers? Stop that.">1/120</buton>
    <buton yay>Can't say</buton>
  </buton-group>
</avatar>


<interstitial 
    image="girl.png"
    key="chainruleinter1" 
    v-if="show('chainruleinter1')">

  <div>
    {{ got('fakeout2') ? 'Right.': 'Not quite.' }} Again, it's not possible to say!
  </div>

  <div>
    To get P(tattoo AND great hair AND tall), we can't just multiply
    P(tattoo) * P(great hair AND tall) without assuming independence.
  </div>

  <div>
    We need another conditional probability.
  </div>

  <buton @click="set('chainruleinter2')">Next</buton>
</interstitial>

<interstitial 
    image="girl.png"
    key="chainruleinter2" 
    v-if="show('chainruleinter2')">
  <div>
    This is called the Chain Rule of probability.
  </div>

  <div class="smaller-children">
    P(tattoo AND great hair AND tall) = <br>
    <span style="color:magenta">P(tall)</span> * <span style="color:green">P(great hair | tall)</span> * <span style="color:blue">P(tattoo | great hair AND tall)</span>
  </div>

  <div class="smaller-children" style="margin-left: 16px;">
    <div>
      First, consider the <span style="color:magenta">probability of the monster being tall</span>.
    </div>

    <div>
      Then, consider the <span style="color:green">probability of a tall monster having great hair</span>.
    </div>

    <div>
      Then, consider the <span style="color:blue">probability that a tall monster with great hair, would have a tattoo</span>.
    </div>

    <div>
      Multiply together to get monsters that are tall and have great hair and have tattoos.
    </div>
  </div>

  <div>
    Basically, the Chain Rule says that when adding a new item to the joint probability, condition on all the events that already exist.
  </div>

  <buton @click="set('problem3')">Try it</buton>
</interstitial>


<avatar key="problem3" 
        v-if="show('problem3')"
        image="girl.png" 
        text="Ooh yes, I've heard of the Chain Rule. Here are the numbers that you'll need.">

  <template v-slot:hint>
    <div>
      Recall the Chain Rule says that everything must be conditioned on what came before. 
    </div>
    <div>
      So P(tall, great hair, tattoos) = P(tall) * P(great hair | tall) * P(tattoos | great hair AND tall). 
    </div>
  </template>

  <div>
  What is P(tall, great hair, tattoos)?
  </div>

  <div class="extra-info">
  Facts from before:
  <ul>
    <li>P(tall) = 1/2</li>
    <li>P(great hair) = 1/4</li>
    <li>P(great hair|tall) = 1/3</li>
    <li>P(tattoos) = 1/5</li>
    <li>P(tattoos|tall) = 1/6</li>
    <li>P(tattoos|tall AND great hair) = 1/7</li>
  </ul>
  </div>

  <div>
  P(tall, great hair, tattoos) =  1/<input-box :right="42" :onRight="() => set('problem4')"/>
  </div>

</avatar>


<avatar key="problem4" 
        v-if="show('problem4')"
        image="girl.png" 
        text="Yes, thank you! But silly us! We forgot to include that these tall, great hair, tattooed monsters also need to be... around my age and single.">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
      <li>P(tattoos) = 1/5</li>
      <li>P(tattoos|tall) = 1/6</li>
      <li>P(tattoos|tall AND great hair) = 1/7</li>
      <li>P(around her age|tall AND great hair AND tattoos) = 1/5</li>
      <li>P(single|tall AND great hair AND tattoos AND around her age) = 1/2</li>
    </ul>
    </div>


    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So in the case of four events, P(tall, great hair, tattoos, single) = P(tall) * P(great hair | tall) * P(tattoos | great hair AND tall) * P(great hair AND tall AND tattoos | single). 
      </div>
      <div>
        What is it for five events?
      </div>
    </template>

    <div>
    P(tall, great hair, tattoos, around her age, single) =
    </div>

    1/<input-box :right="420" :onRight="() => set('not-many')"/>
</avatar>


<avatar key="not-many"
        v-if="show('not-many')"
        image="girl_shock.png" text="That's not very many people!">

  <div>
    Even though each individual criteria may not seem picky, requiring that a monster have all those traits leaves Veronica with a very small dating pool.
  </div>

  <div>
    But hey, at least Veronica's pickiness taught you the Chain Rule.
  </div>

  <buton @click="set('congrats')">Next</buton>
</avatar>

<interstitial 
    image="girl.png"
    key="problem1-result" 
    v-if="show('problem1-result')">
  <div>
    One quick thing that may really blow your mind.
  </div>

  <div>
    We had been decomposing:
  </div>

  <div style="font-size:16px">
    P(tall AND great hair and tattoos) = P(tall) * P(great hair|tall) * P(tattoos | tall AND great hair).
  </div>

  <div>
    But notice... that we can also decompose it as:
  </div>

  <div style="font-size:16px">
    P(tall AND great hair and tattoos) = P(great hair) * P(tattoos | great hair) * P(tall | tattoos AND great hair).
  </div>

  <div>
    We can decompose it in any order we choose to, depending on what information we have on hand.
  </div>

  <buton @click="set('congrats')">OK mind blown</buton>
</interstitial>

<centered key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about independence</li>
    <li>You learned about Chain Rule</li>
    <li>You learned to not be too picky ❤️</li>
  </ul> 

  <buton @click="finish()">Next section</buton>
</centered>

</transition>

</div>

</script>

<script type="text/x-template" id="risk-reward-template">
<div>

<!-- jump to a diferent problem -->
<div class="point-container" style="width:220px">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="{'active-point': point.key == activeOrLastKnownPoint}"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>


<!--<transition name="fade" mode="out-in">-->

<avatar key="intro"
  v-if="show('intro')"
  image="bear.png" 
  text="Do you dare play with a bear???">
  <buton @click="set('ev')">Yes</buton>
</avatar>

<avatar key="ev"
  v-if="show('ev')"
  image="bear.png" 
  text="What would you rather? (a) I pay you 1 coin or... (b) I pay you 4 coins with 20% certainty, and 80% of the time you get nothing.">
  <buton @click="set('ev-right')" yay>(a) 1 coin with certainty</buton>
  <buton @click="set('ev-wrong')" nope>(b) 4 coins with 20% certainty</buton>
</avatar>

<avatar key="ev-right"
  v-if="show('ev-right')"
  image="bear.png" 
  text="Well, that's correct.">

  <template v-slot:question>
    <div>
     On average, the 4 coins with 20% probability is only worth 0.8 coins on average, so the 1 coin with certainty is worth more.
    </div>

    <buton @click="set('100')">Next</buton>
  </template>
</avatar>

<avatar key="ev-wrong"
  v-if="show('ev-wrong')"
  image="bear_money.png" 
  text="Heh heh ."
  animation="spin-and-pulse">

  <template v-slot:overlay>
    <div>
      Player! Your answer was incorrect.
    </div>

    <div>
      On average, the 4 coins with 20% certainty is only worth 0.8 coins.
    </div>

    <div>
      AND it's riskier because the payout isn't guaranteed.
    </div>

    <div>
      By the risk-reward tradeoff, you ought to be compensated for extra risk with higher average reward.
    </div>

    <div style="font-size: 10px">
      The bear offered a bum deal because 4 coins with 20% probability was higher risk and lower average reward.
    </div>

    <buton @click="set('100')">Next</buton>
  </template>
</avatar>

<avatar key="100"
  v-if="show('100')"
  image="bear.png" 
  text="What if I offered you the chance to pick one choice and play 100 times? Which would you pick?">
  <buton @click="set('100-right');" yay>(a) 1 coin with certainty</buton>
  <buton @click="set('100-wrong')" nope>(b) 4 coins with 20% certainty</buton>
</avatar>


<avatar key="100-right"
  v-if="show('100-right')"
  image="bear.png" 
  text="Yeah, that's correct.">

  <template v-slot:question>
    <div>
     Playing 100 times doesn't change the fact that 4 coins with 20% probability has the lower expected value.
    </div>

    <buton @click="set('100-chart')">Next</buton>
  </template>
</avatar>

<avatar key="100-wrong"
  v-if="show('100-wrong')"
  image="bear_money.png" 
  text="Heh. Wrong."
  animation="spin-and-pulse">

  <template v-slot:question>
    <div>
     Playing 100 times doesn't change the fact that 4 coins with 20% probability has the lower expected value.
    </div>

    <buton @click="set('100-chart')">Next</buton>
  </template>
</avatar>

<centered key="100-chart"
  v-if="show('100-chart')">
  <div>
  Running a simulation where a computer really executes the 4 coins with 20% probability deal 100 times, yields... (chart)
  </div>
  
  <div>
    We see the average result is near 80, although random variation resulted in totals near 60 and 100. But in __% of casses, taking the guaranteed 100 coins would have been a better choice.
  </div>

  <div>
    This is a sneak peak of the Binomial Distribution which you will see later in this adventure. Statisticians have invented distributions to model many common scenarios. 
  </div>

  <buton @click="set('congrats')">Stats is cool</buton>
</centered>

<centered key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about expected value (the average)</li>
    <li>You got a sneak peak of the usefulness statistical distributions</li>
  </ul> 

  <buton @click="finish()">Next section</buton>
</centered>

<!--</transition> -->
</div>
</script>


<!-- begin templates -->
<script type="text/x-template" id="interstitial-template">
<centered>
   <div class="cropcircle" style="margin:0 auto; margin-bottom:16px" :style="cropCircleStyle"></div>
  <slot></slot>
</centered>
</script>


<script type="text/x-template" id="centered-template">
<div class="centered">
  <div class="centered-content"><slot></slot></div> 
</div>
</script>

<script type="text/x-template" id="bold-template">
<span class="bold"><slot></slot></span> 
</script>


<script type="text/x-template" id="avatar-template">
<div style="position: relative; height: 700px; width:800px; margin:0 auto; margin-top:16px">

<!--
<transition name="slide-fade">
 <div v-if="showOverlay && hasSlot('overlay')"
     style="position:absolute; z-index:1; height: 500px; width:100%; opacity:0.9; background-color: white; color:black;">
  <centered>
      <slot name="overlay"></slot>
  </centered>
</div>
</transition> -->


<img v-if="showRainbow" src="images/rainbow.png">

<img :src="imgSrc" 
     :class="imgClasses"
     style="height: 300px; left: 80px; position:absolute; top:0px;">


<!-- Dialog box -->
<div style="position:absolute; left: 300px; top:0px;"
  v-if="showLiveText">
  <img src="images/dialog.png" >
  <div style="position: absolute; left:40px; top:23px;" class="dialog-text"
  :class="{'smaller-dialog-text': text.length > 140}">
    <live-text  
        key="initial-text"
        v-if="!showNewText" @live-text-complete="showQuestion=true">
        <slot name="dialog"></slot>
      {{text}}
    </live-text> 

    <live-text 
        key="new-text"
<<<<<<< HEAD
        v-if="state.showNewText"
        @live-text-complete="react('showNewQuestion',true)"
=======
        v-if="showNewText"
        @live-text-complete="showNewQuestion=true">
>>>>>>> parent of 231cb36... Removed bus in favor of vuex
        <slot name="new-text"></slot>
    </live-text>
  </div>
</div>

<!-- Mini dialog -->
<div v-if="showMiniDialog" style="position:absolute; left: 100px; top:300px;">
  <img src="images/mini_dialog.png" style="width:150px">
  <div style="position: absolute; left:40px; top:40px;" class="smaller-dialog-text">
    Yep!
  </div>
</div>

<!-- Bottom right -->
  <div class="question" style="position:absolute; left: 100px; top: 300px; width: 500px;">

    <!-- Show hint via nopeText or nope slot -->
    <div v-if="nopeText" 
         class="nope" style="margin-top:24px">{{nopeText}}</div>
    <transition name="fade">
      <div v-if="showHint" class="nope">
        <slot name="hint"></slot>
      </div>
    </transition>


  <transition name="fade" mode="out-in">  
    <div v-if="showQuestion && !showNewQuestion">  
      <slot name="question"></slot>
      <slot></slot> <!-- todo: consider removing default slot -->
    </div>

    <slot v-if="showNewQuestion" name="new-question"></slot>
  </transition>

  </div>

</div>
</script>



<script type="text/x-template" id="story-template">
<div v-if="isVisible"><slot></slot></div>
</script>

<script type="text/x-template" id="live-text-template">
  <div>
    <transition-group name="fade" tag="span">
      <span v-for="(token, i) in visibleTokens" :key="i" v-html="token">
      </span>
    </transition-group>
  </div>
</script>


<script type="text/x-template" id="monk-head-template">
<div class="handwriting normal-div"
      style="display:inline-block; position:relative; white-space: nowrap;">
  <img src="images/monk_head.png" style="width:80px;">

  <!-- speech pointing to left -->
  <div v-if="hasSlot('lhs')">
    <div style="width:22px; border:1px solid black; transform:rotate(50deg); position:absolute; top:-14px; left:10px;"></div>
    <div style="position:absolute; top: -40px; left:0px;">
      <slot name="lhs"></slot>
    </div>
  </div>

  <!-- speech pointing to right -->
  <div v-if="hasSlot('rhs')">
    <div style="width:24px; border:1px solid black; transform:rotate(310deg); position:absolute; top:-14px; left:50px;"></div>
    <div style="position:absolute; top: -40px; left: 60px;">
      <slot name="rhs"></slot>
    </div>
  </div>

</div>
</script>

<script type="text/x-template" id="exp-template">
  <var>{{base}}<sup>{{pow}}</sup></var>
</script>

<script type="text/x-template" id="buton-template">
<span style="margin-bottom:0px; position:relative; display:inline-block">
  <div v-if="showX" 
       class="handwriting" 
       style="display:inline-block; position:absolute; color:red; font-size: 64px; left: calc(50% - 20px); top:-4px">X</div>
  <button @click="butonClicked()" v-on="$listeners" :class="{'rainbow-text': showRainbowText, 'clicked-button': clickedButton}" class="handwriting"><slot></slot>
  </button>
<!--  <transition name="fade">
    <div v-if="showNopeText" class="nope" style="margin-bottom:8px; position:relative; top:-4px;">
      {{nope}}
    </div>
  </transition>-->
</span>
</script>


<script type="text/x-template" id="input-box-template">
  <div style="display:inline-block; position:relative;">
    <input v-model="val" placeholder="?" style="width:50px; display:inline" v-on:keyup.enter="answerSubmit">
    <buton style="display:inline" @click="answerSubmit">Go</buton>
  
    <transition name="fade">
      <span v-if="showNopeText" class="nope" style="position:absolute; bottom: -8px; margin-bottom:0px">
        {{feedback}}
      </span>
    </transition>
  </div>
</script>


<!-- end templates -->


<script>

<<<<<<< HEAD
// https://www.youtube.com/watch?v=LW9yIR4GoVU
// store.state.message.
var initAvatarState = {
      showQuestion: false,
      showNewQuestion: false,
      showMiniDialog: false,
      showLiveText: false,
      showRainbow: false,
      showFall: false,
      showNewText: false,
      reactionImage: null,
    };

const store = new Vuex.Store({
  state: {
    answerSubmittedComponent: null,
    avatarState: _.cloneDeep(initAvatarState),  
  },
  // sync // store.commit('name', payload)
  mutations: {
    answerSubmitted(state, component){
      state.answerSubmittedComponent = component;
    },
    avatarReaction(state, params){
      console.log('@store ' + params.key + ' ' + params.value);
      state.avatarState[params.key] = params.value;
    },
    resetAvatar(state){
      state.avatarState = _.cloneDeep(initAvatarState);
    }
  },
  // async  // state.dispatch('name', payload);
  actions: {
  }, 
  // Put shared logic 
  getters: {
  }
});

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

// https://alligator.io/vuejs/global-event-bus/
//const bus = new Vue();
=======
const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();
>>>>>>> parent of 231cb36... Removed bus in favor of vuex

var sounds = {
  'speech': {clip: new Audio('sounds/speech.wav')},
  'buton': {clip: new Audio('sounds/button.wav')},
  'wrong': {clip: new Audio('sounds/wrong.wav')},
  'chimes': {clip: new Audio('sounds/chimes.wav')},

  // 'right': {clip: new Audio('sounds/right_soft.wav'), duration: 1000},
  'glitch': {clip: new Audio('sounds/glitch.wav')},
  'spell': {clip: new Audio('sounds/spell.wav')},

  'coy': {clip: new Audio('sounds/laugh.wav')},
  'right': {clip: new Audio('sounds/swish1.wav')},

  'curious': {clip: new Audio('sounds/curious.wav')},
  'achievement': {clip: new Audio('sounds/achievement.wav')},
};


// pull the dialog into a new component?? 
Vue.component('intro-scene', {
  data: function(){
    return {
      stateInd: 0,
      showButons: false,
      showCop: true,
      showDialog: true,
      showWizard: false,
      showMonster: false,
      showExclamation: false,
      states: ['trainee', 'understaffed', 'chase', 'fin'],

      wizardImg: 'wizard_run.png',
    }
  },
  computed: {
    state: function(){
      return this.states[Math.min(this.stateInd, this.states.length-1)];
    },
    copDialog: function(){
      if (this.state == 'trainee'){
        return "Hey you! You're the new trainee, right?";
      }
      else if (this.state == 'understaffed'){
        return "Glad you're here. The Statistics Police is massively understaffed. And some weird --";              
      }
      return "";
    },
    butonValues: function(){
      if (this.state == 'trainee'){
        return ['Er...', 'Yes'];
      } else if (this.state == 'understaffed'){
        return ['Chase'];
      } if (this.state == 'chase'){
        return ['Next'];
      }
    },
  },
  mounted: async function(){
    // await wait(100);
    // this.$refs['cop'].style.left = 'calc(50% - 50px)';
    // await wait(3000);
    // this.$refs['cop'].classList.remove('walk-bounce');
  },
  methods: {
    advance: async function(){
      console.log('advancing from: ' + this.state);
      this.showButons = false;
      this.stateInd++;
      if (this.state == 'chase'){
        this.showCop = false;
        this.showMonster = true;
        this.showWizard = true;

        // Wizard runs to the middle
        this.$refs['wizard'].classList.remove('walk-drift');
        this.$refs['wizard'].style.left = '0%';
        await wait(100);
        this.$refs['wizard'].classList.add('walk-drift');
        this.$refs['wizard'].style.left = '60%';

        // Wizard casts spell.
        await wait(1500);
        this.wizardImg = 'wizard.png';
        this.$root.play('spell');  

        // Monster begins to glitch.
        this.$refs['monster'].glitch();

        // Wizard runs off.
        await wait(800);      
        this.wizardImg = 'wizard_run.png';
        this.$refs['wizard'].style.left = '105%';

        await wait(1000);
        this.showButons = true;
      } 

      if (this.state == 'fin'){
        this.$root.nextStory();
        // this.$emit('scene-complete');
      }
    },
    liveTextComplete: async function(){
      if (this.state == 'trainee'){
        this.showButons = true;
      } 
      else if (this.state == 'understaffed'){
        await wait(200);
        this.showExclamation = true;
 
        await wait(200);
        this.showDialog = false;
        this.showWizard = true;

        // https://michaelnthiessen.com/force-re-render
        // this.$nextTick(() => {
        //   debugger;
        //   this.$refs['wizard'].style.left = '105%';
        // });
        await wait(100);
        this.$refs['wizard'].style.left = '105%';

        await wait(2000);
        this.showButons = true;        
      } 
      // else if (this.state == 'chase'){
      // }
    },
  },
  template: '#intro-scene-template'
});

// You're the trainee right?
// This causes the buttons to show up
// User clicking the buton advances the state -- 


Vue.component('glitch', {
  props: {
    start: {type: String},
    end: {type: String},
  },
  data: function(){
    return {
      showStart: true,
    }
  },
  methods: {
    glitch: async function(){
      await wait(1000);
      this.showStart = false;
      this.$root.play('glitch');

      await wait(200);
      this.showStart = true;
      await wait(200);
      this.showStart = false;
      this.$root.play('glitch');

      await wait(200);
      this.showStart = true;
      await wait(200);
      this.showStart = false;
      this.$root.play('glitch');
    }
  },
  template: '#glitch-template'
});

Vue.component('input-box', {
  props: {
    right: {type: Number, default: 0},
    hints: {
      type: Array, 
      default: function(){ return ['Try again']; },
    },
    onRight: {
      type: Function,
      default: function(){},
    },
  },
  computed: {
    feedback: function(){
      return this.hints[Math.min(this.numWrong, this.hints.length-1)];
    },
    isYay: function(){
      return this.val == this.right;
    },
    isNope: function(){
      return !this.isYay;
    }
  },
  data: function(){
    return {
      val: null,
      showNopeText: false,
      // numWrong: 0,
    }
  },
  methods: {
    answerSubmit: async function(){
      bus.$emit('answer-submitted', this);

      // look at the value in the input.
      if (this.isYay){
        this.showNopeText = false;
        await wait(1000);
        this.onRight();
      } else {
        this.numWrong++;
        this.showNopeText = true;
      }
    }
  },
  template: '#input-box-template'
});

function firstAncestorOfComponent(node, componentName){
  while(node !== undefined){
    node = node.$parent;
    if (node !== undefined && node.$options.name === componentName){
      return node;
    }
  }
  return undefined;
}

function isDescendant(ancestor, maybeChild){
  var node = maybeChild.$parent;
  while(node !== undefined){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }
  return false;
}

Vue.component('avatar', {
  props: {
    image: {type: String}, // 'girl.png'
    text: {type: String, default: ''},
    animation: {type: String, default: 'wobble'},
    sound: {type: String},
  },
  data: function(){
    return {
      // Internally triggered events.
      showQuestion: false,
      showNewQuestion: false,

      showMiniDialog: false,
      showLiveText: false,
      showHint: false,

      showRainbow: false,
      showFall: false,
      showNewText: false,

      reactionImage: null,
      nopeText: null,
    };
  },

  mounted: async function(){
    // Add a blink
    var this_ = this;

    if (this.sound){
      this.$root.play(this.sound);
      await wait(sounds[this.sound].duration || 500);
    }

    await wait(500);
    this_.showLiveText = true;

    bus.$on('avatar-react', function(params){
      this_[params.key] = params.value;
    });

    bus.$on('answer-submitted', function(input){
      this_.reactToInput(input);
    });

    // setInterval(async function(){
    //   // change it to the blink
    //   console.log('blinking');
    //   this_.reactionImage = 'monster_blink.png';
    //   await wait(100);
    //   this_.reactionImage = null;
    // }, 3000);
  },
  computed: {
    imgClasses: function(){
      var classes = {fallover: this.showFall};
      classes[this.animation] = true;
      return classes;
    },
    imgSrc: function(){
      return 'images/'+ (this.reactionImage || this.image);
    }
  },

  methods: {
    hasSlot: function(name){
      return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
    },

    // For some reason, this need to be a separate fn, rather than inside the bus.
    // when the player clicks on a nope button, if the button has nope text, that is rendered.
    // otherwise, if the avatar has a hint slot that is shown.     
    reactToInput: function(input){
      // when the player clicks on a nope button, if the button has nope text, that is rendered.
      // otherwise, if the avatar has a hint slot that is shown. 

      if (input.nopeText){  
        this.nopeText = input.nopeText;        
      } else if(input.isNope && this.hasSlot('hint')){
        this.showHint = true;
      }
    }
  },
  template: '#avatar-template'
});


// Just like a button, but with some special abilities.
// When clicked it looks at it's parent to see if it's a buton-group.
// Executes the onClick event if so.
// e.g.
// <buton-group onClick="doSomethingSecond">
//   <buton @click="doSomethingFirst">Click me</buton>
// </buton-group>

// However, if the buton is a nope buton the buton-group does not get triggered.
// <buton nope="stop and think">Tricked ya</buton>
// <buton nope>Tricked ya</buton>

// Buttons may also have a yay attribute.
// Which causes the button to turn rainbow-text after it gets clicked.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.

    // moved to attr
    //yay: {type: Boolean, default:false}, // Causes cool animation to happen when clicked.
  },
  data: function(){
    return {
      showNopeText: false,
      showRainbowText: false,
      showX: false,
      clickedButton: false,
    }
  },
  computed: {
    nopeText: function(){
      return this.nope;
    },
    // Returns true for: <buton nope> or <buton nope="why not">
    isNope: function(){
      return this.nope || this.nope==="";
    },
    isYay: function(){
      return 'yay' in this.$attrs;
    },
  },
  methods: {
    butonClicked: async function(){
      this.$root.play('buton');
      this.clickedButton = true;

      // Mark the buton as wrong.
      if (this.isNope){
        this.showX = true;
      }

      // Tell those listening on the bus that the buton has been clicked... unless it's a buton within an input-box.
      if(!firstAncestorOfComponent(this, 'input-box')){
        bus.$emit('answer-submitted', this);        
      }

      await wait(1000);
      this.$emit('clik');


      if (!this.isNope && this.$parent.onClick !== undefined){
        // Add delay so any custom handlers on the buton execute before the generic buton-group executes.
        await wait(1000);
        this.$parent.onClick();        
      }

    },
  },
  template: '#buton-template'
});

Vue.component('exp', {
  props: {
    base: {type: String },
    pow: {type: String },
  },
  template: '#exp-template'
});

Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  template: '<div><slot></slot></div>'
});


Vue.component('centered', {
  template: '#centered-template'
});

Vue.component('bold', {
  template: '#bold-template'
});

Vue.component('interstitial', {
  props: {
    image: {type: String, default: 'monster.png'}, 
  },
  computed: {
    cropCircleStyle: function(){
      return {'background-image': 'url("images/' + this.image + '")'};
    }
  },
  mounted: function(){
    this.$root.play('chimes');
  },
  template: '#interstitial-template'
});

function makeComponent(componentName, points, reactions){
  Vue.component(componentName, {
    data: function(){
      return {
        active: 'intro',
        lastActive: 'intro',

        points: points, // jump points in the story

        problemToCorrectness: {}, // 'fakeout1': [false, true]
        memory: null, // A variable for dumping short term component state.
      };
    },
    computed: {
      activeOrLastKnownPoint: function(){
        if (this.isKnownPoint(this.active)){
          return this.active;
        }  
        return this.lastActive;
      }
    },
<<<<<<< HEAD
    watch: {
      answerSubmittedComponent: function(input){
        this.reactOnAnswer(input);
      }
    },
    methods: {
      reactOnAnswer: function(input){
        if (!isDescendant(this, input)){
          return;
        }

        //store.commit('resetAvatar');

=======
    mounted: async function(){
      var this_ = this;
      bus.$on('answer-submitted', async function(input){
        // Respond only if the input is within the current component.
        if (!isDescendant(this_, input)){
          return;
        }

>>>>>>> parent of 231cb36... Removed bus in favor of vuex
        // Have avatar react based on buton attributes.
        var avatar = firstAncestorOfComponent(input, 'avatar');

        if (!avatar){
          // The buton was not used within an avatar, but something else.
          return;
        }
        var problemKey = avatar.$vnode.data.key;

        // If there's a yay.
        if (input.isYay){
          avatar.reactionImage = reactions.yay;
<<<<<<< HEAD
          this.addCorrectness(problemKey, true);          
          this.$root.play('right');
        }


        // If the user got it on their first try, show a rainbow.
        if (this.perfect(problemKey)){
          this.react('showRainbow', true);
        }  else {
          this.react('showRainbow', false);
=======
          this_.addCorrectness(problemKey, true);          
          this_.$root.play('right');

          // If the user got it on their first try, show a rainbow.
          if (this_.perfect(problemKey)){
            this_.react('showRainbow', true);
          }
>>>>>>> parent of 231cb36... Removed bus in favor of vuex
        }
        
        // just a naked <buton nope>
        if (input.isNope){
          avatar.reactionImage = reactions.nope;
          this_.addCorrectness(problemKey, false);  
        } 

        if ('coy' in input.$attrs){
          avatar.reactionImage = reactions.coy;
          this_.$root.play('coy');
        }
      });
    },
    methods: {
      addCorrectness(key, isCorrect){
        if(!(key in this.problemToCorrectness)){
          this.problemToCorrectness[key] = [];
        }
        this.problemToCorrectness[key].push(isCorrect);
      },
      isKnownPoint: function(point){
        return points.map(d => d.key).indexOf(point) > -1;
      },
      react: function(k, v){
        bus.$emit('avatar-react', {key: k, value: v});
      },
      print: function(thing){
        console.log(thing);
      },
      show: function(key){
//        return true;
        return key == this.active;
      }, 
      got: function(key){
        // Return the latest value
        if (this.problemToCorrectness[key]){
          var answers = this.problemToCorrectness[key];
          return answers[answers.length-1];
        } else {
          console.warn('checking for correctness of ' + key + ' which did not exist');
          return false;
        }
      },
      set: async function(key, optionalDelay){
        // Only update the lastActive point if the point is a known point.
        if (this.isKnownPoint(this.active)){
          this.lastActive = this.active;          
        }
        console.log('setting: ' + key);
        if (optionalDelay !== undefined){
//          console.log('started waiting');
          await wait(optionalDelay);        
 //         console.log('done waiting');
        }

        this.active = key;
      },
      delay: async function(fn, ms){
        await wait(ms);
        fn();
      },
      perfect: function(key){
        // All answers to this problem were correct.
        if(this.problemToCorrectness[key] && _.every(this.problemToCorrectness[key])){
          return true;
        }
        return false;
      },
      pointStyle: function(point){
        if (this.perfect(point.key)){
          return {
            'background-image' : "url('images/rainbow.png')",
            'background-size': 'cover'
          };
        } 
      },
      finish: async function(){
        this.play('achievement');
        await wait(1500);
        this.$root.nextStory();
      }
    },
    template: '#' + componentName + '-template'
  });
}

// Joint prob with independence
makeComponent('coin-flips', 

[
  { key: 'intro', name: 'Intro', },
  { key: 'HHHHH', name: '5 heads', },
  { key: 'independence', name: 'Independence'},
  { key: 'HH', name: 'Probability of 2 heads', },
  { key: 'HHH', name: 'Probability of 3 heads', },
  { key: '10H', name: 'Probability of 10 heads', },
  { key: '10HT', name: 'Probability of 10 heads and tails', },
  { key: '100H', name: '100 heads', },
  { key: 'congrats', name: 'Congrats', },
],

{
  'yay': 'monster_fuzzy_happy.png',
  'nope': 'monster_fuzzy_sad.png'
}
); 

// Conditional prob + join prob with chain rule
makeComponent('chain-rule', [
  { key: 'intro', name: 'Intro', },
  { key: 'fakeout1', name: 'Independence', },
  { key: 'conditional1', name: 'Conditional probability', },
  { key: 'tall-hair', name: 'P(tall AND great hair)', },
  { key: 'fakeout2', name: 'Tattoos', },
  { key: 'chainruleinter1', name: 'Chain Rule', },
  { key: 'problem3', name: 'P(tall AND great hair AND tattoos)', },
  { key: 'problem4', name: 'They need to be single', },
  { key: 'mind-blown', name: 'Mind blown', },
  { key: 'congrats', name: 'Congrats', },
  ],

{
    'yay': 'girl_happy.png',
    'nope': 'girl_upset.png',
    'coy': 'girl_coy.png'
}
); 

// EV
makeComponent('risk-reward', [
  { key: 'intro', name: 'Intro', },
  { key: 'ev', name: 'EV', },
  { key: '100', name: 'EV 100', },
  { key: '100-chart', name: 'Binomial distribution', },
  { key: 'congrats', name: 'Congrats', },
]); 



// Can be used to delay logic
// <delay></delay>
Vue.component('delay', {
  props: {
    ms: {type: Number, default: 500},
    visible: {type: Boolean, default: false},
  },
  data: function(){
    return {
      shouldTrigger: false,
    }
  },
  computed: {
    compStyle: function(){
      if (this.visible){
        return {};
      } else {
        return {'display': 'none'};
      }
    }
  },
  mounted: function(){
    var this_ = this;
    setTimeout(function(){
      this_.shouldTrigger = true;
    }, this.ms);
  },
  template: `<span v-if="shouldTrigger" style="compStyle"><slot></slot></span>`,
});


// Hides content until it is revealed as part of the story.
Vue.component('story', {
  props: {
    visible: {type: Boolean, default:false},
  },
  data: function(){
    return {
      isVisible: this.visible,
    };
  },
  watch: {
    isVisible: scrollWindow,
  },
  template: '#story-template'
});


/*

How should this work:
- split the text into words
- inject the words in via setinterval
- add a transition component that makes it fade in when it is injected
*/
Vue.component('live-text', {
  props: {
    interval: {type: Number, default: 1000},
  },

  render: function (createElement) {
    var data = [];

    for (var i=0; i<this.$slots.default.length; i++){
      var vnode = this.$slots.default[i];

      if (vnode.tag){
        data.push([vnode.tag, vnode.data, vnode.children])
      } else if (vnode.text){
        var tokens = vnode.text.split(' ').filter(token => token);
        data = _.concat(data, tokens.map(token => ['span', {}, token + ' ']));
      }
    }

    var vnodes = data.map(function(tuple, i){
      const tag = tuple[0];
      const nodeData = tuple[1];
      const children = tuple[2];
      const meta = {
        ref: i, 
        class: { 'hidden-at-first': true }
      };

      return createElement(tag, _.merge(meta, nodeData), children);
    });

    return createElement(
      'div',   // tag name
      vnodes, 
    )
  },

  data: function(){
    return {
      visibleTokens: [],
    };
  },

  mounted: function(){
    console.log('mounting live text');
    this.render();
  },
  methods: {
    render: async function(){
      var elts = _.values(this.$refs);

      function pauseDuration(text){
        const short = 100;
        const med = 500;
        const long = 1000;
        if (!text){
          return short;
        }
        if (text.includes('.') || text.includes('?') || text.includes('!')){
          return long;
        }
        if (text.includes(')')){
          return med;
        }
        return short;
      }

      this.$root.play('speech');
      for (var i=0; i<elts.length; i++){
        var elt = elts[i];
        elt.style.opacity = 1;

        // Pause.
        var duration = pauseDuration(elt.textContent);
        if (duration == 1000){
          this.$root.pause('speech');
        }
        await wait(duration);
        if (duration == 1000){
          this.$root.play('speech');
        }
      }

      this.$root.pause('speech');
      this.$emit('live-text-complete');
    },
  },
  template: '#live-text-template'
});

// <intro-scene key="intro" v-if="show('intro')" @scene-complete="set('intro1')">
// </intro-scene>

var storyPoints = [
{
  name: 'Intro',
  component: 'intro-scene',
  image: 'cop.png',
},
{
  name: 'Coin Flips',
  component: 'coin-flips',
  image: 'monster.png',
},
{
  name: 'Chain Rule',
  component: 'chain-rule',
  image: 'girl.png',
},
// {
//   name: 'Risk Reward',
//   component: 'risk-reward',
//   image: 'bear.png',
// },

];

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {

    storyPoints: storyPoints,
    storyPointInd: 0,

    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    //soundNameToCount: {},

    show: false,
    isPlaying: false,
  },

  computed: {
    currentStoryPoint: function(){
      return this.storyPoints[this.storyPointInd];
    }
  },
  // watch: {
  //   currentStoryPoint: function(){
  //     this.$root.play('swish');
  //   },
  // },

  methods: {
//    show: show, 
    renderAsPercent: renderAsPercent,

    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,
    nextStory: async function(){
      // this.play('achievement');
      // await wait(1500);
      this.storyPointInd = Math.min(this.storyPoints.length-1, this.storyPointInd+1);
    },

    // // Given 0.8 --> returns {}
    // paramsFromCertainty: function(certainty){
    //   if (certainty == 1.0){
    //     return {
    //       numLoseIfWrong: 10000000, 
    //       numWinIfRight: 1,
    //       certainty: certainty,
    //       percent: '100%',
    //     };
    //   }
    //   return {
    //     numWinIfRight: 1, 
    //     numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
    //     certainty: certainty,
    //     percent: this.renderAsPercent(certainty)
    //   };      
    // },

    // paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
    //   var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
    //   return this.paramsFromCertainty(certainty);
    // },

    play: function(soundName){
//      console.log('playing ' + soundName);
      var sound = sounds[soundName].clip;
      sound.play().catch(function(error){
        console.log(error.toString());
//        debugger;
      });    
    },
    pause: function(soundName){
 //     console.log('pausing');
      var sound = sounds[soundName].clip;
      sound.pause();
      sound.currentTime = 0;      
    }
  } // end methods
});

</script>
