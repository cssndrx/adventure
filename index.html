<!doctype html>
<meta charset="utf-8" />

<head>
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,400,700,900" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet">

<script src="js/lodash.min.js"></script>
<script src="js/d3.v4.min.js"></script>

<script src="js/vue.js"></script>

<script src="js/utils.js"></script>
<script src="js/monk.js"></script>
<script src="js/forest.js"></script>

<style>

h4{
  font-size: 18px;
  font-weight: 500;
}

button{
  font: inherit;
  color: inherit;
  cursor: pointer;
  transition: 1s ease all;
}

button:disabled,
button[disabled]{
/*  cursor: none; */
}

.sign-text{
  font-family: 'Gloria Hallelujah', cursive;
}

.sign{
  border-bottom: 4px solid transparent;
}
.sign:hover{
  border-bottom: 4px solid #ddd;
}

body {
/*  font-family: Helvetica Neue, Arial, sans-serif;*/
  font-family: 'Source Code Pro', monospace;
  font-size: 14px;
  line-height: 1.4;
}

a{
  color: #337ab7; /* boostrap blue */
  text-decoration: none;
}

div{
  margin-bottom: 16px;
}

img{
  max-width: 400px;
}

.item-img{
  max-width: 100px;
  display: block;
  margin: 0 auto;
  margin-top: 16px;
  margin-bottom: 16px;
}

.image-button{
  padding: 16px;
  width: 180px;
  height: 150px;
}

.image-button img{
  max-width: 150px;
  max-height: 100px;
}

.congrats{
  background-color: #23418b; /* monk blue */
  border-radius: 8px;
  padding: 8px;
  color: #fff;
}

.selected-answer{
  background-color: #777;
  color: white;
}

.fade-from {
 opacity: 0  
}

.fade-to {
 opacity: 1  
}

.fade-in {
  transition: opacity 0.5s
}


.story-index{
  margin-top: 32px;
  border: 2px solid grey;
}

a{
  cursor: pointer;
}

button {
  max-width: 150px;
  margin-right: 8px;
}

.active-tab{
  font-weight: bold;
}

.inactive-tab{
  color: #bbb;
}

.ev-answer-bar{
  transition: all 1s ease;
}

.forest-intro-problem{
  font-size: 12px;
}

.draggable-moneybag {
  transition: all 1s ease;
}

.draggable-moneybag:hover{
  border: 2px solid green;
}

</style>

<body>


<div id="app" style="position:relative">

<div style="max-width: 400px; margin: 0 auto; text-align: center;">

<!-- <div><img src="images/map.jpg" width="400px"></div>
<button>Enter</button> -->



<div style="width: 150px; position:absolute; left: 0px; text-align: left; padding-left: 16px">

  <div v-for="storyPoint in storyPoints"
      @click="currentStoryPoint = storyPoint"
      style="margin-bottom: 4px;"
      :style="storyPointStyle(storyPoint)">
    <a :class="[storyPoint === currentStoryPoint ? 'active-tab': 'inactive-tab']">{{storyPoint.name}}</a>
  </div>

</div>


<keep-alive>
  <component v-bind:is="currentStoryPoint.component"></component>
</keep-alive>


<!--

<div>Which plant is poisonous?</div>
<button class="image-button">
  <img src="images/dolls_eyes.jpg">
  <div>This one</div>
</button>
<button class="image-button">
  <img src="images/poke_weed.jpg">
  <div>That one</div>
</button>



<div>
Now, let's see if you can make enough money to fund your journeys...
</div>

<div>
(swirl transition into game)
have bar showing how much money is needed.
</div> -->


<!-- 

<text-animation :tokens="['Hm', '.', '.', '.', '.', '.']" :interval="100"></text-animation>

<stagger>
  <div>{{testVal}}</div>
  <div>2</div>
  <div>3</div>
</stagger>


{{testVal}}
<once-group>
  <once-button :onClickFn="() => testVal='A'">A</once-button>
  <once-button :onClickFn="() => testVal='B'">B</once-button>
</once-group>

-->




</div> <!-- end centering box -->



</div> <!-- end #app -->



<!-- begin templates -->


<script type="text/x-template" id="certainty-widget-template">
<div>

  <once-group>
    <once-button 
      :key="certainty"
      :value="certainty"
      v-for="certainty in certainties" 
      :onClickFn="submitCertainty"
      @mouseenter.native="hoveredCertainty = certainty"
      >{{$root.renderAsPercent(certainty)}}</once-button>
  </once-group>

  <moneybag-widget v-show="hoveredCertainty !== null" :numLoseIfWrong="$root.paramsFromCertainty(hoveredCertainty).numLoseIfWrong"></moneybag-widget>

</div>
</script>


<script type="text/x-template" id="moneybag-widget-template">
<table style="text-align: left">
  <tr>
    <td style="width:50px;font-size:10px;">Win if right ({{numWinIfRight}})</td>
    <td><img v-for="n in numWinIfRight" 
             :style="{width: moneybagWidth+'px'}" 
             style="margin-right:2px"
             src="images/moneybag.png"></td>
    <td v-if="showCertainty" style="position:relative;left:50px;font-size:20px;">
      <span style="font-weight:bold; font-size:24px;">{{percent}}</span> sure
    </td>
  </tr>
  <tr>
    <td style="width:50px;font-size:10px;">Lose if wrong ({{Math.max(numLoseIfWrong, numInteractiveBags)}})</td>
    <td> 
      {{relativeMousePos}}
      <div v-if="isInteractive" 
        class="ref-element" 
        droppable="true"
        style="border: 1px solid blue; width: 340px;">
        <img v-for="n in (numInteractiveBags - 1)" 
             :style="{width: moneybagWidth+'px'}" 
             style="margin-right:2px"
             src="images/moneybag.png">

        <img :style="{width: moneybagWidth+'px'}" 
             src="images/moneybag.png"
             draggable="true"
             class="draggable-moneybag"
             @drag="onDrag($event)">
      </div>
      <button v-if="isInteractive">Submit</button>


      <span v-if="!isInteractive"
            style="position:relative; display:inline-block;">
        <img v-for="n in Math.ceil(numLoseIfWrong)" 
             :style="{width: moneybagWidth+'px'}" 
             style="margin-right:2px"
             src="images/moneybag.png">

        <!-- cover up to make a fractional moneybag -->
         <span v-if="positiveFraction > 0.01"
               style="background-color:white; position:absolute; right: 0px; top:0px;" 
               :style="fractionalCoverStyle"></span>
      </span>
    </td>
  </tr>
</table>
</script>

<script type="text/x-template" id="story-template">
  <div v-if="isActive" class="story">
    <slot></slot>
  </div>
</script>


<script type="text/x-template" id="text-animation-template">
<div>
  {{visibleText}}
</div>
</script>


<script type="text/x-template" id="monk-question-template">
<div>
  <div style="display:inline-block">
    <img src="images/monk_head.png" style="width:80px;">
  </div>

<div style="display:inline-block; width:300px">
  <div style="display:inline-block">
    {{datum.question}}
  </div>

  <once-group>
    <once-button v-for="answer in datum.answers"
                 :key="answer"
                 :value="answer"
                 :onClickFn="userChoseAnswer">{{answer}}</once-button>
  </once-group>


  <div v-if="userAnswer">
    <div>How sure are you of your answer?</div>

    <certainty-widget v-if="vizType == 'certainty'"
                     @bet-submit="onBetSubmit">
    </certainty-widget>

    <moneybag-widget v-if="vizType == 'bet'" 
                     @bet-submit="onBetSubmit"
                     :isInteractive="true"
    ></moneybag-widget>
  </div>
</div>

</div>
</script>


<script type="text/x-template" id="special-monk-interaction-template">
<div>
  <monk-question @answer-complete="onAnswerComplete"
                 :datum="datum"
                 :vizType="vizType"></monk-question>


  <text-animation v-if="userCertainty !== null"
                  :tokens="['Hm', '.', '.', '.', '.', '.']" 
                  :interval="100"
                  @text-animation-complete="showExplanation=true;"></text-animation>

  <div v-if="showExplanation">

    <div v-if="datum.id === 'uniform-prior'">
      <div v-if="userCertainty === 0.5">
        Good. You will receive a 1 moneybag reward.
        <hidden>{{numMoneybagsGained = 1}}</hidden>
      </div>
      <div v-if="userCertainty !== null && userCertainty !== 0.5">
        <div>
          Hm, what do you know that makes you think {{userAnswer}} is more likely? 
        </div>
      </div>

      <!-- Explanation shows up regardless. -->
      <div>
        As a newcomer to this world, you don't know anything about these two places, it is equally likely that your quest could proceed through either of them. In this case, it makes sense to choose either answer but express your certainy as 50 - 50. This is called a uniform prior. You have no information, so all choices are equal.
      </div>

      <button @click="emitQuestionComplete">Continue</button>
    </div> <!-- end uniform prior -->


    <div v-if="datum.id === 'rain-prior'">
      <stagger>

      <div v-if="userCertainty === 0.5">
        Ah, you chose 0.5 because you are unsure whether it will rain tomorrow? 0.5 should be used to express total uncertainty, but in this case you do know something.
      </div>

      <div v-if="isUserCorrect === true && userCertainty > 0.5">
        Very wise. You will receive a 1 moneybag reward.
        <hidden>{{numMoneybagsGained = 1}}</hidden>
      </div>

      <div v-if="isUserCorrect === false && userCertainty > 0.5">
        Hm... I Don't think that's quite right.
      </div>

      <!-- Explanation shows up regardless. -->
      <div>
        I also don't know whether it will rain tomorrow, but based off our past experiences living on earth, there are more sunny days than rainy days -- so in this case you have prior knowledge on the frequency of sunny days vs rainy days which you can use to inform your decision.
      </div>

      <div>
      A calibrated player would answer based on the observed frequency of rain.
      </div>

      <div>
        It is also possible to incorporate additional knowledge, like whether it rained yesterday, into your probability but that's a topic for another day.
      </div>

      <button @click="emitQuestionComplete">Continue</button>
      </stagger>
    </div> <!-- end rain prior -->


    <div v-if="datum.id === 'brenda-question'">

      <!--
      // User right answer with 100% certainty
      // Mm... good. You recognized the Conjuction Fallacy.

      // While it is mathematically true that you have selected the right 
      // answer, but I personally shy away from being 100% certain about
      // anything because it means that you would be willing to give up an
      // entire universe of moneybags if wrong, in exchange for a single 
      // moneybag if you are right. And who knows, you might have misunderstood
      // the question... 

      // In this case, you were right though. Here is your 1 moneybag reward.
      -->

      <stagger>
      <div v-if="userCertainty == 0.9 && isUserCorrect">
        Mm, very good. You will receive a 1 moneybag reward.
        <hidden>{{numMoneybagsGained = 1}}</hidden>
      </div>

      <div v-if="userCertainty < 0.9 && isUserCorrect">
        Your answer is correct but why aren't you more certain? 
      </div>

      <div v-if="isUserCorrect === false">
        Ah, not quite... 
      </div>

      <div>
        The chance that Brenda is a millenial AND something else is true, is always lower than the chane that Brenda is a millenial.
      </div>

      <div>
        This is known as the <a href="//en.wikipedia.org/wiki/Conjunction_fallacy" target="_blank">Conjunction Fallacy</a>  where sometimes our brains get tricked into pattern matching, but if you think about the actual probabilistic events the answer is clear. Take a look at the most famous example, the Linda Problem.
      </div>

      <button @click="emitQuestionComplete">Continue</button>
      </stagger>

    </div> <!-- end brenda -->

    <div v-if="datum.id === 'linda-question'">

      <stagger>
      <div v-if="userCertainty == 0.9 && isUserCorrect">
        Mm, very good. You seem to understand the Conjunction Fallacy, and will receive a 1 moneybag reward.
        <hidden>{{numMoneybagsGained = 1}}</hidden>
      </div>

      <div v-else>
        <div>
          This question was exactly the same as the Brenda situation above.
        </div>

        <div v-if="isUserCorrect === false">
         Oh well...
        </div>

        <div v-if="userCertainty < 0.9">
          Your answer is correct but why aren't you more certain?
        </div>

      </div>

      <button @click="emitQuestionComplete">Continue</button>
      </stagger>

    </div>

</div> <!-- end show explanation -->

</div>
</script>



<script type="text/x-template" id="basic-monk-interaction-template">
<div>
  <monk-question @answer-complete="onAnswerComplete"
                 :datum="datum"
                 :vizType="vizType"></monk-question>


  <text-animation v-if="userCertainty !== null"
                  :tokens="['Hm', '.', '.', '.', '.', '.']" 
                  :interval="100"
                  @text-animation-complete="isMonkDoneThinking=true;"></text-animation>

  <div v-if="isMonkDoneThinking">

    <stagger v-if="isMonkBetting === false"
                      @stagger-complete="monkReactionComplete">
      <div>
         I don't feel like betting with you on that one. I don't have to bet with you on all these questions, by the way. 
      </div>
      <div>
         So if you were really {{percent}} sure, that's great. Keep doing what you are doing. But the more sure you are, the more likely I am to bet with you. This is to encourage you to be better calibrated, and give your true certainty.
      </div>
    </stagger>

    <stagger v-else-if="isUserCorrect"
                      @stagger-complete="monkReactionComplete">
      <div>That is correct.</div>
      <div>You win {{numMoneybagsGained}} moneybags.</div>
    </stagger>

    <stagger v-else-if="!isUserCorrect"
                      @stagger-complete="monkReactionComplete">
      <div>Nope, that's incorrect.</div>
      <div>You lose {{Math.abs(numMoneybagsGained)}} moneybags.</div>
    </stagger>

  </div>
</div>
</script>



<script type="text/x-template" id="monk-game-template">
<div>

  <div style="font-size: 12px;">    
    <div>
    Dear player, earn enough moneybags to leave the monastery and begin your travels.
    </div>

    <div>
    The more sure you are in your answers, the more likely the monk will take you up on your bet — but  also the more you stand to lose.
    </div>

    <button @click="show('questions')">Ok!</button> 
  </div> 

  <div v-for="question in visibleQuestions">

    <div style="border-top: 1px solid #eee;"></div>

    <basic-monk-interaction
      v-if="question.type === 'basic'"
      :key="question"
      :datum="question"
      @question-complete="onQuestionComplete"></basic-monk-interaction>

    <special-monk-interaction
      v-if="question.type === 'special'"
      :key="question"
      :datum="question"
      @question-complete="onQuestionComplete"></special-monk-interaction>

  </div>


  <story ref="questions">

  </story>

  <!--progress indicator -->
  <div style="position:fixed; width: 50px; bottom: 0px; right:50px;"> 
    Acquired 
    <span style="display:inline-block">{{$root.roundTo(numUserMoneybags, 1)}}/{{numMoneybagsNeeded}}</span>
    <img width="30px" src="images/moneybag.png">
  </div> 

  <div v-if="gameOutcome === 'userWon'">
    <div>
      Congratulations adventurer. Through the visualization of fair bets, you have reduced your susceptibility to the Overconfidence Effect.
    </div>

    <div>
      You have also learned about priors, in particular the uniform prior when you are completely unsure. 
    </div>

    <div>
      And the Linda Problem.
    </div>    

    <div>
      You have earned the requisite moneybags to proceed in your quest.
    </div>

    <button @click="isGameComplete=true;">Proceed</button>
  </div>

  <div v-if="gameOutcome === 'monkOutOfQuestions'">
    <div>
    Oh no, I'm out of questions but you don't have {{numMoneybagsNeeded}} moneybags yet... What should I do?
    </div>

    <once-group>
      <once-button :onClickFn="() => userWantToProceedPoor=true">Let player proceed in the quest</once-button>
      <once-button :onClickFn="() => userWantsToProceedPoor=false">Send player home</once-button>
    </once-group>
  </div> 


  <div v-if="userWantsToProceedPoor === true">
    <div>
      Very well then. You may proceed but be very careful because you don't have much money to make mistakes!
    </div>

    <button @click="isGameComplete = true;">Proceed</button>
  </div>


  <div v-if="userWantsToProceedPoor === false">
    Okay, go home! Then you can refresh the page and try again.
  </div>

  <div v-if="isGameComplete">
    You may now leave the monastery and journey on. Take care and be sure to make good decisions in the forest.

    <!-- might be cool to have bowing monk art -->

    <button @click="$root.setStoryPoint('forest-intro')">To the forest</button>

  </div>


</div>
</script>



<script type="text/x-template" id="wooden-sign-template">
  <div style="position:relative; display:inline-block;" class="sign">
    <img src="images/sign7.png" style="width: 190px;" :style="{height: height + 'px'}">
    <div style="position:absolute; width:170px;height:100px; text-align:center; top: 30px; left:10px; cursor:pointer; color: #4E3B27" class="sign-text">
      <slot></slot>
    </div>
  </div>
</script>


<script type="text/x-template" id="forest-intro-template">
<div>


<h4>Forest journey</h4>

<img src="images/forest1.png">

<div>
  You approach the first fork in the road.
</div>

<div>
Choose which way to proceed.
</div>

<!-- basic prob comparison -->


<wooden-sign>10% chance of getting lost in taking path A</wooden-sign>
<wooden-sign>20% chance of getting lost in taking path B</wooden-sign>


<div>
  <guess-button :onClickFn="() => show('right-basic')">
    <wooden-sign>10% chance of getting lost in taking path A</wooden-sign>
  </guess-button>
  <guess-button :onClickFn="() => show('wrong-basic')" 
                :correct="false">
    <wooden-sign>20% chance of getting lost in taking path B</wooden-sign>
  </guess-button>
</div>


<story ref="right-basic">
That's right. In this forest, you definitely want to minimize the chance of getting lost.
<delay :delayFn="() => show('1-x')" :delay="1000"></delay>
</story>

<story ref="wrong-basic">
Why are you maximizing the chance of getting lost? Try again.
</story>




<story ref="1-x">

  <stagger>

  <div>
    You journey deeper into the forest.
  </div>

  <div>
    Another fork.
  </div>

  <div class="forest-intro-problem">
  <div>
    Path A: 10% chance of getting lost
  </div>
  <div>
    Path B: 80% chance of finding the right way
  </div>
  </div>

  <div>
    <guess-button :onClickFn="() => show('right-1-x')">
      Go A
    </guess-button>
    <guess-button :onClickFn="() => show('wrong-1-x')" 
                  :correct="false">
      Go B
    </guess-button>
  </div>
  </stagger>

  <story ref="wrong-1-x">
    Hm, nope. Try again.
  </story>

  <story ref="right-1-x">
    <div>
    Correct. 
    </div>

    <div>
    This problem is the same as the first, because the probability of finding the right way = 1 - the probability of getting lost. 
    </div>

    <delay :delayFn="() => show('x-in-y-times')" :delay="1000"></delay>
  </story>
</story> 


<story ref="x-in-y-times">
  <div>
    Even deeper into the forest, you see a new sign.
  </div>

  <div class="forest-intro-problem">
  <div>
    Path A: 4 in 5 times you'd get lost
  </div>
  <div>
    Path B: 3 in 4 times you'd get lost.
  </div>
  </div>

  <div>
    <guess-button :onClickFn="() => show('wrong-x-in-y')"
                  :correct="false">
      Go A
    </guess-button>
    <guess-button :onClickFn="() => show('right-x-in-y')">
      Go B
    </guess-button>
  </div>

  <story ref="wrong-x-in-y">
    4 in 5 means you would be getting lost 80% of the time! Try again.
  </story>

  <story ref="right-x-in-y">
    Correct. It is better to get lost 75% of the time, than 80% of the time. 

    <delay :delayFn="() => show('x-y-odds')"></delay>
  </story>

</story>


<story ref="x-y-odds">

  <div>
    You journey on, until you are faced with a new problem...
  </div>

  <div class="forest-intro-problem">
  <div>
    Path A: 4 : 5 odds you'd get lost
  </div>
  <div>
    Path B: 3 : 4 odds you'd get lost.
  </div>
  </div>

  <div>

    <guess-button :onClickFn="() => show('wrong-x-y-odds')"
                  :correct="false">
      Go A
    </guess-button>
    <guess-button :onClickFn="() => show('right-x-y-odds')">
      Go B
    </guess-button>
  </div>

  <story ref="wrong-x-y-odds">
    Nope! Try again.
  </story>

  <story ref="right-x-y-odds">
    Yes!
    <delay :delayFn="() => show('x-y-odds-explanation')"></delay>
  </story>

  <story ref="x-y-odds-explanation">
    <div>
    Notice that 4 : 5 odds of something happening is very different from 4 in 5 times.
    </div>

    <div>
    With 4 : 5 odds, it's fairly 50-50, slightly in favor of not getting lost. 4 : 5 odds means that for every 5 moneybags you stake, you would earn 4 moneybags if the event happens.
    </div>

    <div>
    With 4 in 5 times, you're almost certainly getting lost.
    </div>

    <button @click="$root.setStoryPoint('forest-game')">Continue</button>
  </story>

</story>


</div>
</script>



<script type="text/x-template" id="forest-game-template">

<div>

<div>
Oh dear. 
</div>

<div>
By no fault of your own, you are now lost in this forest. 
</div>

<div>
Hopefully with knowledge of expected value (EV), you will make it 
out alive.
</div>

<div style="position:fixed; width: 50px; bottom: 0px; right:50px;"> 
  <div>HP: {{hp}}</div>
  <div>Progress: {{progress}}</div>
  <div>Inventory: {{inventory}}</div>
</div> 

<img src="images/spirit2.png">

<div>
You feel the swirl of spirits of the forest, as though you're
receiving a warm hug. When it is over, you find yourself knowing that 
the <b>expected value</b> of a random event is the average if you are able to experience a random event many times.
</div>


<once-group>
  <once-button>Continue</once-button>
  <once-button :onClickFn="() => show('spirit-berry')">Thank the forest spirits</once-button>
</once-group>

<story ref="spirit-berry">
  <div>
  Immediately after you finish thanking the spirits, you find
  a berry on the ground. 
  </div>

  <img class="item-img" src="images/berry1.png">
  <div>
  The packaging says: Heals +10HP in a bind.
  </div>

<!-- hm: neither of these are working. todo: debug?
  {{addToInventory('spirit-berry')}}
 <hidden>{{addToInventory('spirit-berry')}}</hidden> -->

  <once-group>
    <once-button :onClickFn="() => {addToInventory('spirit-berry')}">Add to inventory</once-button>
  </once-group>
</story>


<!-- todo: this for loop needs to get removed in favor of individual problem ids, because we have the surrounding text -->
<forest-problem v-for="problem in visibleProblems"   
                :problem="problem"
                :key="problem"
                @problem-complete="onProblemComplete"></forest-problem>



<!-- <div>

<pity-fairy></pity-fairy>                

You finally see light shining through the periphery of the forest.
</div>

[[Shining light at the end of tunnel]]

<div>
With newfound knowledge in expected value, variance (and standard deviation), you stumble out of the forest and into
the radiant sunlight. You have definitely emerged stronger.
</div>-->


</div>
</script>




<script type="text/x-template" id="forest-problem-template">
<div>

<div>
  {{problem.intro}}
</div>

<div><img v-if="problem.images"
     v-for="image_name in problem.images" 
     :src="'images/' + image_name"
     style="max-width:150px; margin:8px; max-height: 150px;">
   </div>

<div>
  <button v-for="choice in problem.choices"
          @click="choiceMade($event, choice)"
          :key="choice">

    <div style="font-size:11px; margin-bottom:4px;">EV: {{outcomesMean(choice.outcomes)}}</div>
    <div>{{choice.name}}</div>

    <distribution v-if="problem.renderAsDistribution" 
                  @outcome-drawn="outcomeDrawn"
                  :ref="choice.name"
                  :outcomes="choice.outcomes" 
                  :fittedX="true" 
                  :chartHeight="100" 
                  :chartWidth="140"></distribution>

    <forest-outcomes v-if="!problem.renderAsDistribution"
                     :ref="choice.name"
                     :outcomes="choice.outcomes" 
    ></forest-outcomes>

  </button>
</div>


<div v-if="userOutcome !== null">

  <stagger>
  <div>
  You chose {{userChoice.name}}. 
  </div>

  <text-animation :tokens="['And', '.', '.', '.', '.', '.']" :interval="100"></text-animation>

  <div>
  You {{userOutcome.hp < 0 ? 'lose': 'gain'}} {{userOutcome.hp}} HP.
  </div>
</stagger>
</div>

</div>

</script>

<script type="text/x-template" id="forest-outcomes-template">
<div>

<div v-for="(outcome, index) in outcomes" :key="outcome" 
  style="font-size:13px; margin-bottom:4px;"
  :style="{'background-color': outcomeColors[index]}">

  {{renderCertainty(outcome.certainty)}}: 

  {{outcome.text}} 

  <span v-if="Array.isArray(outcome.hp)">
    <distribution :outcomes="outcome.hp"></distribution>
  </span>

  <span v-else>
    <span v-if="outcome.hp === 0">
      no effect
    </span>

    <span v-if="outcome.hp !== 0">
      {{outcome.hp >= 0 ? '+' : ''}}{{outcome.hp}} HP 
    </span>

    {{outcome.caption ? '(' + outcome.caption + ')' : ''}}
  </span>
</div>

</div>
</script>


<script type="text/x-template" id="pity-fairy-template">
<div>

<!--// Only shows up if you have met the variance witch?? or should she show up whenever
// You're about to die. One chance to save yourself.

todo: make sure pity fairy analysis is correct
might need to make chance of negative outcome in order to make math work out
-->


<div>
Hello, I am the Pity Fairy. Yikes, you're not in very good health. 
</div>

<div>
There's much more of the forest to go.
</div>

<div>
Would you rather I...?
</div>


hmm: this should probably be a forest-problem
[[higher EV, lower var]]: Restore 12 HP
[[lower EV, really high var]] : 10% chance of restoration 80 HP.

<story ref="wrong">
  <div>
  That's such a pity! I think you chose the wrong answer. 
  </div>

  <div>
  Oh well, here's your HP anyways.
  </div>
</story>

<story ref="right">
  <div>
  Yes, that's clever. 
  </div>

  <div>
  Even though Restore 12HP has a higher EV than a 10% chance of 
  restoring 80HP, in this case I think it makes more sense to choose the 
  lower EV, higher variance option, because that +12HP isn't going to 
  make much of a difference in getting you out of the forest while that
  +80HP would.
  </div>

  <div>
  This is one of the few times it may be worth it to take the lower EV
  option, and is called making a "high variance play".
  </div>
</story>

</div>
</script>

<script type="text/x-template" id="variance-witch-template">
<div>

<img src="images/grim_reaper.png">

<stagger>
  <div>
  I'm the Witch of Variance, or Variance Witch for short. 
  </div>

  <div>
  So far, you have only concerned yourself with expected value (EV)
  which describes how much you expect to gain on average if you are able
  to repeat the random event many times.
  </div>

  <div>
  Of course, there's another important dimension to consider: each time
  you experience the random event, by **how much does what you experience
  deviate from the average**?
  </div>

  <button @click="show('how-to')">That does seem important</button>
</stagger>

<story ref="how-to">
  <div>
  That's what my number tells you. 
  </div>

  <div>
  So, to compute the variance: 
  </div>

  <div>
  Take all the times you experience the random event. Calculate the 
  difference between your experience and the average. Square it so you
  get a positive value. And the average of all those squares is the 
  variance.
  </div>

  <once-group>
    <once-button :onClickFn="() => show('std')">Easy!</once-button>
    <once-button :onClickFn="() => show('why-square')">Why do you square it?</once-button>
  </once-group>
</story>


<story ref="why-square">
  <div>
    You want to square it because you don't want the times that you
    experience a different value more than the average and a different
    value less than the average to cancel out. 
  </div>

  <once-group>
    <once-button :onClickFn="() => show('std')">Oh okay</once-button>
    <once-button :onClickFn="() => show('why-not-abs')">Why don't you take the absolute value?</once-button>
  </once-group>
</story>


<story ref="why-not-abs">
  <div>
    Bah! ??
    todo: ask yan
  </div>

  <button @click="show('std')">Continue</button>
</story>

<story ref="std">
<stagger>
  <div>
  Well actually, I own two related numbers: the variance and the standard
  deviation. The standard deviation is just the square root of the variance. No more no less. 
  </div>


  <div>
  But Standard Deviation Witch didn't have the same ring to it.
  </div>

  <div>
  The neat thing about Standard Deviation is that it's in the same units
  as your original random event*. So it might be easier to have
  intuitions about.
  </div>

  <div>
  Because I like you so much, for the rest of the game I'll help you by
  drawing the standard deviation on distributions like this:
  </div>

  [[distribution]] 

  <div>
  *As opposed to the variance, which is in that unit^2.
  </div>

  <button @click="">Wow! Thanks much, Variance Witch!</button>
</stagger>
</story>

</div>
</script>


<script type="text/x-template" id="monk-dual-quiz-template">

<div>

<div v-for="(certainty, index) in visibleCertainties">
  <div>What is the fair bet if you are {{$root.renderAsPercent(certainty)}} sure?</div>  
  <moneybag-widget 
    @bet-submit="dualAnswerSubmit" :show-certainty="false"
    :isInteractive="true"
    ></moneybag-widget>
  <div>{{monkMessages[index]}}</div>
</div>

<div v-if="isEndGame">
  <stagger>
    <div>
      Haha! I bet you won't ever say that you're 99% sure again!    
    </div>

    <div>
    In my opinion, it is easier to visualize the fair bet and convert that to how sure you are. Human brains work better on concrete numbers and quantities. For more, [[see Dor's research]].
    todo: run that experiment
    todo: link dor
    </div>

    <div>
      To start your quest, you will need to earn enough moneybags to fund your travels. Let's see if you can use what you learned about fair bets.
    </div>

    <button @click="$root.setStoryPoint('monk-game')">Continue</button>
  </stagger>
</div> <!-- end isEndGame -->

</div>

</script>

<script type="text/x-template" id="monk-intro-template">
<div>

<!--    <moneybag-widget 
                     :isInteractive="true"
    ></moneybag-widget> -->

  <div><img src="images/monk.png" width="400px"></div>

  <div>
  So you want to get rid of cognitive biases, eh?
  </div>

  <div>
  <button @click="show('monk-hyderabad-question')">Talk to</button>
  </div>

  <story ref="monk-hyderabad-question">
    <div>Which has the bigger population Hyderabad or Islamabad?</div>

    <once-group>
      <once-button :onClickFn="() => show('monk-hyderabad-certainty')">Hyderabad</once-button>
      <once-button :onClickFn="() => show('monk-hyderabad-certainty')">Islamabad</once-button>
    </once-group>
  </story>

  <story ref="monk-hyderabad-certainty">
    <div>
    How certain are you of your answer?
    </div>

    <certainty-widget @bet-submit="hyderabadCertaintySubmit"></certainty-widget>
  </story>

  <story ref="monk-hyderabad-bet">
    <div>How many money bags are you willing to lose, if I pay you one money bag if you are right?</div>

    <moneybag-widget @bet-submit="hyderabadBetSubmit"  
      :show-certainty="false"
      :isInteractive="true"
    ></moneybag-widget>

  </story>


  <story ref="monk-hyderabad-dual">


      <div v-if="isUserCalibrated === true">
        <stagger>

        <div>
          Ah, you see... those two questions were one and the same.
        </div>

        <div>
          What you think is fair, should directly correspond to how sure you are. 
        </div>

        <div>
        But perhaps you already knew that... because you were well calibrated.
        </div>

        <div>
          Your being {{hyderabadCertaintyParams.percent}} sure, is equivalent to the fair bet that you chose.
        </div>

        <once-group>
          <once-button :value="'monk-dual-explanation'">Explain it anyways</once-button>
          <once-button :value="'monk-dual-quiz'">Yeah, old news</once-button>
        </once-group>
    
        </stagger>
      </div>

      <div v-if="isUserCalibrated === false">
        <stagger>
        <div>
          Hm, not quite.
        </div>
          
        <div>
          Those two questions were one and the same.
        </div>

        <div>
          What you think is fair, should directly correspond to how sure you are. 
        </div>


        <div>
        You said you were {{hyderabadCertaintyParams.percent}} sure, which would translate to the following bet:
        </div>
        <moneybag-widget :showCertainty="false" :numLoseIfWrong="hyderabadCertaintyParams.numLoseIfWrong"></moneybag-widget>
        <button @click="show('monk-dual-explanation')">Why??</button>

        </stagger>
      </div>

  </story>

  <story ref="monk-dual-explanation" v-if="isUserCalibrated !== null">
    <div>
      If you are right {{hyderabadCertaintyParams.percent}} of the time, you win 1 moneybag when you are right. You lose {{$root.renderAsPercent(1-hyderabadCertaintyParams.certainty)}} of the time, and lose {{hyderabadCertaintyParams.numLoseIfWrong}} moneybags. Averaging over many times, you break even. 
    </div>

    <button @click="show('monk-dual-quiz')">Hm...</button>
  </story>

  <story ref="monk-dual-quiz">
    <stagger>

      <div>
        Let's test you out. 
      </div>

      <monk-dual-quiz></monk-dual-quiz>

    </stagger>
  </story>

</div>
</script>


<script type="text/x-template" id="distribution-template">
<div class="dist"
     :style="{ height: chartHeight + 'px', width: chartWidth + 'px'}"
     style="position:relative; margin-bottom:64px;">

  <!-- add axis containing important points -->
  <div class="axis" 
      style="position:relative; bottom: 0px; border-top: 1px solid #F6AB83; font-size:10px; padding-top:8px; text-transform:uppercase"
      :style="{top: chartHeight + 'px'}">
    {{xAttr}}</div>

  <div class="bar" v-for="(outcome, index) in outcomes"
       :key="outcome"
       :style="barStyle(outcome, index)"
       style="position:absolute; background-color:#C55A2C; bottom:0px; text-align: center; font-size:10px; color: white; margin-bottom:0px;"
       >
       {{renderAsPercent(outcome.certainty)}}
       
       <div class="hp-text" style="position:absolute; bottom:-30px; width: 100%; color:black;">{{outcome.hp}}</div>
  </div>

  <!-- show the mean as a bar -->
  <div v-if="showMean" style="border-left: 2px solid #74361F; width:0px; height:160px; position:absolute; bottom: 0px; pointer-events:none; font-size:8px; white-space: nowrap; position:relative;"
       :style="meanStyle">

     <span style="position:absolute;bottom:-12px; color: #74361F; left:-15px; font-weight: bold;">mn {{ $root.roundTo(stats.mean, 1)}}</span>

    <!-- show the std as a horizontal thing -->
    <div v-if="showStd" style="height: 14px; border-top: 1px solid #F6AB83; 
    border-bottom: 1px solid #F6AB83; position:absolute; bottom: -52px; color: #F6AB83; text-align: center; padding-top:2px"
         :style="stdStyle">sd {{$root.roundTo(stats.std, 1)}}</div>

  </div>



</div>
</script>


<script type="text/x-template" id="visual-ev-click-template">

<div>

<!-- might want to plug in spirit story later 

Spirits dance around you.
They encourage you to make a guess. 
Your hand is gently guided to the true of EV. 

They chatter excitedly. Your guess of __ was very close to the true EV of __-. 

You were kind of far off, so the spirits gently guide you to the true answer of ___.

The spirits want you to try another distribution.

-->

<!-- When used on a component, v-on now only listens to custom events $emitted by that component. To listen for a native DOM event on the root element, you can use the .native modifier. 

  https://stackoverflow.com/questions/41475447/vue-v-onclick-does-not-work-on-component -->

<div style="position:relative">
  <distribution ref="distribution" 
    :outcomes="outcomes" 
    @click.native.once="distributionClicked"
    @mousemove.native="mouseX = getRelativeMouseX($event)"
    @mouseenter.native="isMouseover = true"></distribution>

  <!-- tracks the user mouseover and user answer -->
  <div v-if="isMouseover" 
       style="border-left:1px solid red; width:1px; height:200px; position:absolute; bottom: -32px; pointer-events:none;"
       :style="trackerStyle"></div>

  <!-- show the real answer -->
  <div ref="answer-marker"
       v-if="answerPx" 
       class="ev-answer-bar"
       :style="{left: answerPx + 'px'}"
       style="border-left:1px solid green; width:1px; height:200px; position:absolute; bottom: -32px; pointer-events:none;"></div>
</div>


<div v-if="answerReal">
  <stagger @stagger-complete="$emit('visual-ev-click-complete')">
  <div>
  You <span style="color:red">guessed {{$root.roundTo(guessReal, 1)}}</span>. The <span style="color:green">true answer of  {{$root.roundTo(answerReal,1)}}</span> was {{isUserClose  ? 'very close!' : 'far off.'}}
  </div>

  <div>
    {{ isUserClose ? 'Good job!' : 'Needs work.' }}
  </div>

  <div>
    Let's do another.
  </div>

</stagger>


</div>


</div>
</script>


<script type="text/x-template" id="distribution-interlude-template">
<div>

<div>
And that, a visual shortcut for computing the expected value happens
to be the center of mass of the probability distribution. i.e. 
Pretend the probability distribution is made of a solid material
and you are balancing the material on your finger. The X-axis value
of that balance point, is the expected value.
</div>

<div style="font-size: 12px;">
  Click where you think the EV is.
</div>

<visual-ev-click v-for="outcomes in visibleQuestions"
          :outcomes="outcomes"
          :key="outcomes"
          @visual-ev-click-complete="questionInd++"></visual-ev-click>  

</div>
</script>


<!-- end templates -->


<script>

var evQuestions = [

  [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}],

  [{certainty: 0.1, hp:14}, {certainty: 0.3, hp:13}, {certainty: 0.4, hp:12}, {certainty: 0.2, hp:11}],

  [{certainty: 0.8, hp:4}, {certainty: 0.2, hp:3}],

];

Vue.component('distribution-interlude', {
  data: function(){
    return {
      evQuestions: evQuestions,
      questionInd: 0,

      isGameComplete: false,
    };
  },
  computed: {
    visibleQuestions: function(){
      return this.evQuestions.slice(0, this.questionInd+1);      
    },
  },
  watch: {
    visibleQuestions: scrollWindow,
    isGameComplete: scrollWindow
  },
  methods: {
    onQuestionComplete: function(params){
      this.questionInd++;
      // this.numUserMoneybags += params.numMoneybagsGained;

      // if (this.numUserMoneybags == this.numMoneybagsNeeded){
      //   // todo: trigger game end
      //   this.gameOutcome = 'userWon';        
      // } else if (this.questionInd == this.monkQuestions.length){
      //   // todo: trigger game end
      //   this.gameOutcome = 'monkOutOfQuestions';
      // } else {
      //   this.questionInd++;        
      // }
    },
  },
  template: '#distribution-interlude-template',
});

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
Vue.component('forest-outcomes', {
  props: {
    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
    certaintyAs: {type: String, default: 'percent'}, // 'odds'
  },
  data: function(){
    return {
      animatedInd: null,
    };
  },
  computed: {
    outcomeColors: function(){
      var colors = _.times(this.outcomes.length, () => 'transparent');
      if (this.animatedInd !== null){
         colors[this.animatedInd] = '#ccc';
      }
      return colors;
    }
  },

  methods: {


    drawOutcome: async function(){
      var numCycles = 5;
      var outcomeInd = drawIndFromOutcomes(this.outcomes);
      var numIters = numCycles*this.outcomes.length+outcomeInd;

      // milliseconds
      var activeTimes = this.outcomes.map(outcome => outcome.certainty * 500);

      // Each outcome is active for a different length of time.
      for (var i=0; i<numIters; i++){
        var animatedInd = i % activeTimes.length;
        this.animatedInd = animatedInd;
        await wait(activeTimes[animatedInd]);

        // Check if it's the last one and emit an event.
        if (i == this.numIters-1){
          this.$emit('outcome-drawn', {outcomeInd: outcomeInd});          
        }
      }
    },

    renderCertainty: function(certainty){
      if (this.certaintyAs == 'percent'){
        return this.$root.renderAsPercent(certainty) + ' chance';        
      } else if (this.certaintyAs == 'odds'){
        var params = this.$root.paramsFromCertainty(certainty);
        // stopped here figuring out how we want to render x parts chance
        // could hardcode it? 
        return 'nope'; 
      } else{
        console.error('unrecognized certaintyAs: ' + this.certaintyAs);
      }
    },

  },
  template: '#forest-outcomes-template',
});


function outcomesMean(outcomes){
  return sum(outcomes.map(outcome => outcome.certainty * outcome.hp));
}

function outcomesVariance(outcomes){
  var mean_hp = outcomesMean(outcomes);
  return sum(outcomes.map(outcome => outcome.certainty * (outcome.hp - mean_hp) * (outcome.hp - mean_hp)));
}

function outcomesStd(outcomes){
  return Math.sqrt(outcomesVariance(outcomes));
}

Vue.component('visual-ev-click', {
  props: {
    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
  },
  data: function(){
    return {
      isMouseover: false,

      mouseX: null,  // tracks mouse position always

      guessPx: null, // populated when user clicks
      guessReal: null, // populated when user clicks

      answerPx: null, // populated after delay when user clicks
      answerReal: null, // populated after delay when user clicks
    };
  },

  computed: {
    trackerStyle: function(){
      return {
        left: (this.guessPx !== null ? this.guessPx : this.mouseX) + 'px'
      };
    },

    isUserClose: function(){
      // Is close if it's less than X% away from the true answer
      var distribution_component = this.$refs['distribution'];
      var total = distribution_component.xMax - distribution_component.xMin;

      var difference = Math.abs(this.answerReal - this.guessReal);
      return difference / total < .05;
    }
  },

  methods: {
    distributionClicked: function(event){
      var distribution_component = this.$refs['distribution'];
      var stats = distribution_component.stats;
      var xScale = distribution_component.xScale;


      this.guessPx = this.getRelativeMouseX(event);
      this.guessReal = xScale.invert(this.guessPx);

      // answerPx gets animated into the correct position.
      this.answerPx = this.guessPx;
      var this_ = this;
      setTimeout(function(){
        // Make the answer bar to animate.
        this_.answerPx = xScale(stats.mean);

        // Make the text to show.
        setTimeout(() => this_.answerReal = stats.mean, 1000);
      }, 200);

    },

    getRelativeMouseX: function(event){
      // https://stackoverflow.com/questions/5921413/difference-between-e-target-and-e-currenttarget
      // e.target is what triggers the event dispatcher to trigger and e.currentTarget is what you assigned your listener to.

      // Find the 'dist' element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'dist'){
        refElement = refElement.parentElement;
      }

      // console.log(event.target.className + ' ' + event.clientX + '      ' + refElement.className + JSON.stringify(refElement.getBoundingClientRect()));        
      return event.clientX - refElement.getBoundingClientRect().x;
    },

  },
  template: '#visual-ev-click-template',
});

// outcomes = [
//  {certainty: 0.4, hp: 15, caption: 'warmth'}, 
//  {certainty: 0.6, hp: 0, caption: 'you fail to start the fire'}
// ]
Vue.component('distribution', {
  props: {
    outcomes: {type: Array, required: true},
    // barWidth: {type: Number, default: 50},

    chartHeight: {type: Number, default: 160},
    chartWidth: {type: Number, default: 400},

    xAttr: {type: String, default: 'hp'},
    yAttr: {type: String, default: 'certainty'},

    // If we want the x-axis to be the same between problems, so
    // hardcode it here.
    xMin: {type: Number, default: -10},
    xMax: {type: Number, default: 10},
    // Uses xMin and xMax if false, otherwise fits to smallest xMin and xMax.
    fittedX: {type: Boolean, default: false},
    showMean: {type: Boolean, default: false},
    showStd: {type: Boolean, default: false},

    margin: {
      type: Object, 
      default: function(){
        return {top: 0, right: 0, bottom: 0, left: 20};
      }
    },
  },
  computed: {
    barWidth: function(){
      var domain = this.domain;
      return (this.chartWidth - this.margin.left - this.margin.right) / (domain[1] - domain[0]);
    },
    domain: function(){
      // Note: we adjust for barWidth within barStyle.
      var xVals = _.map(this.outcomes, outcome => outcome[this.xAttr]);
      return this.fittedX ? [_.min(xVals), _.max(xVals)] : [this.xMin, this.xMax];
    },
    xScale: function(){
      return d3.scaleLinear()
        .domain(this.domain)
        .range([this.margin.left, this.chartWidth-this.margin.right]);
    },

    yScale: function(){
      return d3.scaleLinear()
        .domain([0, 1])
        .range([this.margin.bottom, this.chartHeight-this.margin.top]);
    },
    stats: function(){
      return {
        mean: outcomesMean(this.outcomes), 
        std: outcomesStd(this.outcomes),
      }      
    },
    meanStyle: function(){
      return {
        left: this.xScale(this.stats.mean) + 'px',
      }
    }, 
    stdStyle: function(){
      var width = this.stats.std * this.barWidth; 
      return {
        // left: this.meanStyle.left,
        width: width + 'px',
      }
    }
  },

  data: function(){
    return {
      animatedInd: null,
    }
  },

  // mounted: function(){
  //   this.drawOutcome();
  // },
  methods: {
    renderAsPercent: renderAsPercent,
    barStyle: function(outcome, barIndex){
      return {
        width: this.barWidth + 'px',
        height: this.yScale(outcome[this.yAttr]) + 'px',
        left: (this.xScale(outcome[this.xAttr]) - this.barWidth / 2) + 'px',
        'background-color': barIndex === this.animatedInd ? 'blue': 'orange'
      };
    },

    // todo: dedup?
    drawOutcome: async function(){
      var numCycles = 5;
      var outcomeInd = drawIndFromOutcomes(this.outcomes);
      var numIters = numCycles*this.outcomes.length+outcomeInd;

      // milliseconds
      var activeTimes = this.outcomes.map(outcome => outcome.certainty * 500);

      // Each outcome is active for a different length of time.
      for (var i=0; i<numIters; i++){
        var animatedInd = i % activeTimes.length;
        this.animatedInd = animatedInd;
        await wait(activeTimes[animatedInd]);

        // Check if it's the last one and emit an event.
        if (i == numIters-1){
          this.$emit('outcome-drawn', {outcomeInd: outcomeInd});
        }
      }
    },

  },
  template: '#distribution-template'
});


Vue.component('pity-fairy', {
  methods: {
    show: show,
  },
  template: '#pity-fairy-template'
});

Vue.component('variance-witch', {
  methods: {
    show: show,
  },
  template: '#variance-witch-template'
});

Vue.component('forest-intro', {
  methods: {
    show: show,
  },
  template: '#forest-intro-template'
});

Vue.component('forest-problem', {
  props: {
    problem: {type: Object, required: true}
  },
  data: function(){
    return {
      userChoice: null,
      userOutcome: null,
    };
  },
  computed: {
    maxEVChoice: function(){
     // function outcomesMean(outcomes){
      var evs = this.problem.choices.map(choice => outcomesMean(choice.outcomes));
      var maxEvInd = evs.indexOf(Math.max(...evs));
      return this.problem.choices[maxEvInd];
    }
  },
  methods: {
    outcomesMean: outcomesMean,
    choiceMade: function($event, choice){
      // var audio = new Audio('sounds/bloop1.wav');
      // audio.play();

      this.userChoice = choice;

      // Color the clicked button.
      var elt = $event.target
      while (elt.tagName !== 'BUTTON'){
        elt = elt.parentElement;
      }
      elt.style.backgroundColor = choice == this.maxEVChoice ? 'green' : 'red';

      // Disable all buttons.
      this.$el.querySelectorAll('button').forEach(elt => elt.disabled=true);

      this.$refs[choice.name][0].drawOutcome(); 
    },

    outcomeDrawn: function(params){
      this.userOutcome = this.userChoice.outcomes[params.outcomeInd];

      debugger;
      this.$emit('problem-complete', {userChoice: this.userChoice,
                                      userOutcome: this.userOutcome});     
    }
  },
  template: '#forest-problem-template'
});


Vue.component('forest-game', {
  data: function(){
    return {
      forestProblems: forestProblems,
      forestItems: forestItems,
      hp: 100,
      inventory: [],

      // showExplanation: false,
      questionInd: 0,
    }
  },
  computed:{
    progress: function(){
      // todo: figure out fraction of questions
      return 0;
    },
    visibleProblems: function(){
      // Return slice from [0, questionInd] inclusive.
      // Slice is safe from array out of bounds errors.
      return this.forestProblems.slice(0, this.questionInd+1);
    },
  },
  watch: {
    visibleProblems: scrollWindow,
//    gameOutcome: scrollWindow
  },
  methods: {
    show: show,
    addToInventory: function(item_name){
      console.log('add to inv: ' + this.forestItems[item_name]);
      this.inventory.push(this.forestItems[item_name]);
    },
    onProblemComplete: function(params){
      var this_ = this;
      setTimeout(function(){this_.questionInd++}, 4000);
      // this.userAnswer = params.userAnswer;
      // this.userCertainty = params.certainty;
    }
  },
  template: '#forest-game-template'
});



// Useful for hiding logic inside of a v-if.
// e.g.
// <div v-if="isUserReallyCorrect">
//   <hidden>{{numMoneybagsGained = 10}}</hidden>
// </div>
Vue.component('hidden', {
  template: `<span style="display:none"><slot></slot></span>`,
});


// Can be used to delay logic
// <delay :delayFn="() => show('wrong-basic')"></delay>
Vue.component('delay', {
  props: {
    delay: {type: Number, default: 500},
    delayFn: {type: Function, required: true},
  },
  mounted: function(){
    var this_ = this;
    setTimeout(function(){
      this_.delayFn();
    }, this.delay);
  },
  template: `<span style="display:none"></span>`,
});

Vue.component('wooden-sign', {
  props: {
    height: {type: Number, default: 150},
  },
  template: '#wooden-sign-template',
});

// https://jsfiddle.net/39hkrot0/5/
Vue.component('once-group', {
  data: function(){
    return {
      userAnswer: null
    }
  },
  template: `<div><slot></slot></div>`,
  methods: {

    // childComponent is always populated
    // onClickFn can be undefined (but defaults to this.$root.show)
    // value can be undefined (if onClickFn does not require value)
    childClicked: function(childComponent, onClickFn, value) {
      if (this.userAnswer !== null){
        return;
      }
      this.userAnswer = value;

      // Change the buttons to indicate that it is disabled.
      var this_ = this;
      this.$slots.default.forEach((item, index) => {
        if (item.tag) {
          // var button_value = item.componentInstance.$props.value;
          // if (button_value === this_.userAnswer){
          if (childComponent === item.componentInstance){
            item.elm.classList.add('selected-answer');
          } else {
            item.elm.setAttribute('disabled', true); 
          }
        }
      });

      if (value === undefined && onClickFn === undefined){
        // this button does nothing. We are probably sketching the story.
        // todo: add an error once we are prod ready
      } else if (value !== undefined && onClickFn === undefined){
        // Value is given but no handler, so assume it's navigation.

        // Traverse up the tree trying to call $parent.show(value) until
        // it succeeds.
        // Log error if it still doesn't work by the time it hits the root.
        var ancestor = this.$parent;
        while (true){
          if (hasShow(ancestor, value)){
            // We successfully found the show.
            break;
          } else {
            if (ancestor === this.$root){
              console.error('once-group could not show(' + value + ')');
              break;              
            }
            ancestor = ancestor.$parent;            
          }
        }
      } else {
        // onClickFn is defined, and it's okay if we pass it an
        // undefined value because it won't be used.
        onClickFn(value);
      } 

    }
  }
});

// once-button must live inside a once-group
// The once-group enforces that only one child can be called once.
Vue.component('once-button', {
  props: {
    value: {type: [String, Number]},
    onClickFn: {type: Function},
  },
  data: function(){
    return {
      self: this
    }
  },
  template: '<button @click="$parent.childClicked(self, onClickFn, value)"><slot></slot></button>'
});

// guess-button differs from once-button, in that it doesn't live in a 
// special parent.
// If a guess-button is clicked, it's siblings may still be clicked.
// guess-button just provides a color to the user whether the guess was
// correct or not
Vue.component('guess-button', {
  props: {
    correct: {type: Boolean, default: true},
    onClickFn: {type: Function},
  },
  data: function(){
    return {
      isClicked: false,
    };
  },
  template: `<button @click="isClicked = true; onClickFn()" 
                    :class="{'selected-answer' : isClicked === true && correct === true}"
                    :disabled="isClicked===true && correct===false"
                    ><slot></slot></button>`
});


// https://jsfiddle.net/jamesbrndwgn/85h6n1q9/14/
Vue.component('stagger', {
  props: {
    interval: {type: Number, default: 500},
  },

  mounted: function(){
    var this_ = this;
    this.$slots.default.forEach((item, index) => {
      // item: VNode
      if (item.tag) { // item.tag: 'div'
        item.elm.classList.add('fade-from'); // item.elm: <div>sup</div>

        setTimeout(() => {
          item.elm.classList.remove('fade-from');
          item.elm.classList.add('fade-in', 'fade-to');
          scrollWindow();

          // trigger that the animation is complete
          if (index == this_.$slots.default.length - 1){
            setTimeout(function(){
              this_.$emit('stagger-complete');
            }, this_.interval);
          }
        }, this_.interval + (index*this_.interval));
      }
    });

    // use setTimeout instead of setInteval
    // todo: look at JS () => {}
  },
  template: `<div><slot></slot></div>`
});

// A component where you give it
// ['Hm', '.', '.', '.', '.', '.']
// and it uses setInterval + data to animate.
// Also trigger an event when it's done? 
Vue.component('text-animation', {
  props: {
    tokens: {type: Array},
    interval: {type: Number, default: 500},
  },
  data: function(){
    return {
      visibleText: '',
    };
  },
  created: function(){
    var current_ind = 0;
    var this_ = this;
    function animation(){
      // Add one token at a time
      // console.log('current_ind: ' + current_ind);
      // console.log('this_.tokens: ' + this_.tokens);
      this_.visibleText = this_.tokens.slice(0, current_ind).join('');
      current_ind++;

      if (current_ind > this_.tokens.length+1){
        clearInterval(animation_timer);
        setTimeout(function(){
          this_.$emit('text-animation-complete');
        }, 500);
      }
    }
    animation();
    var animation_timer = setInterval(animation, this.interval);
  },
  template: '#text-animation-template'
});


// Hides content until it is revealed as part of the story.
Vue.component('story', {
  data: function(){
    return {
      isActive: false,
    };
  },
  watch: {
    isActive: scrollWindow,
  },
  template: '#story-template'
});


var storyPoints = [
{
  name: 'Monk Intro',
  component: 'monk-intro',
},
{
  name: 'Monk Game',
  component: 'monk-game',
},
{
  name: 'Forest Intro',
  component: 'forest-intro',
},
{
  name: 'Forest Game',
  component: 'forest-game',
},
{
  name: 'Distribution Interlude',
  component: 'distribution-interlude',
  nest: 1
},


];

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {

    storyPoints: storyPoints,
    currentStoryPoint: storyPoints[3],

    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    // storyState: null, // A string like 'hyderabadCertainty' used to jump to a particular point in the story.
  },
  methods: {
    show: show, 
    renderAsPercent: renderAsPercent,

    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,

    // Changes tabs.
    setStoryPoint: function(component_name){
      var story_point = _.filter(storyPoints, {component: component_name});
      if (story_point.length !== 1){
        console.error('must match exactly one story point');
        debugger;
      }
      this.currentStoryPoint = story_point[0];
    },

    // Given 0.8 --> returns {}
    paramsFromCertainty: function(certainty){
      if (certainty == 1.0){
        return {
          numLoseIfWrong: 10000000, 
          numWinIfRight: 1,
          certainty: certainty,
          percent: '100%',
        };
      }
      return {
        numWinIfRight: 1, 
        numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
        certainty: certainty,
        percent: this.renderAsPercent(certainty)
      };      
    },

    paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
      var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
      return this.paramsFromCertainty(certainty);
    },

    storyPointStyle: function(storyPoint){
      if (storyPoint.nest === undefined){
        return {};
      }
      return {
        'margin-left': storyPoint.nest * 8 + 'px',
        'font-size': '12px'
      };
    }
  } // end methods
});


</script>