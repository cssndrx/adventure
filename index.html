<!doctype html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">

<base target="_blank">

<title>Totally Not Scary Guide to Statistics</title>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-59181255-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-59181255-1');
</script>


<link href="https://fonts.googleapis.com/css?family=Itim|Fira+Sans:300,700" rel="stylesheet">

<script src="js/lodash.min.js"></script>
<script src="js/d3.v5.min.js"></script>
<script src="js/vue.min.js"></script>
<script src="js/howler.min.js"></script>

<style>

*{
  font-family: 'Fira Sans', sans-serif;
  font-size: 18px;
  font-weight: 300;
}

.handwriting, .handwriting *{
  font-family: 'Itim';
}

.comment{
  font-family: 'Itim';
  font-size:14px;
  margin-left: 16px;  
}

.chapter-icon{
  max-width:50px; 
  max-height:70px;
  margin: 0 auto;
}

.tree-header{
  width: 80px;
  font-size: 12px;
  display: inline-block;
  text-align: center;
  background-color: black;
  font-weight: bold;
  color: white;
}

h2{
  font-family: 'Itim';
  font-size: 36px;  
  max-width: 600px;
  margin: 0 auto;
  margin-bottom: 16px;
  margin-top: 16px;
}

h4{
  font-family: 'Itim';
  font-size: 18px;  
  margin-top: 16px;  
  margin-bottom: 16px;
}

ul {
  list-style-type: square;
}

li, li * {
  font-size: 16px;
  margin-bottom: 8px;
}

.ev-answer-bar{
  transition: all 1s ease;
}

.hint, .hint *{
  font-size: 16px;
  margin: 8px;
  font-weight: 700;
  color: #777;
}

.bayes-comp{
  display: inline-block;
  position:relative;
  width: 120px;
  height: 300px;
  vertical-align: top;
  text-align: center;
}
.bayes-comp .label *{
  font-size: 14px;
  text-align: center;
}

.dot{
  border-radius: 50%;
  width: 12px;
  height: 12px;
  background-color: blue;
  cursor: ns-resize;
}

text{
  font-size: 10px;
}

div{
  margin-bottom: 16px;
}

.normal-div, .normal-div div{
  margin-bottom: 0px;
}

a{
  color: #337ab7; /* bootstrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}

button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 8px; 
  padding: 8px 16px;
  margin: 8px;
  max-width: 180px;
  display: inline-block;
}

button:hover{
  background-color: #eee;
}

.bold{
  font-weight: 700;
}
.smaller-children, .smaller-children *{
  font-size: 14px;
}

.aside{
  background-color:#777; 
  color:white; 
  padding:8px;
  font-family: 'Itim';
  font-size: 14px;
}


.cropcircle{
    width: 100px;
    height: 100px;
    border-radius: 100%;
    background-size: cover;
    border: 4px solid black;
    margin-right: 16px;
}

.coin{
  display: inline-block;
  width: 120px;
  cursor: pointer;
  vertical-align: top;
  word-wrap: break-word;
}

.no-select, .no-select *{
  -webkit-user-select: none; /* Safari 3.1+ */
  -moz-user-select: none; /* Firefox 2+ */
  -ms-user-select: none; /* IE 10+ */
  user-select: none; /* Standard syntax */
}

.sideways{
  transform: translateX(-50%) translateY(-50%) rotate(-90deg);
  position: absolute;
  top: 50%;
  left: 50%;
}

.toc-chapter{
  display: grid;
  grid-template-columns: 50px auto;
}

.toc-chapter:hover{
  background-color: #ddd;
}

.disabled, .disabled * { 
  pointer-events: none;
  user-select: none; 
}

.disabled .highlight{
  font-weight: bold;
}

svg *{
    font-family: 'Itim';
}
svg .emoji-outcome{
  font-size: 30px;
}

svg .emoji-branch{
  font-size: 16px;
}

svg .outcome{
  font-size: 30px;
}


.shrink .emoji-outcome{
  font-size: 20px;
}


.fulcrum {
  display: inline-block;
  color: white;
  width: 0; 
  height: 0; 
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;  
  border-bottom: 50px solid black;
}

.right-wobble{
  position: absolute;
  animation: rightwobble 1s ease 0s 1;
}
@keyframes rightwobble {
  0% {
    transform: rotate(0turn);
  }
  30% {
    transform: rotate(0.005turn);
  }
  100% {
    transform: rotate(0turn);
  }
}
.left-wobble{
  position: absolute;
  animation: leftwobble 0.5s ease 0s 1;
}
@keyframes leftwobble {
  0% {
    transform: rotate(0turn);
  }
  30% {
    transform: rotate(-0.01turn);
  }
  100% {
    transform: rotate(0turn);
  }
}


/*@media only screen and (max-width: 500px) {

}
*/

.navbar{
  width:60px;
  position: fixed; 
  top:0px; 
  left:0px; 
  width: 100%;
  text-align: center; 
  background-color: #eee;
}

@keyframes pulse {
  from {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }

  50% {
    -webkit-transform: scale3d(1.1, 1, 1);
    transform: scale3d(1.1, 1, 1);
  }

  to {
    -webkit-transform: scale3d(1, 1, 1);
    transform: scale3d(1, 1, 1);
  }
}

.pulse {
    animation: pulse 2.5s ease 0s infinite;
}


</style>
</head>


<body>


<div id="app" @click="mainClick($event)">
    <a style="position:fixed; bottom:2px; right:2px; font-size:10px; color: #aaa; z-index:2" href="//forms.gle/QeUmVfvoxpNJMEcDA">Report bug</a>

  <div ref="toc" class="normal-div navbar" style="text-align: left; position:fixed; z-index: 2; display: grid; grid-auto-flow: column; padding-top:8px; ">

    <div style="display: inline-block; white-space: nowrap; margin-right:8px">
    <img @click="toggleTOC" 
         :src="showTOC ? 'images/x.png' : 'images/menu.png'"
         style="cursor: pointer; height: 28px; margin-left: 8px" >

    <img @click="toggleVolume" 
         :src="hasVolume ? 'images/volume.png' : 'images/volume_off.png'" 
         style="width:20px; padding-bottom: 4px; padding-left: 4px" >
     </div>

   <div class="handwriting" style="white-space: nowrap;display: inline-block; overflow: hidden">Totally Not Scary Guide to Statistics</div>

  </div> 


  <div v-if="showTOC" class="normal-div" style="position:fixed; z-index:1; width:150px;top:40px; left:0px;
    bottom:0;
overflow-y:auto;padding-top:8px; background-color: rgb(247,247,247);">
    <div v-for="(chapter, ind) in chapters"
         @click="showTOC = false; chapterInd = ind"
         class="toc-chapter"
         style="padding:4px">
      <img :src="'images/' + chapter.image" 
           class="chapter-icon">
      <span style="top:60px; font-size:12px; display: inline-block; margin:8px;"><bold style="font-size:12px">{{chapter.title || 'Chapter ' + ind}}</bold><br> {{chapter.description}}</span>
    </div>
  </div>

<!--left:calc(50% - 10px) -->
<keep-alive>
  <component v-bind:is="visibleScreen" :style="componentStyle" style="margin-top: 52px"></component>
</keep-alive>


</div> <!-- end #app -->



<script type="text/x-template" id="intro-to-pvalues-template">
<div>

<h2>Chapter 5: P-Values</h2>

<pset>

<avatar image="scroll.png">
  <div>
    This is a flashback to the recent past in which Elena was still with us...
  </div>
  <next>Next</next>
</avatar>

<avatar 
  text="Elena, my crow friend is really smart.">
  <next>Next</next>
</avatar>


<avatar 
  text="I'm going to get her evaluated by Wei the Scientist to see if her intelligence is statistically significant.">
  <next>Next</next>
</avatar>


<avatar image="scientist.png"
  text="My my, what a pretty little bird.">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw caw!">
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="I can certainly design an intelligence test worthy of this lovely creature.">
  <next>Next</next>
</avatar>

<avatar image="scientist.png">
  <div>
    Although, I guess the default belief is that you're just an average crow.
  </div>
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Cawwww (Don't insult my intelligence, human).">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    Another name for default belief is <bold>null hypothesis</bold>.
  </div>
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png">
  <div>My apologies, clever crow. I'm just trying to explain what a p-value is. A <bold>p-value</bold> is the probability that you'll see as extreme a result if the null hypothesis is true.</div>
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png"
  text="I ran Elena through my first battery of intelligence tests, and got a p-value of 0.6.">

  <div>
    What does a p-value of 0.6 mean?
  </div>

  <buton-group>
    <buton nope>There's a 60% chance that Elena is smarter than the average crow</buton>
    <buton nope>There's a 60% chance that Elena is an average crow</buton>
    <buton yay>There's a 60% chance of observing as extreme a result even if Elena is just an average crow</buton>

    <template v-slot:hint>
    P-values only speak about the probability of obtaining the results if the null hypothesis is true. It isn't the probability of the null hypothesis being correct, or the alternative hypothesis ("Elena is smarter than an average crow") being correct.
    </template>
  </buton-group>

</avatar>

<avatar image="scientist.png">
  <div>
    Correct. A P-value assumes the null hypothesis (aka that Elena is just an average crow) and says how extreme the results are under this assumption.
  </div>
  <next>Next</next>
</avatar>

<avatar  image="scientist.png"
  text="I ran Elena through a different intelligence test and got a p-value of 0.01. What does a p-value of 0.01 mean?">

  <buton-group>
    <buton yay>There's a 1% chance of observing as extreme a result even if Elena is just an average crow</buton>
    <buton nope>There's a 1% chance that Elena is an average crow</buton>
    <buton nope>There's a 1% chance that the results are due to chance</buton>

    <template v-slot:hint>
    P-values only speak about the probability of obtaining the results if the null hypothesis is true. It isn't the probability of the null hypothesis being correct, or the alternative hypothesis being correct.
    </template>
  </buton-group>
</avatar>

<avatar 
  image="scientist.png"
  text="For one of my experiments, what would be a more exciting result? A p-value of 0.01 or 0.001? ">

  <buton-group>
    <buton nope>0.01</buton>
    <buton yay>0.001</buton>

    <template v-slot:hint>
    A p-value of 0.01 would mean that there's a 1% chance that we would observe as extreme a result if the potion didn't work. While that's nice, it would be nicer if there were only a 0.1% chance that the result would occur.
    </template>
  </buton-group>
</avatar>

<avatar image="scientist.png">
  <div>
    Yes! We're hoping that Elena is smarter than an average crow, so a lower p-value is better. 
  </div>
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="Oh interesting...">
  <next>What?</next>
</avatar>

<avatar image="scientist.png"
  key="trap"
  text="Some other scientists have been testing unusual crows as well. One scientist found a crow that tested more intelligent than normal  at a p-value of 0.05. Another scientist found a crow that tested more intelligent than normal at a p-value of 0.1. Which crow do you think is smarter?">

  <buton-group>
    <buton nope>p<0.05 crow</buton>
    <buton nope>p<0.1 crow</buton>
    <buton yay>Not enough info</buton>
  </buton-group>

</avatar>


<avatar image="brain.png">
  <div>
    {{ got('trap') ? "Correct! There's not enough info." : 'Good attempt, but not quite.' }}  
  </div>

   <div>
    The surprising thing about p-values is that they don't say anything about <bold>effect size</bold>. The effect size is the actual difference in the measured quantity. A p-value just tells you how likely something is under the null hypothesis. 
  </div>
  <next>Next</next>
</avatar>


<avatar image="scientist.png">
  <div>
    The two other crows scored as such. Which one do you think is the smarter bird?
  </div>

<div style="margin-bottom:24px;">
<bold>Bird A</bold>
<div>Scores compared to average:
  <div style="font-size:14px">+2% +0% +6% +6% +8% +3% +4% +0% +9% +4% +7% +5% +9% +9% +4% +3% +7% +7% +1% +8% +3% +9% +5%</div>
</div>
<div>Average effect size: 5%</div>
<div>P-value: 0.05</div>
</div>


<div>
<bold>Bird B</bold>
<div>Scores compared to average:
  <div style="font-size:14px">+47% +46% +6% +0% -7% -3% +13% +0% -10% +28% -4% +30% +1% +48% +37% +26% +47% +46% -13% +15% +33% +33% +26% </div>
</div>
<div>Average effect size: 11% </div>
<div>P-value: 0.1</div>
</div>

<once-group>
  <next>Bird A</next>
  <next>Bird B</next>
</once-group>
</avatar>

<avatar image="brain.png" text="It's hard to say, right? It's possible to have a greater average effect size but a less compelling p-value.">
<next>Next</next>
</avatar>

<avatar text="I don't care about these other birds. What is Elena's p-value?">
  <next>Next</next>
</avatar>

<avatar image="scientist.png"
  text="Well, based on the exxperiments I've run so far... Elena's p-value is 0.14.">

  <next>Next</next>
</avatar>

<avatar text="WHAT!">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="CAW!??! (WHAT!??!)">
  <next>Next</next>
</avatar>

<avatar 
  image="scientist.png">

  <div>
    Scienitific journals usually require a p-value of 0.05 or smaller to publish. If a p-value is less than 0.05, it is called <bold>statistically significant</bold>. Experimenting with another battery of tests yielded a p-value of 0.14. Which is...
  </div>

  <buton nope>Statistically significant</buton>
  <buton yay>Not statistically significant</buton>
</avatar>


<avatar text="I DO NOT accept this!!!!">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Cawwww!! (Indeed, what a gross miscalculation!!)">
  <next>Next</next>
</avatar>


<avatar image="scientist.png">
  <div>
    Well "statistically significant" sounds really important, but it's just the scientific name for p-value less than a threshold. It's up to the domain expert to determine if the result is meaningful or not.
  </div>
  <next>Next</next>
</avatar>

<avatar text="I am SO OFFENDED (on Elena's behalf).">
  <next>Next</next>
</avatar>


<avatar 
  image="scientist.png"
  text="How should a p-value of 0.14 be interpreted?">

  <buton nope>Weak evidence that Elena is the same as an average crow</buton>
  <buton yay>Weak evidence that Elena is smarter than an average crow</buton>
  <buton nope>Strong evidence that Elena is the same as an average crow</buton>
  <buton nope>Strong evidence that Elena is smarter than an average crow</buton>

</avatar>

<avatar image="scientist.png">
  <div>
    Correct. Although a p-value of 0.14 does not meet the threshold for "statistical significance", it is still weak evidence that the results may be unusual under the null hypothesis (aka default world view). There was only a 14% chance that we would observe as extreme a result. 
  </div>

  <next>Next</next>
</avatar>

<avatar image="scientist.png">
  <div>
    When you get a borderline p-value like 0.14 it is worth investigating further, perhaps redesigning part of the experiment to better capture signal from the noise. 
  </div>
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw caw caw caw?? (Test me 10 more times!)">
  <next>Er...</next>
</avatar>


<avatar image="scientist.png">
  <div>
    I can't just randomly test you until I get a positive result. That is p-hacking (<a href="//xkcd.com/882/">xkcd: green jelly beans</a>).
  </div>
  <next>Next</next>
</avatar>


<avatar text="Well, I don't need a p-value to tell me that Elena is no average bird.">
  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw... (Sad...)">
  <next>Next</next>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>
  <ul>
    <li>The <bold>null hypothesis</bold> is the default belief (e.g. it's not possible to learn by drinking a potion).</li>
    <li>You learned that a <bold>p-value</bold> is the chance of witnessing as extreme an outcome under the null hypothesis.</li>
    <li>p-values below a threshold of 0.05 are called <bold>statistically significant</bold> but that does not mean it is necessarily useful.</li>
    <li>A smaller p-value does not imply a larger effect size.</li>
  </ul> 

  <buton @click.native="$root.nextChapter()">Next story?</buton>
  <next>Go deeper</next>

</avatar>

<!--<avatar>
  <div>
  In Chapter 1, when I repeatedly got the gross white potion from a presumably fair coin, and started questioning the fairness of the coin.
  </div>

  <div>
  Now we have the tools to go back and answer the question more definitively.
  </div>

  <next>Next</next>

</avatar>

<avatar image="scientist.png">

  <div>
  We could run an experiment where the <bold>null hypothesis</bold> is that the coin is fair. The <bold>test statistic</bold> is the number of times the coin comes up on lunch. We would flip the coin a number of times and compute the p-value for the number of lunches observed. 
  </div>

  <div>
  What is the p-value if the "fair" coin is flipped 10 times and yields 9 potions and 1 lunch?
  </div>

  <input-box right="6/1024"/>

</avatar>


<avatar image="scientist.png">
<div>
  Even if a scientist get a low p-value, it is still good to be uncertain about the results.
</div>

<div>
  A p-value doesn't tell you how well the experiment was designed.
</div>

<div>
  Also, if many experiments are run, then it is expected that some low p-value results were low due to randomness. 
</div>

<next>Next</next>
</avatar> -->


<avatar image="brain.png">
<div>There is a <a href="//en.wikipedia.org/wiki/Replication_crisis">Replication Crisis</a> in science. Only ~60% of public scientific results are replicatable when another group of scientists try to follow the same instructions in the paper.</div>
<next>What causes that?</next>
</avatar>

<avatar>
<div>
Imagine many scientists across the world are running experiments. When a scientist gets a p-value <0.05, they publish a paper about it. If they get a p-value >0.05, they file the paper away or perhaps rerun the experiment.
</div>

<div>
This ends up in the publication of false positives. Due to random chance, the result looked statistically significant at a moment in time. 
</div>

<next>What are we doing about this?</next>
</avatar>


<avatar image="brain.png">

<div>A few things!</div>

<ul>
<li>Forcing you to <a href="https://www.pnas.org/content/115/11/2600">preregister the experiment</a> in order to get funding. This guards against (a) the file drawer effect on negative results and (b) mining the data for insights other than what you intended to find.
</li>
<li><a href="//fivethirtyeight.com/features/how-to-tell-good-studies-from-bad-bet-on-them/">Prediction markets</a> on which studies are reproducible</li> 
<li>Databases logging the success and failure of replication attempts.</li>
</ul>

<buton @click.native="$root.nextChapter()">Next story</buton>

</avatar>


</pset>
</div>
</script>


<script type="text/x-template" id="once-group-template">
<div :class="{disabled: isClicked}"><slot></slot></div>
</script>


<script type="text/x-template" id="intro-scene-template">
<div>  <!-- need extra div so margin:0 auto doesn't override margin-top at component level -->
<div style="max-width:600px; margin: 0 auto; text-align:center;">

  <div class="handwriting" style="font-size:48px;">Totally Not Scary Guide to Statistics</div>

  <img src="images/wizard.png" style="max-width:280px">

  <div style="max-width:500px; margin: 0 auto">
    <div>
      <bold>Statistics is useful ‚Äî </bold> in daily life and machine learning. Approach this topic in a non-scary way... through a friendly wizard, weird stories, and interactivity!
    </div>
  </div>


<!--  <div>Expected playtime: <bold>60 min</bold></div> -->
  <buton class="pulse" @click.native="$root.nextChapter()" :button-style="{'font-size': '28px', 'background-color': 'black', 'color': 'white'}">PLAY</buton>
</div>
</div>
</script>

<script type="text/x-template" id="thanks-template">
<div>
<div style="max-width:400px; margin: 0 auto;" >

<h2>The End</h2>


<p>
  As you can see, life can be quite exciting with more probability and statistics. I hope this guide adds more mischief and color to your life.
</p>

<img src="images/wizard.png" style="max-width:200px">



<p>
That's all the chapters for now, but the story may continue if you click these buttons.
</p>

<a href="//eepurl.com/c8ur5T">
<buton>
  <div>SIGN UP</div>
  <div style="font-size:10px">to be notified of new chapters</div>
</buton>
</a>

<a href="//www.paypal.com/cgi-bin/webscr?cmd=_donations&business=cssndrx%40gmail.com&currency_code=USD&source=url">
<buton>
  <div>SEND MONEY</div>
  <div style="font-size:10px">to me</div>
</buton>
</a>

<!--<buton>
  <div>DECIDE NEW CHAPTERS</div>
  <div style="font-size:10px">with your wallet</div>
</buton>

<buton>
  <div>PLAY</div>
  <div style="font-size:10px">Adventures in Cognitive Biases</div>
</buton>

<ul>
<li>Sign up to be notified of <a href="//eepurl.com/c8ur5T">future chapters</a></li>
<li>Or leave me some <a href="//forms.gle/QeUmVfvoxpNJMEcDA">feedback</a> on story so far</li>
</ul>

-->

</p>


<h4 style="margin-top:32px">If you liked this story, you might also like</h4>

<ul>
<li>My older story about thinking rationally <a href="//cassandraxia.com/cogbiases/">Adventures in Cognitive Biases <img src="images/monk-small.png" style="height:20px; margin-bottom:0px"></a></li>


<li>A comprehensive text covering much more statistics + cool story. <a href="https://www.amazon.com/gp/product/1446210456/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=1446210456&linkCode=as2&tag=cassandraxia-20&linkId=38c49070a217a5b8b289553486d6d721">An Adventure in Statistics: The Reality Enigma</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=cassandraxia-20&l=am2&o=1&a=1446210456" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>

<li>A juicy read on which parts of statistics are used by real statisticians <a href="https://www.amazon.com/gp/product/0321629302/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321629302&linkCode=as2&tag=cassandraxia-20&linkId=8acaf4f7bf04f2ff7ac0341e952c9670">What is a p-value anyway? 34 Stories to Help You Actually Understand Statistics</a><img src="//ir-na.amazon-adsystem.com/e/ir?t=cassandraxia-20&l=am2&o=1&a=0321629302" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /></li>
</ul>




<h4>Music</h4>
<div class="smaller-children">

<p>
Two background pieces were found at <a href="//filmmusic.io">https://filmmusic.io</a>
"Sneaky Snitch" (Title & Chapter 1) and "Comfortable Mystery" (Chapter 2) by Kevin MacLeod (<a href="//incompetech.com">https://incompetech.com</a>)
License: CC BY (http://creativecommons.org/licenses/by/4.0/)
</p>

<p>
The rest came from <a href="//plasterbrain.com">plasterbrain</a> including 'Your Call' (Chapter 3), 'Extreme Hardcore Death Metal Loop' (Chapter 4), 'Comma Flaw' (Chapter 5), and 'Find My Body Please' (Chapter 6). 
</p>


<p>
The sound for this story was graciously edited to be less obtrusive by doctor <a href="//cargocollective.com/lh-hantrakul">Hanoi Hantrakul</a>.
</p>

</div>


<h4>Thanks</h4>

<div class="smaller-children">

<p>
The following people are awesome.
</p>

<p>
The backers and supporters of Timmy's Journey, including <a href="//en.wikipedia.org/wiki/Vivek_Rajkumar">Vivek Rajkumar</a>, <a href="//www.conradho.com/conrad/">Conrad Ho</a>, Brienne and <a href="http://yudkowsky.net/">Eliezer Yudkowsky</a>, Eric Chisholm, Alia McCutcheon and other folks from the LessWrong scene encouraged me to develop Adventures in Cognitive Biases further. <a href="//ruwl.net/">Ruwen Liu</a> contributed a few pieces of good art to this story and I found or drew the less artistic ones.
</p>

<!--wholesome-by-kevin-macleod_edit.wav
comma-flaw_edit.wav
extreme-hardcore-death-metal-loop_edit.wav
find-my-body-please_edit.wav
rusted-maid_edit.wav
sneaky-snitch-by-kevin-macleod_edit.wav
-->


<p>
<a href="//ncase.me/">Nicky Case</a>, the de facto guru in being educational and entertaining gave amazing feedback on how to make things more visual and connected (I'm sorry I wasn't able to implement it all!). Folks from the explorabl.es community provided valuable advice on how to improve the design including, Srini Kadamati, Zachary Steinberg, <a href="//mathigon.org/">Philipp Legner</a>, <a href="//www.redblobgames.com/">Amit Patel</a>, and Philipp Wacker. Mai Akiyoshi who sat me down to talk about marketing.
</p>

<p><a href="//www.spencergreenberg.com/">Spencer Greenberg</a> and <a href="//www.cs.colorado.edu/~mozer/">Mike Mozer</a> resuscitated the project at points through their enthuasism and insightful critique. And thank you to all the folks who emailed in with encouragement and offers to help when earlier projects stagnated. 
</p>

<p>
Anand Babu and Google Kernel friends provided a creative space and the final push of energy to rewrite this. Kourosh Gharachorloo for all the bugs he found, and accidentally the most senior QA tester I've ever had. <a href="//tianyuliu.herokuapp.com/">Tianyu Liu</a> recommended the perfect pieces of prior work. <a href="//twitter.com/nathanmartz?lang=en">Nathan Martz</a> was the game-industry oracle who was right about all the pitfalls. <a href="http://www.chrislengerich.com/">Chris Lengerich</a> was the final, heroic, 9PM-before-launch playtester!
</p>

<p>
All the new friends that I met along the way, including Wei Ho who inspired Chapter 5. Ric Ewing who designed Chapter 2 and taught me how to properly do paper prototypes. Fred Bertsch, Picabo, Meg Gordon, Katie Kormanik, and many Google security guards who helped playtest. 
</p>

<p>
On the tech side, <a href="//vuejs.org/">Vue.js</a> greatly simplified the code needed for this project. I think it's better than React. I also want to thank <a href="//joshcai.com/">jpegslayer</a> who helped me on the friendly Vue forums.
</p>


</div>
</div>
</div>
</script>



<script type="text/x-template" id="next-template">
  <buton @click="next()"><slot></slot></buton>
</script>


<script type="text/x-template" id="ev-tree-template">
<svg height="100" width="90">
   <line x1="0" y1="55" x2="45" y2="20" style="stroke:#ddd;stroke-width:2" />
   <line x1="0" y1="55" x2="45" y2="90" style="stroke:#ddd;stroke-width:2" />

   <text class="outcome" x="50" y="30">{{prettyString(outcomes[0].payoff)}}</text>
   <text class="outcome" x="50" y="100">{{prettyString(outcomes[1].payoff)}}</text>

   <text class="branch" x="10" y="30" >{{$root.formatPct(outcomes[0].certainty)}}</text>
   <text class="emoji-branch" x="28" y="50">{{outcomes[0].emoji}}</text>

   <text class="emoji-branch" x="28" y="74">{{outcomes[1].emoji}}</text>
   <text class="branch" x="10" y="86">{{$root.formatPct(outcomes[1].certainty)}}</text>
</svg>
</script>


<script type="text/x-template" id="tree-node-template">
  <g>
   <line x1="0" :y1="height/2" :x2="lineX"" :y2="linePadding" style="stroke-width:2"
   :style="{stroke: color.indexOf('0') > -1 ? 'black': '#eee'}" />

   <line x1="0" :y1="height/2" :x2="lineX" :y2="height-linePadding" style="stroke-width:2"
   :style="{stroke: color.indexOf('1') > -1 ? 'black': '#eee'}" />

   <text class="emoji-outcome" :x="lineX+emojiPadding" :y="emojiHeight">{{emojis[0]}}</text>
   <text class="emoji-outcome" :x="lineX+emojiPadding" :y="height-10">{{emojis[1]}}</text>
  </g>
</script>

<!-- 

2 day tree
  <tree-node transform="translate(0, 150)"></tree-node>
  <tree-node transform="translate(80,90)"></tree-node>
  <tree-node transform="translate(80,200)"></tree-node>

3 day tree
-->
<script type="text/x-template" id="tree-diagram-template">

<div>
<svg height="150" width="80" style="border: 1px solid red">
  <tree-node :height="150" :width="80"></tree-node>
</svg>


  <svg height="210" width="180">
    <g transform="translate(0,-90)">
      <tree-node color="1" transform="translate(0, 150)"></tree-node>
      <tree-node color="" transform="translate(80,90)"></tree-node>
      <tree-node color="1" transform="translate(80,200)"></tree-node>
    </g>
  </svg>

</div>

</script>


<script type="text/x-template" id="coin-flips-template">
<div>
<h2>Chapter 1: Independent Events</h2>
<pset>


<!--<avatar
  text="Ready to learn statistics?">
  <next>Next</next>
</avatar>
-->

<avatar>
  <div>
    I'm your friendly neighborhood <bold>statistics wizard</bold>. I can teach you about independent events, the chain rule of probability, expected value, p-values, and Bayes Rule.
  </div>

  <div class="smaller-children">
    (It's best to go through the story in order, but you can use <img src="images/menu.png" style="height:18px; position:relative; top:4px"> to jump ahead)
  </div>
  <next>Next</next>
</avatar>


<avatar>
  <div>
    There's a spell that can magically materialize food. Half the time it materializes a delicious lunch box üç±. Half the time it materializes a gross white potion ü•õ. 
  </div>

  <div>
    The results of the spell are <bold>independent</bold>. Independence means that knowing previous results does not give any information about future results. 
  </div>

  <div>
    This works like coin flips in your world. Coins have no memory.
  </div>

  <next>Next</next>
</avatar>


<avatar key="HH"
  text="What is the probability that after I cast the spell twice, I will have two gross potions? ü•õ">

  <div>
  <div>
    <div class="tree-header">Cast 1</div>
    <div class="tree-header">Cast 2</div>
  </div>
  <svg height="210" width="180">
    <g transform="translate(0,-90)">
      <tree-node color="1" transform="translate(0, 150)"></tree-node>
      <tree-node color="" transform="translate(80,90)"></tree-node>
      <tree-node color="1" transform="translate(80,200)"></tree-node>
    </g>
  </svg> <span style="font-size:32px; position:relative:-20px">?</span>
  </div>

  <buton nope="1/2 is the probability of getting a potion with one cast. Getting two potions is rarer, but how much rarer?">1/2</buton>
  <buton yay>1/4</buton>
</avatar>

<avatar image="brain.png">
  <div>
    To calculate the probability that multiple independent events will occur together, you can multiply their individual probabilities.
  </div>
  <div>
    Probability of two potions = 1/2 √ó 1/2.
  </div>
  <next>Next</next>
</avatar> 

<avatar key="HHH"
  text="What is the probability that after three casts, I'll have 3 gross potions?">

  <div>
    <div class="tree-header">Cast 1</div>
    <div class="tree-header">Cast 2</div>
    <div class="tree-header">Cast 3</div>
  </div>

  <div>
  <svg height="420" width="300">

    <g transform="translate(0,-30)">
      <tree-node color="1" transform="translate(0, 150)" :height="200" :width="80"></tree-node>

      <g transform="translate(84, -60)">
        <tree-node color="" transform="translate(0, 150)"></tree-node>
        <tree-node color="" transform="translate(80,90)"></tree-node>
        <tree-node color="" transform="translate(80,200)"></tree-node>
      </g>


      <g transform="translate(84, 150)">
        <tree-node color="1" transform="translate(0, 150)"></tree-node>
        <tree-node color="" transform="translate(80,90)"></tree-node>
        <tree-node color="1" transform="translate(80,200)"></tree-node>
      </g>
    </g>

  </svg>
  </div>

  <buton-group>
    <buton nope>1/2</buton>
    <buton nope>1/3</buton>
    <buton yay>1/8</buton>
  </buton-group>
</avatar>

<avatar key="HHHHH"
  text="If after 5 casts, I have 5 gross potions, am I more likely to get the potion OR a delicious lunchbox on my next cast?">

  <buton-group>
    <buton @click="memory='userSaidPotion'" nope>Gross potion ü•õ</buton>
    <buton @click="memory='userSaidLunch'" nope>Delicious lunch üç±</buton>
    <buton yay>It's 50-50</buton>

    <template v-slot:hint>
      <div v-if="memory == 'userSaidPotion'">
        <div>That's the Gambler's Fallacy... a common misconception that events that haven't occured are more likely to occur.</div>

        <div>Like a coin, this spell has no memory, so just because potions have occured a lot, doesn't mean that potions are more likely.</div>
      </div>

      <div v-if="memory == 'userSaidLunch'">
        <div>That's the Hot Hand Fallacy... a common misconception that events that have occurred recently are "hot" and more likely to come up.</div>

        <div>Like a coin, this spell has no memory, so just because potions have occured a lot, doesn't mean that lunch boxes are more likely now.</div>
      </div>

    </template>
  </buton-group>
</avatar>

<avatar
  text="Yeah! If the spell is truly independent, the odds remain the same regardless of past results.">
  <next>Next</next>
</avatar>


<avatar key="100H"
  text="Okay, but if in my last 100 casts of the spell, I got the gross potion all 100 times, what do you think the next cast would yield?">

  <buton-group>
    <buton yay>Gross potion ü•õ</buton>
    <buton nope>Normal lunch üç±</buton>
    <next nope>It's 50-50</next>
  </buton-group>
</avatar>

<avatar image="brain.png">
<div>
   {{got('100H') ? 'Yeah!': 'Nice try, but not quite.'}} Getting 100 potions in a row on is different from getting 5 potions in a row, because 100 potions in a row is basically impossible. 
 </div>

 <div>The probability is so tiny (1/<exp base="2" pow="100"/>) that it a million times rarer than finding a particular atom by drawing from all <exp base="2" pow="80"/> atoms in the universe. 
 </div>

 <div>
   So if the wizard ever casts the spell and gets 100 potions in a row, we know the spell does not work the way it was described. 
 </div>

   <next>Okay</next>
</avatar>

<avatar>
  <div>
    There is a also set of spells that I can cast to summon an animal familiar. 
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Casting each of the spells in the set is finicky and doesn't always succeed. A cast succeeds 20% of the time ‚ú® and is independent of previous casts. I need 3 successful casts in a row ‚ú®‚ú®‚ú® to summon the animal familiar.
  </div>

  <div>
    What is the probability that I summon a familiar on my first try? 
  </div>

  <input-box :right="1/125">
    <template v-slot:hint>
      <div>
        Try again. This is just like the coin tosses, but the probability of casting successfully is only 20% each time.
      </div>
    </template>
  </input-box>


<!--  <div>
    <div class="tree-header">Cast 1</div>
    <div class="tree-header">Cast 2</div>
    <div class="tree-header">Cast 3</div>
  </div>

  <div>
  <svg height="420" width="300">

    <g transform="translate(0,-30)">
      <tree-node :emojis="['üí•', '‚ú®']" color="1" transform="translate(0, 150)" :height="200" :width="80"></tree-node>

      <g transform="translate(84, -60)">
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(0, 150)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(80,90)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(80,200)"></tree-node>
      </g>


      <g transform="translate(84, 150)">
        <tree-node :emojis="['üí•', '‚ú®']" color="1" transform="translate(0, 150)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(80,90)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="1" transform="translate(80,200)"></tree-node>
      </g>
    </g>

  </svg>
  </div> -->

</avatar>

<avatar>
  <div>
    What is the probability that I'll succeed ‚ú® on my first 2 casts and then fail üí• the third cast? 
  </div>

  <div>
    In other words, what is the probability that I get ‚ú®‚ú®üí•?
  </div>

  <input-box :right=".032">
    <template v-slot:hint>
      <div>
        Not quite. The probability of a cast being successful is 20%. The probability of a cast failing is 80%. 
      </div>
      <div>
        Multiply to get the probability that multiple events occur together.
      </div>
    </template>
  </input-box>


<!--  <div>
    <div class="tree-header">Cast 1</div>
    <div class="tree-header">Cast 2</div>
    <div class="tree-header">Cast 3</div>
  </div>

  <div>
  <svg height="420" width="300">

    <g transform="translate(0,-30)">
      <tree-node :emojis="['üí•', '‚ú®']" color="1" transform="translate(0, 150)" :height="200" :width="80"></tree-node>

      <g transform="translate(84, -60)">
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(0, 150)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(80,90)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(80,200)"></tree-node>
      </g>


      <g transform="translate(84, 150)">
        <tree-node :emojis="['üí•', '‚ú®']" color="1" transform="translate(0, 150)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="" transform="translate(80,90)"></tree-node>
        <tree-node :emojis="['üí•', '‚ú®']" color="0" transform="translate(80,200)"></tree-node>
      </g>
    </g>

  </svg>
  </div> -->
</avatar>

<avatar>
  <div>
    What is the probability that I'll get 2 successful casts ‚ú® and 1 failed cast üí•? (any order)
  </div>

  <div>
    In other words, what is the probabilty that I get any of
  </div>

  <div>
    üí•‚ú®‚ú®<br>
    ‚ú®üí•‚ú®<br>
    ‚ú®‚ú®üí•<br>
  </div>

  <input-box :right=".096">
    <template v-slot:hint>
      <div>
        Try again. This is the same as the previous question of getting ‚ú®‚ú®üí•, except there are 3 different positions for where the failed cast üí• could be located. 
      </div>

      <div>
        So the probability is 3 times more than the previous question. 
      </div>
    </template>
  </input-box>

</avatar>


<avatar>
  <div>
    You want me to try it? Ok, here goes.
  </div>
  <div>
    Hold down to cast until the wizard casts a ‚ú®‚ú®‚ú®. It may take awhile, but it's worth it.
  </div>

  <summoning />
</avatar>


<avatar>
  <div>
    Oh my! Oh my! {{$root.summoningFlips.length > 1 ? 'I finally did it!' : 'I did it on my first shot!'}} I summoned a familiar!!
  </div>

  <next>Next</next>
</avatar>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    I'll name her Elena üíñ
  </div>
  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <ul>
    <li>You met a statistics wizard.</li>
    <li>You learned about <bold>independent events</bold>.</li>
    <li>You learned that there are <exp base="2" pow="80"/> atoms in the universe.</li>
    <li>You learned to calculate the probability of many independent events happening together by multiplying their individual probabilities.</li>
  </ul> 
  <buton @click.native="$root.nextChapter()">Next story</buton>
</avatar>


</pset>
</div>
</script>

<script type="text/x-template" id="wizard-flips-template">
<div>

<h2>Chapter 2: Randomness</h2>
<pset>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>

<avatar text="My crow familiar Elena found some hilarious coins. They say H on one side, and A on the other. Let's play with them! ">
  <next>Next</next>
</avatar>

<avatar 
  text="Of these 3 coins, 2 are fair and 1 is unusual. Let's see if you can find the unusual one.">

  <div class="smaller-children">
    <div>Hold down the coins to flip them. When you have enough info, submit your guess.</div>
  </div>

  <coin></coin>
  <coin></coin>
  <coin :bias="0.7"></coin>

  <div>The unusual coin is:</div>

  <buton-group>
    <buton nope>Coin 1</buton>
    <buton nope>Coin 2</buton>
    <buton yay>Coin 3</buton>

    <template v-slot:hint>
      Hint: One coin has a tendency to land on one side more than the other.
    </template>
  </buton-group>

</avatar>

<avatar >

  <div>
    {{ perfect('3coins') ? 'Oh. You got me. That coin was biased to land on H, 70% of the time.' : "HAAAHHAA! It's pretty hard to find the biased coin, right? And that was when the coin was biased to land on H, 70% of the time!"}} 
  </div>

  <div>
     What is the weakest bias with which you can easily tell that the coin is biased?
  </div>

  <div>
    On weakly biased coins, how many flips do you need to see that it's unfair?
  </div>

  <biased-coin-machine></biased-coin-machine>
  <next>Done with this</next> 

</avatar>

<avatar 
  text="HAHA this is fun. I again have 3 coins. 2 are fair, 1 is unusual. Find the unusual coin.">


  <div class="smaller-children">
    <div>Hold down the coins to flip them. When you have enough info, submit your guess.</div>
  </div>

  <coin></coin>
  <coin pattern="haha"></coin>
  <coin></coin>

  <div>The unusual coin is:</div>

  <buton-group>
    <buton nope>Coin 1</buton>
    <buton yay>Coin 2</buton>
    <buton nope>Coin 3</buton>

    <template v-slot:hint>
      Hint: Look at the pattern of coin flips. The wizard may be having a joke at your expense.
    </template>
  </buton-group>
</avatar>


<avatar 
  text="Good find (or lucky guess)! That coin always says HAHA. It lands on heads 50% of the time, but it's unusual because I know what's coming next. Genius, isn't it??">

  <next>Next</next>
</avatar>


<avatar 
  text="OKOK last one. Find the unusual coin.">

  <div class="smaller-children">
    <div>Hold down the coins to flip them. When you have enough info, submit your guess.</div>
  </div>

  <coin></coin>
  <coin pattern="human"></coin>
  <coin></coin>

  <div>The unusual coin is:</div>

  <buton-group>
    <buton nope>Coin 1</buton>
    <buton yay>Coin 2</buton>
    <buton nope>Coin 3</buton>

    <template v-slot:hint>
      Hint: Look at the streaks within the pattern of coin flips.
    </template>
  </buton-group>
</avatar>


<avatar 
  text="Yes, Coin 2 never has long streaks of one thing or the other. Humans tend to generate 'random' sequences like this. But they aren't random, because nature doesn't mind having long streaks.">

  <next>Next</next>
</avatar>


<avatar 
  text="HAHAHA. Aren't these coins great? Isn't Elena the Crow great? ">
  <next>Yes</next>
</avatar>

<avatar text="Elena is my only friend actually.">
  <next>Oh</next>
</avatar>

<avatar image="crow.png"
  text="Caw!">
  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
    Well, at least you learned
  </div>
  <ul>
    <li>What real randomness feels like</li>
  </ul> 

  <buton @click.native="$root.nextChapter()">Next story</buton>
</avatar>

</pset>
</div>
</script>


<script type="text/x-template" id="bayes-rule-template">
<div>

<h2>Chapter 6: Bayes Rule</h2>  

<pset>

<avatar text="Elena??? Where's Elena??">
  <next>NEXT</next>
</avatar>

<avatar text="Oh noooo my one and only friend!">
  <next>NEXT?!?!!</next>
</avatar>

<avatar image="brain.png"
        text="Calm down calm down CALM DOWN.">
  <next>Breathe</next>
</avatar>

<avatar text="Wait... does this have to do with Chapter 5??">
  <next>Next</next>
</avatar>

<avatar text="Do you think Elena was offended by her p-value?">
  <next>Possibly</next>
</avatar>


<avatar text="But Elena is a very clever self sufficient crow. Chances are that she's okay.">
  <next>Next</next>
</avatar>


<avatar text="But then again, I've never seen Elena so ruffled before.">
  <next>Next</next>  
</avatar>

<avatar text="There's too much conflicting info!! Is Elena okay or not??">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    To reconcile the two pieces of information into a single belief use <bold>Bayes Rule</bold>.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    I thought Bayes Rule was just the relationship between conditional probabilities?
  </div>
  <div class="handwriting">
  P(A|B) = <big-frac style="position:relative; top:12px" num="P(B|A) √ó P(A)" den="P(B)" />
  </div>
  <next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
    Yes, but if you plug in meaningful values, then Bayes Rule becomes a general relationship of how to change what you think (<bold>hypothesis</bold>) in response to new <bold>evidence</bold>.
  </div>

  <div style="margin-bottom:28px;" class="smaller-children handwriting">
  P(Hypothesis|Evidence) = <big-frac style="position:relative; top:12px" num="P(Evidence|Hypothesis) √ó P(Hypothesis)" den="P(Evidence)" />
  </div>

  <div>This is the basis for Bayesian reasoning and Bayesian machine learning.</div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">

  <div>
  Another useful form is the <bold>odds ratio form of Bayes Rule</bold>.
  </div>

  <div>This occurs when seeing which is more likely of two competing hypotheses (i.e. is Elena OK, or is she not OK).
  </div>

  <div>This involves calculating the ratio  <span class="handwriting">P(Hypothesis=OK|Evidence) : P(Hypothesis=Not OK|Evidence)</span> and yields a comparison of the Bayes Formula numerators. The denominator cancels out.</div>

  <div style="margin-bottom:28px;" class="smaller-children handwriting">
  <big-frac style="position:relative; top:12px" num="P(H=OK|Evidence)" den="P(H=Not OK|Evidence)" /> = <big-frac style="position:relative; top:12px" num="P(Evidence|H=OK) √ó P(H=OK)" den="P(Evidence|H=Not OK) √ó P(H=Not OK)" />
  </div> 

  <next>Next</next>

</avatar>

<avatar image="brain.png">
  <div>The three remaining ratios have names, and intuitive meanings: <bold>prior belief</bold> (what you thought before), <bold>likelihood ratio</bold> (likelihood of evidence under each hypothesis), and <bold>posterior belief</bold> (what you thought after).</div>


  <img src="images/bayes-colored.png" style="max-width:100%">

  <next>Next</next>
</avatar>

<avatar>
  <div>What is my <bold>prior belief</bold> on Elena being okay? What is
  </div>

  <div class="handwriting">
    <big-frac num="P(H=OK)" den="P(H=Not OK)" /> 
  </div>

  <div>before I found out that she was ruffled?</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Elena is a very self-sufficient bird, so 80% of the times she's disappeared on me, she has been okay.
  </div>

  <div>Input your prior belief that Elena is okay. 
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [1, 1], correct: [4, 1], isActive: true, isControllable:true}}">
  </triple-bayes>

</avatar>

<avatar image="brain.png">
  <div>
    Now you need to take into account the evidence that Elena was last seen visibly ruffled. 
  </div>
  <div>
    To incorporate this evidence, Bayes Rule says to look at the likelihood of the evidence under each hypothesis P(Evidence|Hypothesis). 
  </div>

  <div>
    We need to compute the ratio of
  </div>

  <div>
    <span class="handwriting">P(Ruffled|OK)</span> vs <span class="handwriting">P(Ruffled|Not OK)</span>.
  </div>

  <div>
    This is called the <bold>likelihood ratio of the evidence</bold>.
  </div>
  <next>Next</next>
</avatar>


<avatar>
  <div>
    Out of 100 OK birds, I imagine 10 of them might be ruffled.
    Out of 100 Not OK Birds, probably 80 are ruffled.
  </div>

  <div>
    Input the likelihood ratio of the evidence.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [4, 1]}, likelihood: {dist: [1, 1], correct: [1, 8], isActive: true, isControllable: true}}">
  </triple-bayes>

</avatar>

<avatar 
  text="Bayes Rule says our belief after seeing the evidence is our prior belief multiplied by the likelihood ratio.">

  <div>
    The belief after we have considered the evidence is called the <bold>posterior belief</bold>.
  </div>

  <triple-bayes 
    :hypotheses="['OK', 'Not OK']" 
    :config="{prior: {dist: [4, 1]}, likelihood: {dist: [1, 8]}, posterior: {isActive: true}}">
  </triple-bayes>

  <div>
    Looking at the posterior belief, what is the probability that Elena is OK?
  </div>
  <buton yay>33%</buton>
  <buton nope>40%</buton>
  <buton nope>80%</buton>
</avatar>

<avatar text="That's not great odds.">
  <next>Oh no</next>
</avatar>


<avatar text="The other thing is she didn't leave a note.">
  <div>
  50 out of 100 OK people don't leave a note when they are ruffled.<br>
  90 out of 100 Not OK people don't leave a note when they are ruffled.
  </div>

  <div>
  Use this information to create a likelihood ratio.<br>
  </div>

  <triple-bayes 
    :hypotheses="['Ok', 'Not OK']" 
    :config="{prior: {dist: [4, 8]}, likelihood: {dist: [1, 1], correct: [5, 9], isActive: true, isControllable: true}, posterior: {isActive:true}}">
  </triple-bayes>
</avatar>

<avatar text="Oh no!!! Only a 22% chance she's okay??">
  <next>Next</next>
</avatar>

<avatar text="Wait I hear a cacophony of crows!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    What's the probability that I'd hear a cacophony of crows under each hypothesis?
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png"
  text="Get out of your head and follow the noise!">
  <next>Next</next>
</avatar>

<avatar text="ELENA!!!">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="CAWW (HELP)">
  <next>Next</next>
</avatar>

<avatar text="There you are Elena!">
  <next>Next</next>
</avatar>

<avatar text="Was I right to infer that there was a 78% chance you were in trouble?">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="CAWW CAWW (HELP HELP)">
  <next>Chase off the kidnappers</next>
</avatar>

<avatar text="Thank you for helping me find Elena.">
  <next>Next</next>
</avatar>

<avatar text="Elena, I hope that p-value nonsense didn't cause you to run away.">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="...">
  <next>Next</next>
</avatar>

<avatar text="Not only are you the cleverest crow I know, you're my best friend.">
  <next>Next</next>
</avatar>

<avatar image="crow.png" text="c... aw...">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  While this is all touching, let's take another look at Bayes Rule that saved the day.
  </div>
  <next>Next</next>
</avatar>

<avatar image="brain.png"
      text="This is the Taxi-cab problem by psychologists Kahneman & Tversky.">

  <div style="max-width: 350px; margin:0 auto; margin-bottom: 16px; line-height:1.4em; text-align: justify" class="smaller-children">
  30% of the cabs in the city are Blue and 70% are Green.
  A cab was involved in a hit and run, and the witness identified the cab as Blue. 
  The court tested the reliability of the witness under the circumstances that existed on the night of the accident, and concluded that the witness correctly identified each one of the two colors 80% of the time and failed 20% of the time.
  What is the probability that the cab involved in the accident was Blue?
  </div>

  <div>
    Use the widget to solve the problem.
  </div>

  <triple-bayes 
    :hypotheses="['B guilty', 'G guilty']" 
    :config="{prior: {dist: [1, 1], correct: [3, 7], isActive: true, isControllable: true}, likelihood: {dist: [1, 1], correct:[4, 1], isActive:true, isControllable: true}, posterior: {isActive: true}}">

    <template v-slot:yay>
      <buton @click="set('bayes-rule')">Next</buton>
    </template>

    <template v-slot:hint>

      <div>
      <div><bold>Prior</bold></div>
      Ignoring the eye witness evidence, and just considering the base rate of cabs in the city gets the prior.
      </div>

      <div>
      <div><bold>Likelihood Ratio</bold></div>
      The likelihood ratio of the data P(E|H) given that the eyewitness saw a blue cab consists of
      </div>
      <big-frac>
        <template v-slot:num>
          P(Saw blue|Blue guilty)
          </template>
          <template v-slot:den>
          P(Saw blue|Green guilty)
        </template>
      </big-frac>
    </template>
  </triple-bayes>

</avatar>


<avatar>
  <div>
    <div>
      So even though there is pretty accurate eyewitness testimony pointing to Blue cabs, given the low base rate of Blue cabs, it's still pretty uncertain which cab company was at fault.
    </div>
    <next>Next</next>
  </div>
</avatar>

<avatar image="brain.png">

  <div>
    Congrats, you solved a problem that so few people get correct that it inspired the naming of two cognitive biases: Base Rate Neglect (not using prior) and Bayesian Conservatism (not using likelihood ratio).
  </div>

  <div>
    If you want to learn more, you may want to read <a href="//hpmor.com">Harry Potter and the Methods of Rationality</a> or play <a href="//cassandraxia.com/cogbiases/">Adventures in Cognitive Biases</a>.
  </div>

  <next>Next</next>
</avatar>



<avatar text="Hey... are you my friend? ">
  <next>Next</next>
</avatar>

<avatar text="I feel like we've hit the three tenets of friendship from Chapter 4.">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    We have consistency ‚Äî you've hung out with me for {{$root.elapsedMinutes}} minutes and {{$root.elapsedSeconds}} seconds.
  </div>
  <next>Next</next>
</avatar> 

<avatar text="And positivity ‚Äî you look like you're having fun.">
  <next>Next</next>
</avatar>

<avatar text="And vulnerability ‚Äî you saw my struggle to make friends.">
  <next>Next</next>
</avatar>

<avatar>
  <p>
    Wait, I don't know anything vulnerable about you.
  </p>

  <iframe src="https://docs.google.com/forms/d/e/1FAIpQLSfD8mzdkhL4XiSSg-Z2hCtRxvsxjvanklWZrODVEmbtW4LV5Q/viewform?embedded=true" width="400" height="471" frameborder="0" marginheight="0" marginwidth="0">Loading‚Ä¶</iframe>

  <next>Next</next>
</avatar>

<avatar>
  <div>
  So... I guess we're friends now? 
  </div>

  <once-group>
    <next>Yes</next><next>Possibly</next>
  </once-group>
</avatar>

<avatar>
  <div>
  And you see probability and statistics in real life now? 
  </div>

  <once-group>
    <next>Yes</next><next>Possibly</next>
  </once-group>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>

  <ul>
    <li>How to update beliefs with <bold>Bayes Rule</bold> is the average reward.</li>
    <li><bold>Posterior belief</bold> is proportional to <bold>prior belief</bold> √ó <bold>likelihood of evidence</bold></li>
    <li>To breathe when panicking.</li>
    <li>That you have a new friend.</li>
  </ul> 

  <div class="smaller-children">
    You solved the problems in this chapter using the odds ratio form of Bayes Rule. You can also solve it using the <a href="//pure.mpg.de/rest/items/item_2102205/component/file_2102204/content">Gigerenzer frequency grid technique</a> (h/t Nicky Case). Try out the sepsis problem from Gigerenzer's paper.
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    By the way, Bayes Rule is easy to derive, if you ever forget it.
  </div>

  <div>
    P(A AND B) = P(A|B) √ó P(B)  <span class="comment"># From Chapter 3</span>
  </div>

  <div>
    P(A|B) = <big-frac num="P(A AND B)" den="P(B)"/>  <span class="comment"># Rearrange the terms</span>
  </div>

  <div>
    P(A|B) = <big-frac num="P(B|A) √ó P(A)" den="P(B)" />  <span class="comment"># Expand P(A AND B) again</span>
  </div>


  <div>
    P(A|B) = <big-frac style="position:relative; top:12px" num="P(B|A) √ó P(A)" den="P(B)" /> <span class="comment"># Tada! It's Bayes Rule</span>
  </div> 

  <div>
    <buton @click.native="$root.nextChapter()" :scroll="false">The End?</buton>
  </div>
</avatar>



</pset>
</div>
</script>

<script type="text/x-template" id="the-end">
<div>
</div>
</script>

<script type="text/x-template" id="pset-template">
  <div class="pset">
    <slot></slot>
  </div>
</script>

<script type="text/x-template" id="coin-template">
  <div @mousedown="isMouseDown = true" 
       @mouseup="isMouseDown = false" 

       @touchstart="isMouseDown = true"
       @touchend="isMouseDown = false"

       @contextmenu="isMouseDown = false"
       class="coin normal-div no-select" style="position:relative">
    <img v-if="isShowingH" src="images/coin_heads.png" style="width:100px">
    <img v-if="!isShowingH" src="images/coin_tails.png" style="width:100px">
    <div ref="flip-string" style="font-size:13px; margin-left:8px; margin-right:8px" :style="flipStringStyle">{{flipString ? flipString.length + ' flips ' : ''}} {{flipString}}</div>
    <samples-chart v-if="flips.length > 0" :xdomain="xDomain" :dist="dist" :style="chartStyle"></samples-chart>
  </div>
</script>

<script type="text/x-template" id="summoning-template">
  <div>


    <div>
    <buton @mousedown.native="isMouseDown = true" 
       @mouseup.native="isMouseDown = false" 

       @touchstart.native="isMouseDown = true"
       @touchend.native="isMouseDown = false"

       @contextmenu.native="isMouseDown = false">Summon familiar</buton>
     </div>

    <span v-for="flip in $root.summoningFlips" style="margin-right:8px">
      {{flip}}
    </span>

  </div>
</script>


<script type="text/x-template" id="biased-coin-machine-template">
<div>

  <div class="smaller-children">Adjust the bias, and click (or hold down) on the coin to flip.</div>

  <div>
    <span class="smaller-children">Lands H with <bold>{{$root.formatPct(bias)}}</bold> chance:</span>
    <input v-model="slider" type="range" min="0" max="100" style="width:200px; display:inline">
  </div>


  <div>
  <coin ref="coin" :bias="bias" style="width:120px" :sideBySide="true"></coin>
  </div>
</div>
</script>


<script type="text/x-template" id="chain-rule-template">
<div>

  <h2>Chapter 3: Chain Rule of Probability</h2>
<pset>

<!--<div class="normal-div" style="display:table-cell; vertical-align:bottom; border:1px solid red">
    <div style="width:40px; height:60px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:64px; position:absolute; top:-70px;left:-12px">üßô‚Äç‚ôÇÔ∏è</div>
    </div>
    <div style="width:40px; height:20px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:64px; position:absolute; top:-70px;left:-12px">üßô‚Äç‚ôÇÔ∏è</div>
    </div>
    <div style="width:40px; height:60px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:48px; position:absolute; top:-50px;left:-4px">üë±</div>
    </div>
    <div style="width:40px; height:20px; background-color:#000; display:inline-block; position:relative">
      <div style="font-size:48px; position:absolute; top:-50px;left:-4px">üë±</div>
    </div>
</div>-->

<avatar text="I like someone but she doesn't like me back.">
  <next>Next</next>
</avatar>

<avatar 
  image="girl.png" 
  text="I'm Veronica and I only date characters that are tall and have beards.">

  <next>Next</next>
</avatar>


<avatar 
  text="So I cast a spell to cause many characters to be unable to grow beards...">
  <next>Oh</next>
</avatar>


<avatar image="girl.png"
  text="Is that why it's so hard to find someone I like?">
  <next>Next</next>
</avatar>

<avatar image="girl_happy.png"
  text="Naw, I don't think that's it. I'm just waiting for my Mister Right.">
  <next>Next</next>
</avatar>


<avatar 
  image="girl.png" 
  text="1/2 of all characters are tall and 1/4 of characters have beards.">
  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    Let's write what Veronica told us in math language.
  </div>

  <div>
    The probability of a character having a beard can be written as   <span class="handwriting">P(beard) = 1/4</span>
  </div>


  <div class="aside">
    This is pronounced "the probability of a beard is 1/4".
  </div>

  <div>
    Veronica also told us <span class="handwriting">P(tall) = 1/2</span>
  </div>

  <next>Next</next>
</avatar>
<avatar key="fakeout1"
  image="girl.png">

  <div>
    What is the probability that a random character is datable? i.e. What is <span class="handwriting">P(tall AND beard)</span>? 
  </div>

  <div>
    This probability is called the <bold>joint probability</bold> because it is the probability that tall and beard jointly occur. It's a mathy way of saying <span class="handwriting">"and"</span>.
  </div>

  <buton-group>
    <next>1/8</next>
    <buton nope="Hm... 1/3 doesn't make sense. Try again.">1/3</buton>
    <buton nope="Although 1/4 is the number of characters that have a beard, it's not clear that all bearded characters are tall. Try again.">1/4</buton>
    <buton nope="There aren't even that many tall characters! Try again.">3/4</buton>
    <buton yay>Not enough info</buton>
  </buton-group>
</avatar>


<avatar image="brain.png">

  <div>
    {{got('fakeout1') ? "Right! It's not possible to say." : "Nice try, but there's a catch." }}
  </div>

  <div>
    In Chapter 1, we calculated the joint probability of <span class="handwriting">P(X and Y)</span> by multiplying  <span class="handwriting">P(X)</span> and  <span class="handwriting">P(Y)</span>. But this is only valid when X and Y are <bold>independent</bold>.
  </div>

  <div>
     Independence means that knowing X <bold>does not provide any information</bold> on Y ‚Äî like the spell casts in Chapter 1. 
  </div>

  <div>
     However, if knowing that a character is tall or short, makes it more or less likely that the character has a beard... then height and beardedness are dependent. 
  </div>

  <next>Next</next>
</avatar>


<avatar image="girl.png" 
        text="I guess I do see some correlation between being tall and having a beard, so they're not independent. If a character is tall, there's a 1/3 chance that they have a beard.">
  <next>Next</next>
</avatar>



<avatar image="brain.png">

  <div>
    Veronica told us a <bold>conditional probability</bold> when she said:
  </div>

  <div class="handwriting">
   If a character is tall, there's a 1/3 chance that they have a beard.
  </div>

  <div>
    Conditional probabilities are written like <span class="handwriting">P(X|Y)</span>. The bar "|" is  pronounced as <span class="handwriting">"given"</span>, and <span class="handwriting">P(X|Y)</span> indicates the probability of X given that we know Y to be true.
  </div>


  <div>
    Veronica told us <span class="handwriting">P(beard|tall) = 1/3</span>.
  </div>


  <div class="aside">
   This is pronounced "the probability a character has a beard <bold>given</bold> that we know the character is tall is 1/3". 
  </div>


  <next>Next</next>
</avatar>


<avatar  image="brain.png">

  <div>
    We can use the conditional probability to calculate P(tall AND beard) without assuming independence:
  </div>

  <div class="handwriting">
    P(tall AND beard) = <span style="color:#a6d854">P(tall)</span> √ó <span style="color:#ffd92f">P(beard|tall)</span>
  </div>

  <div>
    The formula just says
  </div>

  <div class="handwriting smaller-children">probability of finding a tall character with a beard = <span style="color:#a6d854">probability of finding a tall character</span> √ó <span style="color:#ffd92f">probability that a tall character would have a beard</span>
  </div>

  <next>Try it</next>
</avatar>


<avatar key="tall-hair" 
        image="girl.png" 
        text="Okay, so what is the probability that a random character is datable?">

  <div>What is <span class="handwriting">P(tall AND beard)</span>?</div>

  <div class="extra-info">Facts from before:
  <ul class="handwriting">
    <li class="highlight">P(tall) = 1/2</li>
    <li class="unused">P(beard) = 1/4</li>
    <li class="highlight">P(beard|tall) = 1/3</li>
  </ul>
  </div>

  <buton-group>
    <buton yay>1/6</buton>
    <buton nope="We said that being tall and having a beard are not independent, so we can't just multiply 1/2 √ó 1/4.">1/8</buton>
    <buton nope="Are you just multiplying things together? Try again.">1/24</buton>
    <buton nope="The answer isn't always 'Not enough info'...">Not enough info</buton>
  </buton-group>
</avatar>


<avatar image="girl_happy.png" text="Thank you for your help so far. But I forgot... ">
  <next>Yes?</next>
</avatar>


<avatar key="fakeout2"
        image="girl.png"
        text="I also want my character to have tattoos. 1/5 of characters have tattoos.">

  <div>In math speak, <span class="handwriting">P(tattoos) = 1/5.</span></div>
  <div>What is <span class="handwriting">P(tall, beard, tattoos)?</span></div>

  <div class="aside">
    Using commas like in P(tall, beard, tattoos) is a more compact way of writing the joint probability P(tall AND beard AND tattoos).
  </div>

  <div class="extra-info">Facts from before:
    <ul class="handwriting">
      <li>P(tall) = 1/2</li>
      <li>P(beard) = 1/4</li>
      <li>P(beard|tall) = 1/3</li>
      <li>You calculated P(beard, tall) = 1/6</li>
    </ul>
  </div>

  <buton-group>
    <next>1/30</next>
    <buton nope="Remember, we want to use P(beard|tall), not P(tall).">1/40</buton>
    <buton nope="Wait, are you just blindly multiplying numbers? Stop that.">1/120</buton>
    <buton yay>Not enough info</buton>
  </buton-group>
</avatar>


<avatar 
    image="brain.png">

  <div>
    {{ got('fakeout2') ? 'Right.': 'Not quite.' }} Again, it's not possible to say!
  </div>

  <div>
    To get <span class="handwriting">P(tattoo, beard, tall)</span> we can't just multiply
    <span class="handwriting">P(tattoo) √ó P(beard, tall)</span> without assuming independence.
  </div>

  <div>
    We need another conditional probability.
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    And this brings us to the <bold>Chain Rule of Probability</bold>.
  </div>

  <div class="smaller-children handwriting">
    P(tattoo, beard, tall) = <br>
    <span style="color:#a6d854">P(tall)</span> √ó <span style="color:#ffd92f">P(beard | tall)</span> √ó <span style="color:#e78ac3">P(tattoo | beard AND tall)</span>
  </div>

  <div class="smaller-children" style="margin-left: 16px;">
    <div>
      First, consider the <span class="handwriting" style="color:#a6d854">probability of the character being tall</span>.
    </div>

    <div>
      Then, consider the <span class="handwriting" style="color:#ffd92f">probability of a tall character having a beard</span>.
    </div>

    <div>
      Then, consider the <span class="handwriting" style="color:#e78ac3">probability that a tall character with a beard, would have a tattoo</span>.
    </div>

    <div>
      Multiply together to get characters that are tall and have a beard and have tattoos.
    </div>
  </div>

  <div>
    Basically, the Chain Rule says that when bringing a new item to the joint probability, condition on all the events that already exist.
  </div>

  <next>Try it</next>
</avatar>


<avatar key="problem3" 
        image="girl.png" 
        text="Ooh yes, I've heard of the Chain Rule. Here are the numbers that you'll need.">

  <div>
  What is P(tall, beard, tattoos)?
  </div>

  <div class="extra-info">
  Facts from before:
  <ul class="handwriting">
    <li>P(tall) = 1/2</li>
    <li class="unused">P(beard) = 1/4</li>
    <li>P(beard|tall) = 1/3</li>
    <li class="highlight">You calculated P(beard AND tall) = 1/6</li>
    <li class="unused">P(tattoos) = 1/5</li>
    <li class="unused">P(tattoos|tall) = 1/6</li>
    <li class="highlight">P(tattoos|tall AND beard) = 1/7</li>
  </ul>
  </div>

  <div>
  <span class="handwriting">P(tall, beard, tattoos) = 1/</span><input-box right="42">
    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So P(tall, beard, tattoos) = P(tall) √ó P(beard | tall) √ó P(tattoos | beard AND tall). 
      </div>
    </template>
  </input-box>
  </div>

</avatar>

<avatar key="problem4" 
        image="girl.png" 
        text="Yes, thank you! But silly us! We forgot to include that these tall, bearded, tattooed characters also need to be... around my age and single.">

    <div class="extra-info">
    Facts from before:
    <ul class="handwriting">
      <li class="unused">P(tall) = 1/2</li>
      <li class="unused">P(beard) = 1/4</li>
      <li class="unused">P(beard|tall) = 1/3</li>
      <li class="unused">You calculated P(beard AND tall) = 1/6</li>
      <li class="unused">P(tattoos) = 1/5</li>
      <li class="unused">P(tattoos|tall) = 1/6</li>
      <li class="unused">P(tattoos|tall AND beard) = 1/7</li>
      <li class="highlight">You calculated P(beard, tall, tattoos) = 1/42</li>
      <li class="highlight">P(around her age | tall, beard, tattoos) = 1/5</li>
      <li class="highlight">P(single | tall, beard, tattoos, around her age) = 1/2</li>
    </ul>
    </div>


    <template v-slot:hint>
      <div>
        Recall the Chain Rule says that everything must be conditioned on what came before. 
      </div>
      <div>
        So in the case of four events, <span class="handwriting">P(tall, beard, tattoos, single) = P(tall) √ó P(beard | tall) √ó P(tattoos | beard AND tall) √ó P(beard AND tall AND tattoos | single)</span>. 
      </div>
      <div>
        What is it for five events?
      </div>
    </template>

    <div class="handwriting">
    P(tall, beard, tattoos, around her age, single) =
    </div>

    1/<input-box right="420"/>
</avatar>


<avatar image="girl_shock.png"
        text="That's not very many people!">
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Even though each individual criterion may not seem picky, requiring that a character have all the traits leaves Veronica with a very small dating pool. Ha-ha!
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>But hey, at least Veronica's pickiness taught you the Chain Rule.</div>

  <next>Next</next>
</avatar>

<avatar 
    image="brain.png"
    key="decompose" >

  <div>
    We had been decomposing:
  </div>

  <div class="handwriting">
    P(tall, beard, tattoos) = P(tall) √ó P(beard|tall) √ó P(tattoos | tall AND beard).
  </div>

  <div>
    But notice... that we can also decompose it as:
  </div>

  <div class="handwriting">
    P(tall AND beard and tattoos) = P(beard) √ó P(tattoos | beard) √ó P(tall | tattoos AND beard).
  </div>

  <div>
    We can decompose it in any order we choose to, depending on what information we have on hand.
  </div>

  <div>
    How many different ways are there to decompose <span class="handwriting">P(tall, beard, tattoos)</span> using the Chain Rule?
  </div>
  <input-box right="6" :feedback="true"/>
</avatar>


<!-- <avatar image="brain.png">
<div>
  If this process of calculating the joint probability feel similar to Chapter 1, it's because it is! Chapter 1 is just a special case where 
P(X|what happened before) = P(X).
</div>

  <div>
  In fact, that's exactly the definition of independence ‚Äî what happens is not dependent on what happened before.
  </div>

  <next>Next</next>
</avatar>
-->


<avatar image="wizard.png"
        text="Aw, you foiled my plan by showing Veronica how picky she was. But....">
  <ul>
    <li>You learned to calculate the joint probability of multiple events occurring together (without assuming independence) by using the Chain Rule.</li>
    <li>You learned to not be too picky ‚ù§Ô∏è.</li>
  </ul> 

  <next>Next</next>
</avatar>


<avatar text="Hey, do you think I'll find love one day?">
  <next>Yes</next>  <next>No</next>

</avatar>

<avatar text="What about a friend?">
  <next>Sure</next>
  <next>Of course</next>
</avatar>

<avatar text="Uh... it might be harder than you think...">
  <buton @click.native="$root.nextChapter()">Next story</buton>
</avatar>

</pset>
</div>
</script>

<script type="text/x-template" id="ev-story-template">
<div>
<h2>Chapter 4: Expected Value</h2>
<pset ref="pset">

<!--  <fulcrum>
    <template v-slot:left>Yooooooo</template>
    <template v-slot:right>Yooooooo</template>
  </fulcrum> -->

<avatar text="How can I make friends?">
  <next>Next</next>
</avatar>

<avatar image="brain.png">

<div>The <a href="//www.youtube.com/watch?v=hmJyWreER7A">internet</a> claims that the 3 tenets of friendships are...</div>

<ul>
  <li>positivity</li>
  <li>consistency</li>
  <li>vulnerability</li>
</ul>
<next>Thanks internet</next>
</avatar>

<avatar>
  <div>To become friends, make interactions positive. That makes sense.</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    I'm a pretty good joke teller. I'll memorize some jokes from the <a href="//www.rd.com/funny-stuff/short-jokes/">internet</a> and make people laugh.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    But jokes don't always hit. A bad joke might lead to an awkward silence. 
  </div>
  <next @click.native="$root.play('crickets')">Crickets ü¶óü¶óü¶ó</next>
</avatar>

<avatar text="Take this joke for instance... should I tell it?">
  <div>
  40% of the time it lands üòÇüòÇüòÇüòÇ
  </div>

  <div>
  60% of the time it fails ü¶óü¶óü¶óü¶óü¶óü¶ó
  </div>

  <next>Yes</next>  <next>No</next>
</avatar>

<avatar image="brain.png"
        text="The answer actually depends on the payoffs. If ">
  <div>
    üòÇ = +1 positivity point<br>
    ü¶ó = -1 positivity point<br>
  </div>

  <div>
    Then it seems like a bad deal, because on average the wizard loses -0.2 positivity points each time I tell the joke. 
  </div>

  <div>
    This average is called the <bold>expected value</bold>.
  </div>

  <next>Next</next>
</avatar>


<avatar>
  <div>
    I feel like the payoff looks like this. If the joke lands, I'll gain 5 points because there's nowhere to go but up for my reputation. Ha-ha!
  </div>

  <div>
    üòÇ = +5 positivity points<br>
    ü¶ó = -1 positivity point<br>
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
    To calculate the expected value, calculate the <bold>average outcome</bold>. For each possible outcome, multiply the probability of that outcome with the reward of that outcome, and add it all together. 
  </div>

  <div>The expected value of the joke in question is?</div>

  <div>
    <ev-tree></ev-tree>
  </div>

  <input-box right="1.4"/>
</avatar>


<avatar>
  <div>So, I should tell the joke?</div>
  <buton-group>
    <buton yay>Yes</buton>
    <buton nope>No</buton>

    <template v-slot:hint>
      The wizard should tell the joke because it has positive expected value, given that there aren't options that are higher in expected value.
    </template>
  </buton-group>
</avatar>

<avatar text="Okay... here goes...">
  <next>Next</next>
</avatar>

<avatar text="Where are average things manufactured?">
  <next>Next</next>
</avatar>

<avatar>
  <div><bold>The satisfactory!</bold></div>
  <next @click.native="memory='haha'; positivityPoints+=5; $root.play('haha')">Ha-ha!</next> 
  <next @click.native="memory='eh'; positivityPoints-=1; $root.play('crickets')">Eh...</next>
</avatar>

<avatar>
  <div v-if="memory=='haha'">
    Yay!! That joke landed! So I gain 5 positivity points.
  </div>
  <div v-if="memory=='eh'">
    Aw... it seems like that joke didn't land. So I lost 1 positivity point. I'm still glad I told the joke, because it was positive expected value.
  </div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
Help me decide whether to tell each joke or not, by calculating their expected value.
</div>
<next>Next</next>
</avatar>


<div>
  <ev-joke 
    v-for="(joke, index) in jokes" 
    v-if="index <= jokeInd" 
    :joke="joke"
    :key="joke.lead"
    @done="nextJoke"
   />
</div>

<avatar image="brain.png">
<div>
Okay, I think that's enough for positivity. The second tenet of friendship is consistency... find a structure that makes people repeatedly hangout with you.
</div>
<next>Next</next>
</avatar>

<avatar text="Hm... I could join a club that meets regularly.">
  <next>Next</next>
</avatar>

<avatar text="Which club should I join to maximize the number of interactions?">
  <next>Next</next>
</avatar>


<avatar>
  <div>I've plotted the average number of interactions other people have experienced from joining the fencing club.</div>

  <distribution :outcomes="[{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.3},{x: 4, y: 0.4},]" xLabel="Number of interactions" yLabel="Probability" title="Fencing Club" />

  <div>This type of plot with possibilities on the x-axis, and probabilities on the y-axis is called a <bold>distribution</bold>.</div>
  <next>Next</next>
</avatar>

<avatar>
  <div>
    Hm... I wonder how many interactions I could expect to get from joining the fencing club?
  </div>

  <next>Next</next>
</avatar>

<avatar image="brain.png">
  <div>
  Just like before, you can take the expected value. Once the data is plotted as a distribution is the same as finding the <bold>balance point</bold> (where would the distribution balance on your finger if it were made of cardboard).
  </div>

  <div class="smaller-children">Click on the distribution to mark the balance point.</div>

<!--  <fulcrum>
    <template v-slot:center>  <visual-ev-click 
    :outcomes="clubs[0].outcomes"
    :title="clubs[0].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</template>
  </fulcrum>-->

 <visual-ev-click 
    :outcomes="clubs[0].outcomes"
    :title="clubs[0].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 

</avatar>

<avatar text="That's not a bad number of interactions. What about the math team?">

  <visual-ev-click 
    :outcomes="clubs[1].outcomes"
    :title="clubs[1].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="What about Biology Olympiad?">
  <visual-ev-click 
    :outcomes="clubs[2].outcomes"
    :title="clubs[2].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar text="The other club I was considering was the Knitting Circle.">
  <visual-ev-click 
    :outcomes="clubs[3].outcomes"
    :title="clubs[3].name"
    xLabel="Number of interactions"
    yLabel="Probability"
    @done="next" /> 
</avatar>

<avatar>
  <div>
    Okay, so which club should I join? 
  </div>

  <buton-group>
    <buton nope>Fencing Club</buton>
    <buton nope>Math Team</buton>
    <buton yay>Bio Olympiad</buton>
    <buton nope>Knitting Circle</buton>

    <template v-slot:hint>
      Join the club with the maximum expected number of interactions.
    </template>
  </buton-group>
</avatar>

<avatar>
  <div>
Cool, so now I'm a member of Bio Olympiad. And I have {{positivityPoints}} positivity points. What's next?
</div>
<next>Next</next>
</avatar>


<avatar image="brain.png">
  <div>
The final ingredient in making friends is that you need to be vulnerable.
</div>
<next>Next</next>
</avatar>

<avatar>
  <div>
Eh... I'm not going there. Who needs friends anyways?
</div>
<next>Next</next>
</avatar>

<avatar>
  <div>
Why bother... I have Elena. 
</div>
<next>Next</next>
</avatar>

<avatar image="" text="(silence)">
  <next>Next</next>
</avatar>

<avatar text="Elena??? Where's Elena??">
  <next>Next</next>
</avatar>

<avatar 
  image="brain.png">

  <div>You learned....</div>

  <ul>
    <li>The <bold>expected value</bold> is the average reward.</li>
    <li>To use the expected value to make good decisions (on average).</li>
    <li>To take the expected value of a scenario by multiplying the probability of each outcome by the reward, and then summing.</li>
    <li>That the expected value of a distribution its balance point.</li>
  </ul> 

  <buton @click.native="$root.nextChapter()">Next story</buton>

</avatar>

</pset>
</div>
</script>


<script type="text/x-template" id="visual-ev-click-template">

<div>

<!--<div>
Click where you think the balance point is...
</div>
-->

<div style="position:relative">

<distribution ref="distribution" 
  :outcomes="outcomes"
  :title="title"
  :xLabel="xLabel"
  :yLabel="yLabel" ></distribution>

<div style="position:absolute; top:0px; z-index:1"   
  class="overlay"
  :style="overlayStyle"
  @mousemove="mouseX = getRelativeMouseX($event)"
  @mouseenter="isMouseover = true"
  @click.once="distributionClicked">

  <!-- tracks the user mouseover and user answer -->
  <div v-if="isMouseover" 
       style="border-left:2px dashed #000; width:1px; height:200px; position:absolute; bottom: -48px; pointer-events:none;"
       :style="trackerStyle"></div>

  <!-- show the real answer -->
  <div ref="answer-marker"
       v-if="answerPx" 
       class="ev-answer-bar"
       :style="{left: answerPx + 'px'}"
       style="border-left:2px solid #000; width:1px; height:200px; position:absolute; bottom: -48px; pointer-events:none;"></div>
</div>


<div v-if="answerReal" class="smaller-children">
  <div>
  You guessed {{$root.roundTo(guessReal, 1)}}. The <bold>expected value of  {{$root.roundTo(answerReal,1)}}</bold> was {{feedbackString}}
  </div>

  <buton @click.native="$emit('done')">Next</buton>
</div>


</div>
</div>
</script>

<script type="text/x-template" id="ev-joke-template">
<div ref="container">

<avatar ref="joke">
  <div>Should I tell the joke?</div>

  <div v-for="outcome in joke.outcomes">
    {{$root.roundTo(outcome.certainty*100, 0)}}% chance joke {{outcome.present}}, {{outcome.payoff}} points
  </div>

  <div>
    <ev-tree :outcomes="joke.outcomes" /> 
  </div>

  <buton @click.native="setUserAnswer('Yes')">Yes</buton>
  <buton @click.native="setUserAnswer('No')">No</buton>
</avatar>


<avatar v-if="ev > 0 && userAnswer == 'No'">
  <div>Oh, what's wrong with this joke? It seems like positive expected value to me: </div>
  <div>{{evCalculation}}</div>
  <div>Pick again.</div>
</avatar>

<avatar v-if="ev < 0 && userAnswer == 'Yes'">
  <div>Hmm... I'm not sure if this is a good idea: </div>
  <div>{{evCalculation}}</div>
  <div>Pick again.</div>
</avatar>

<avatar v-if="ev < 0 && userAnswer == 'No'">
  <div>
    Good call... that joke has negative expected value so I probably shouldn't tell it.
  </div>
  <buton @click.native="finish(0)">Next</buton>
</avatar>


<pset v-if="(ev > 0 && userAnswer == 'Yes') || forceTell">
<avatar text="Okay... here goes...">
  <next>Next</next>
</avatar>

<avatar :text="joke.lead">
  <next>Next</next>
</avatar>

<avatar>
  <div><bold>{{joke.punchline}}!</bold></div>
  <next @click.native="playJokeSound">{{chosenOutcome.payoff > 0 ? 'Ha-ha!' : 'Eh...'}}</next>
  <div style="font-size:10px">The random number generator in the background dictates that the joke {{chosenOutcome.past}}.</div>
</avatar>


<avatar v-if="userAnswer !== null && chosenOutcome.payoff < 0">
  <div>
    Aw... it seems like that joke {{chosenOutcome.past}}. So I lost {{chosenOutcome.payoff}} positivity points. I'm still glad I told the joke, because it was +{{evString}} points in expected value.
  </div>

  <div>
    {{evCalculation}}
  </div>

  <next @click.native="finish(chosenOutcome.payoff)">Next</next>
</avatar>

<avatar v-if="userAnswer !== null && chosenOutcome.payoff > 0">
  <div>
    Yay!! That joke {{chosenOutcome.past}}! So I gain {{chosenOutcome.payoff}} positivity points.
  </div>
  <next @click.native="finish(chosenOutcome.payoff)">Next</next>
</avatar>

</pset>

</div>
</script>


<script type="text/x-template" id="fulcrum-template">

<div class="normal-div" style="position:relative; width: 100%; height: 250px;">


  <!-- black bar and items -->
  <div :class="{'left-wobble': shouldLeftWobble, 'right-wobble': shouldRightWobble}" 
        :style="{width: width + 'px'}"
        style="position:absolute; border-bottom: 5px solid black; bottom:50px;">


    <div style="position:absolute; left: 40px; top:-180px;">
      <slot name="center"><slot>
    </slot>



  </div>

  <!-- triangle fulcrum -->
  <div class="fulcrum smooth" 
    style="position:absolute; bottom:-50px;"
    :style="fulcrumStyle">
    <div class="bold" style="position:absolute; width:30px; font-size:18px; color:white; left:-22px; top:22px">{{percent}}</div>
  </div>

  <button @click="wobble(3)" style="position:absolute;top:0px; left:0px">wobble</button>


</div>
</script>

<script type="text/x-template" id="bold-template">
<span class="bold"><slot></slot></span> 
</script>


<script type="text/x-template" id="distribution-template">
<div class="distribution" style="display:inline-block">
<div v-if="title" style="text-align: center; font-size: 16px; text-transform:capitalize" :style="titleStyle">{{title}}</div>

<svg :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">
      <rect v-for="outcome in outcomes"
          :x="xScale(outcome.x)"
          :y="yScale(outcome.y)"
          :width="xScale.bandwidth()"
          :height="chartHeight - yScale(outcome.y)"
          :key="outcome.x"
          fill="#EA27A2"/>

      <!-- top of bar 
      <text v-for="outcome in outcomes" 
        :x="xScale(outcome.x) + xScale.bandwidth()/2 - 8"
        :y="yScale(outcome.y) - 2">
        {{ outcome.y }}
      </text>-->
    </g>
</svg>
</div>
</script>

<!-- <triple-bayes 
  :hypotheses="['Nice', 'Evil']" 
  :config="{prior: {dist: [1, 1], correct: [1, 2], isActive: true, isControllable:true}, likelihood: {dist: [10, 1], isActive: true, isControllable: true}, posterior: {}}"></triple-bayes> -->
<script type="text/x-template" id="triple-bayes-template">
<div style="display:inline-block">

<div v-if="hasKey('prior')" class="bayes-comp" :style="compStyle('prior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('prior')}}</div>
    <div>{{subtitle('prior')}}</div>
  </div>

  <samples-chart 
  :xdomain="hypotheses"
  :xLabels="xLabels('prior')"
  :dist="arrToDist(priorArr)"
  :isControllable="isControllable('prior')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  @dist-changed="priorChanged" /> 
</div>


<div v-if="hasKey('likelihood')" class="bayes-comp" :style="compStyle('likelihood')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('likelihood')}}</div>
    <div>{{subtitle('likelihood')}}</div>
  </div>
  <samples-chart
  :xdomain="hypotheses"
  :xLabels="xLabels('likelihood')"
  :dist="arrToDist(likelihoodArr)"
  :isControllable="isControllable('likelihood')"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  @dist-changed="likelihoodChanged" /> 
</div>

<div v-if="hasKey('posterior')" class="bayes-comp" :style="compStyle('posterior')">
  <div class="label normal-div">
    <div style="font-weight:700">{{title('posterior')}}</div>
    <div>{{subtitle('posterior')}}</div>
  </div>
  <samples-chart 
  :xdomain="hypotheses"
  :xLabels="xLabels('posterior')"
  :dist="posteriorDist"
  :chartHeight="chartHeight" :chartWidth="chartWidth"
  :colors="colors"
  ref="posterior-samples-chart" /> 
</div>

<div v-if="showFeedback && !allCorrect" class="handwriting">
  <div>Not quite. Try again!</div>
  <slot name="hint"></slot>
</div>


<div v-if="showFeedback && allCorrect" class="handwriting">
  <div>Correct!</div>
  <slot name="yay"></slot>
</div>

<div v-if="(isControllable('prior') || isControllable('likelihood')) && !(showFeedback && allCorrect)">
<buton @click="submitClicked">Submit</buton>
</div>

  </div>
</script>

<script type="text/x-template" id="samples-chart-template">
<div style="position:relative; display:inline-block" class="samples-chart normal-div"
:class="{disabled: !isControllable}">

<!-- discrete -->
  <svg v-if="view=='discrete'"
     :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom"
     class="no-select">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">

        <g v-for="x in xdomain">
          <rect v-if="counts[x]" v-for="countInd in counts[x]"
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x]) + yScaleBandwidth*(countInd-1)+yPadBetweenBars"
          :width="xScale.bandwidth()"
          :height="yScaleBandwidth-yPadBetweenBars"
          :key="x + countInd"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="Math.max(0, chartHeight - yScale(counts[x]) - 4)">
        {{ prob(x) }}%
      </text>

    </g>
</svg>

<!-- continuous -->
 <svg v-if="view=='continuous'"
     :width="chartWidth+margin.left+margin.right" 
     :height="chartHeight+margin.top+margin.bottom"
     class="no-select">
    <g v-if="isCreated" 
      class="container"
      :transform="'translate(' + margin.left + ',' + margin.top + ')'">

        <g v-for="x in xdomain">
          <rect
          :x="xScale(x)"
          :y="chartHeight - yScale(counts[x])"
          :width="xScale.bandwidth()"
          :height="yScale(counts[x])"
          :fill="colors.bar || '#D1D9E0'"/>
        </g>


      <text v-for="x in xdomain" 
        :x="xScale(x)+ xScale.bandwidth()/2 - 4"
        :y="Math.max(0, chartHeight - yScale(counts[x])) - 4">
        {{ prob(x) }}%
      </text>

    </g>
</svg>


<input v-if="isCreated && isControllable"
       v-for="x in xdomain" 
      :key="x" 
      v-model="counts[x]"
      style="font-size:28px; width:50px; text-align:center" />


</div>
</script>

<script type="text/x-template" id="avatar-template">
<div style="position: relative; display:grid; grid-auto-flow:column; max-width:600px; margin:0 auto; margin-top:16px; grid-template-columns: auto 1fr">

 <div class="cropcircle" :style="cropCircleStyle" style="display:inline-block; vertical-align:top;">
 </div>


<div style="display:inline-block; max-width:400px">
    <div>{{text}}<slot name="text"></slot></div>

    <slot></slot>
</div>

</div>
</script>


<script type="text/x-template" id="exp-template">
<var>{{base}}<sup>{{pow}}</sup></var>
</script>


<script type="text/x-template" id="big-frac-template">
<div style="display: inline-block; text-align:center" class="normal-div">
    <div style="border-bottom:1px solid">{{num}}<slot name="num"></slot></div>
    <div>{{den}}<slot name="den"></slot></div>
  </td>
</div>
</script>

<script type="text/x-template" id="frac-template">
<var><sup>{{num}}</sup>&frasl;<sub>{{den}}</sub></var>
</script>

<script type="text/x-template" id="buton-template">
<span style="margin-bottom:0px; position:relative; display:inline-block; vertical-align:top" class="normal-div">
  <div style="display:inline-block">
    <div v-if="showX" 
         class="handwriting" 
         style="display:inline-block; position:absolute; color:red; font-size: 48px; top:-4px;"
         :style="xStyle">‚úó</div>
     <div v-if="showYay"
              class="handwriting" 
         style="display:inline-block; position:absolute; color:green; font-size: 48px; top:0px; left:calc(50% - 10px)">
     	‚úì
     </div>
    <button ref="button" 
      @click="butonClicked()" v-on="$listeners" 
      :class="{'clicked-button': clickedButton}" 
      class="handwriting"
      :style="mergedButtonStyle"
      style="margin-bottom:4px"><slot></slot>
    </button>
  </div>

  <div v-if="showNopeText" class="hint" style="margin-left:12px;">
    {{nopeText}}
  </div>
  <div v-if="showYay" style="margin:8px;" class="hint" >
    Yay
  </div>

</span>
</script>

<script type="text/x-template" id="buton-group-template">
<div>
  <slot></slot>
  <div v-if="showHint" class="hint"><slot name="hint"></slot></div>
</div>
</script>

<script type="text/x-template" id="input-box-template">
<div style="display:inline-block; position:relative; top:-16px;">

  <input v-model="val" placeholder="?" style="width:70px; display:inline; position:relative; top:16px" v-on:keyup.enter="answerSubmit">
  <slot></slot>
  <buton style="display:inline" @click="answerSubmit">Go</buton>

  <!-- absolute position so they don't shift the screen -->
  <span v-if="showCannedHint" class="hint" style="position:absolute; bottom:-24px; right:4px">
    {{cannedHint}}
  </span>
  <span v-if="showYay" class="hint" style="position:absolute; bottom:-24px; right:12px; color:green">
    Yay!
  </span>

  <div v-if="showHintSlot" class="hint normal-div">
    <slot name="hint"></slot>
  </div>
</div>
</script>


<script>
var DEBUG = false;


const wait = ms => new Promise(resolve => setTimeout(resolve, ms));
// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();



const sneakySnitch = new Howl({src: ['sounds/sneaky-snitch-by-kevin-macleod_edit.wav'], loop: true});

const sounds = {
  'spell': {clip: new Audio('sounds/spell.wav')},
  'heads': {clip: new Audio('sounds/gold0.wav')},
  'tails': {clip: new Audio('sounds/gold1.wav')},


  // 'buton': {clips: [new Audio('sounds/237422__plasterbrain__hover-1.mp3')]},

  'nope': {clip: new Audio('sounds/423169__plasterbrain__pc-game-ui-error.mp3')},
  'yay': {clip: new Audio('sounds/237422__plasterbrain__hover-1.mp3')},

  'haha': {clip: new Audio('sounds/laugh.mp3')},
  'crickets': {clip: new Audio('sounds/crickets.mp3')},

  'open': {clip: new Audio('sounds/swish0.wav')},
  'close': {clip: new Audio('sounds/swish1.wav')},


	'intro-scene': sneakySnitch,  
	'coin-flips': sneakySnitch,
	'wizard-flips': new Howl({src: ['sounds/comfortable_mystery_edit.wav'], loop:true}),
  // 'chain-rule': new Howl({src: ['sounds/wholesome-by-kevin-macleod_edit.wav'], loop:true}),
  // 'chain-rule': new Howl({src: ['sounds/rusted-maid.wav'], loop:true}),
  'chain-rule': new Howl({src: ['sounds/your_call_edit.wav'], loop:true}),

  'ev-story': new Howl({src: ['sounds/extreme-hardcore-death-metal-loop_edit.wav'], loop:true}),
  'intro-to-pvalues': new Howl({src: ['sounds/comma-flaw_edit.wav'], loop:true}),
  'bayes-rule': new Howl({src: ['sounds/find-my-body-please_edit.wav'], loop:true}),
	'thanks': sneakySnitch,
};

const volume = {
  'wizard-flips': 0.7,
  'chain-rule': 0.3,
  'ev-story': 0.3,
  'intro-to-pvalues': 0.7,
  'bayes-rule': 0.7
}

Howler.volume(0.5);


const jokes = [
{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.5, payoff: 3},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.5, payoff: -1}, 
  ],
  lead: "Did you hear about the mathematician who's afraid of negative numbers?",
  punchline: "He'll stop at nothing to avoid them",
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ',certainty: 0.4, payoff: 1},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.6, payoff: -1}, 
  ]
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.4, payoff: 5},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.6, payoff: -1}, 
  ],
  lead:"Why don't scientists trust atoms?",
  punchline:"Because they make up everything"
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.45, payoff: 3},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.55, payoff: -1}, 
  ],
  lead:   "How many times can you subtract 10 from 100?",
  punchline: "Once. The next time you would be subtracting 10 from 90"
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.3, payoff: 4},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.7, payoff: -2}, 
  ]
},

{
  outcomes: [
    {present: 'lands', past: 'landed', emoji: 'üòÇ', certainty: 0.68, payoff: 4},
    {present: 'fails', past: 'failed', emoji: 'ü¶ó', certainty: 0.32, payoff: -1}, 
  ],
  lead: "The numbers 19 and 20 got into a fight.",
  punchline: "21"
},
];

const clubs = [
  {
    name: 'fencing club',
    outcomes: [{x: 1, y: 0.2},{x: 2, y: 0.3},{x: 3, y: 0.3},{x: 4, y: 0.2},]
  },
  {
    name: 'math team',
    outcomes: [{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.3},{x: 4, y: 0.4},]
  },
  {
    name: 'biology olympiad',
    outcomes: [{x: 1, y: 0.1},{x: 2, y: 0.2},{x: 3, y: 0.1},{x: 4, y: 0.6},]
  },
  {
    name: 'knitting circle',
    outcomes: [{x:1, y: 0}, {x: 2, y: 0.5},{x: 3, y: 0.3},{x: 4, y: 0.2},]
  },
];



Vue.component('coin', {
  props: {
    bias: {type: Number, default: 0.5},
    pattern: {type: String},
    sideBySide: {type: Boolean, default: false},
  },
  data: function(){
    return {
      flips: [], //true, false, true, true], 
      isMouseDown: false,
      autoFlipper: null,
    }
  },
  watch: {
    isMouseDown(){
      if (this.isMouseDown == false){
        // This flip handles the click case.
        this.flip();
        if (this.autoFlipper){
          clearInterval(this.autoFlipper);
        }
      }

      if (this.isMouseDown == true){
        const this_ = this;
        this.autoFlipper = setInterval(function(){
          if (this_.isMouseDown == true){
            this_.flip();
          }
        }, 150);        
      }
    }
  },
  computed: {
    flipString: function(){
      return this.samples.join('');
    },
    flipStringStyle: function(){
      return { 'min-height': '30px'};
    },
    isShowingH: function(){
      if (this.flips.length == 0){
        return true;
      }
      return this.render(this.last) == 'H';
    },
    last: function(){
      return this.flips[this.flips.length-1];
    },

    xDomain(){
      return ['H', 'A'];
    },
    // ['H', 'A', 'H', 'A']
    samples(){
      return this.flips.map(this.render);
    },
    dist(){
      return _.assign({'H': 0, 'A': 0}, _.countBy(this.samples));
    },
    chartStyle(){
      if (this.sideBySide){
      return {
        position: 'absolute',
        left: '150px',
        bottom: '0px'       
      };
    }
    }
  },
  methods: {
    render: function(flip){
      return flip ? 'H' : 'A';
    },
    append: function(flip){
      this.$root.play(flip ? 'heads' : 'tails');
      this.flips.push(!!flip);
    },
    reset: function(){
      this.flips = [];
    },
    flip: function(){
      // Always repeats as HAHA.
      if (this.pattern == 'haha'){
        if (this.flips.length == 0){
          this.append(1);
        } else {
          this.append(Math.abs(this.last - 1));
        }

        // Early return.
        return;
      }

      // Prevents long streaks from happening.
      if (this.pattern == 'human'){
        const maxStreak = 3;
        if (this.flips.length > maxStreak){
          const slice = this.flips.slice(-maxStreak);
          if(_.every(slice) || _.every(slice, x => !x)){ 
            // If the last ones have all been of a type, the new one must be opposite.
            this.append(Math.abs(this.last - 1));
          } 

          // Fallthrough.
        }
      }

      // True coin flip.
      this.append(Math.random() < this.bias); 
    }
  },
  template: '#coin-template'
});



Vue.component('summoning', {
  props: {
    bias: {type: Number, default: 0.25}, // Chance of success
  },
  data: function(){
    return {
//      flips: [], // ['‚ú®‚ú®‚ú®', ' ‚ú®‚ú®üí•'], 

      isMouseDown: false,
      autoFlipper: null,

      isWon: false,
    }
  },
  watch: {
    isMouseDown(){
      if (this.isMouseDown == false){
        // This flip handles the click case.
        this.flip();
        if (this.autoFlipper){
          clearInterval(this.autoFlipper);
        }
      }

      if (this.isMouseDown == true){
        const this_ = this;
        this.autoFlipper = setInterval(function(){
          if (this_.isMouseDown == true){
            this_.flip();
          }
        }, 150);        
      }
    }
  },

  methods: {
    flip: function(){
      if (this.isWon){
        return;
      }

      this.$root.play('spell');
      var result = '';
      for (var i=0; i<3; i++){
        result += Math.random() < this.bias ? '‚ú®' : 'üí•';
      }
      this.$root.summoningFlips.unshift(result);       

      if (result === '‚ú®‚ú®‚ú®'){
        this.isWon = true;
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }        
      }
    }
  },
  template: '#summoning-template'
});


// Returns a boolean measuring if two numbers are approximately equal.
function approx(a, b, epsilon){
  var epsilon = _.isUndefined(epsilon) ? .0001 : epsilon;
  return Math.abs(a - b) < epsilon;
}

function cumulativeSum(arr){
  if (arr.length < 1){
    return [];
  }

  var total = [arr[0]];
  for (var i=1; i<arr.length; i++){
    var last = total[total.length - 1];
    total.push(last + arr[i]);
  }
  return total;
}


// outcomes = [
//  {certainty: 0.4, ...}, 
//  {certainty: 0.6, ...}
// ]
function drawFromOutcomes(outcomes){
  var ind = drawIndFromOutcomes(outcomes);
  return outcomes[ind];
}

function drawIndFromOutcomes(outcomes){
  var certainties = _.map(outcomes, 'certainty');
  if (!approx(_.sum(certainties), 1.0)){
    debugger;
    console.error('certainties for outcomes did not sum to 1: ' + outcomes);
  }

  var rand = Math.random();
  var cumsum_certainties = cumulativeSum(certainties);
  var cumsum_ind = 0;
  while (cumsum_certainties[cumsum_ind] < rand){
    cumsum_ind++;
  }
  return cumsum_ind;
}

Vue.component('ev-joke', {
  props: {
    joke: {type: Object},
  },
  computed: {
    ev(){
      return _.sum(this.joke.outcomes.map(outcome => outcome.certainty * outcome.payoff));
    },
    evString(){
      return this.$root.roundTo(this.ev, 2);
    },
    evCalculation(){
      return this.joke.outcomes.map(outcome => outcome.certainty + ' √ó ' + outcome.payoff).join(' + ') + ' = ' + this.evString;
    },
    chosenOutcome(){
      return this.joke.outcomes[this.chosenOutcomeInd];
    },
    isWrong(){
      return (this.ev > 0 && this.userAnswer == 'No') || (this.ev < 0 && this.userAnswer == 'Yes');
    }
  },
  mounted(){
   this.chosenOutcomeInd = drawIndFromOutcomes(this.joke.outcomes);
  },
  data: function(){
    return {
      stage: 0,
      userAnswer: null,
      forceTell:null,
    }
  },
  methods: {
    setUserAnswer(answer){
      this.userAnswer = answer;
      if(!this.isWrong){
        this.$refs['joke'].$el.style.opacity = 0.5;        
      }
    },
    playJokeSound(){
      const soundName = this.chosenOutcome.payoff > 0 ? 'haha' : 'crickets';
      this.$root.play(soundName);
    },
    finish(payoff){
      this.$refs['container'].style.opacity = 0.5; 
      this.$emit('done', {payoff: payoff});
    }
  },
  template: '#ev-joke-template'
});


Vue.component('biased-coin-machine', {
  data: function(){
    return {
      slider: '50',
    }
  },
  computed: {
    bias: function(){
      return +this.slider / 100;
    },
  },
  watch:{
    bias: function(){
      this.$refs['coin'].reset();
    },
  },
  template: '#biased-coin-machine-template'
});


Vue.component('input-box', {
  props: {
    right: {type: Array},
    hints: {
      type: Array, 
      default: function(){ return ['Try again', 'Nope']; },
    },
  },
  computed: {
    cannedHint(){
      return this.hints[this.answers.length % this.hints.length];      
    },
    isYay: function(){
      const this_ = this;
      if (_.isArray(this.right)){
        return _.some(this.right.map(r => this_.isMatch(this_.val, r)));
      }
      return this.isMatch(this.val, this.right);
    },
    isNope: function(){
      return !this.isYay;
    },
    showYay(){
      return this.checkedAnswer && this.isYay;
    },
    showCannedHint(){
      return this.checkedAnswer && !this.hasSlot('hint') && this.isNope;
    },
    showHintSlot(){
      return (DEBUG || this.checkedAnswer) && this.hasSlot('hint') && this.isNope;
    }
  },
  data: function(){
    return {
      val: null,
      answers: [],

      checkedAnswer: false,
      calledNext: false,
    }
  },
  watch:{
    val(){
      this.checkedAnswer = false;
    }
  },
  methods: {
    isMatch(val, right){
      if (val === undefined || val === null){
        return false;
      }
      const exactMatch = val == right;
      const europeanCommaMatch = val.replace(',', '.') == right;
      var evalMatch;
      try {
        evalMatch = approx(eval(val), eval(right));
      } catch(err){
        evalMatch = false;
      }
      return exactMatch || europeanCommaMatch || evalMatch;
    },
    answerSubmit: async function(){
      this.checkedAnswer = true;
      this.answers.push(this.val);

      if (this.isYay){
        this.$root.play('yay');
        this.$emit('yay');

        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset && !this.calledNext){
          pset.next();
          this.calledNext = true;
        }
      } else {
        this.$root.play('nope');
      }

    },
    hasSlot: hasSlot,
  },
  template: '#input-box-template'
});


function firstAncestorOfComponent(node, componentName){
  while(node !== undefined){
    node = node.$parent;
    if (node !== undefined && node.$options.name === componentName){
      return node;
    }
  }
  return undefined;
}
function isDescendant(ancestor, maybeChild){

  // If maybeChild is a vue component
  var node = maybeChild.$parent;
  while(node){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }

  // If maybeChild is an HTML element
  var node = maybeChild.parentElement;
  while(node){
    if (node === ancestor){
      return true;
    }
    node = node.parentElement;
  }

  return false;
}

function hasSlot(name){
  return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
}

Vue.component('avatar', {
  props: {
    image: {type: String, default:'wizard.png'},
    text: {type: String, default: ''},
    sound: {type: String},
  },
  mounted: async function(){
    // Add a blink
    var this_ = this;
    if (this.sound){
      this.$root.play(this.sound);
      await wait(sounds[this.sound].duration || 500);
    }
  },
  computed: {
    cropCircleStyle: function(){
      return {'background-image': 'url("images/' + this.image + '")'};
    },
  },
  template: '#avatar-template'
});

// Just like a button, but with some special abilities.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.
    buttonStyle: {type: Object},
    scroll: {type: Boolean, default: true},
  },
  data: function(){
    return {
      clickedButton: false,
    }
  },
  computed: {
    nopeText: function(){
      if (this.nope){
        return this.nope;        
      }
      if (this.isNope){
        return 'Try again';
      }
    },
    // Returns true for: <buton nope> or <buton nope="why not">
    isNope: function(){
      return this.nope || this.nope==="";
    },
    isYay: function(){
      return 'yay' in this.$attrs;
    },
    defaultStyle(){
      if (this.$slots.default[0].text){
        const defaultFontSize = this.$slots.default[0].text.length > 40 ?16 : 20;
        return {'font-size': defaultFontSize + 'px'};        
      }
    },
    mergedButtonStyle: function(){
      return _.merge(this.defaultStyle, this.buttonStyle);
    },
    showNopeText(){
      return (DEBUG || this.clickedButton) && this.isNope;
    },
    showYay(){
      return (DEBUG || this.clickedButton) && this.isYay;
    },
    showX(){
      return this.clickedButton && this.isNope;
    }, 
    xStyle(){
      return {left: (this.$refs['button'].clientWidth/2 - 5)+'px'};
    }
  },
  methods: {
    butonClicked: async function(){
      if (this.isYay){
        this.$root.play('yay');        
      } else if (this.isNope){
        this.$root.play('nope');
      } else{
        this.$root.play('buton');        
      }
      this.clickedButton = true;
      const avatar = firstAncestorOfComponent(this, 'avatar');

      // Tell those listening on the bus that the buton has been clicked... unless it's a buton within an input-box.
      if(!firstAncestorOfComponent(this, 'input-box')){
        // Don't emit again if this is the buton inside PS either.
        if (avatar && avatar.psButton !== this){
          bus.$emit('answer-submitted', this);        
        }
      }

      // Add yourself to parent butonGroup's clicked children
      // so it can show feedback.
      const butonGroup = firstAncestorOfComponent(this, 'buton-group');
      if (butonGroup){
        butonGroup.clickedChildren.push(this);
      }

      // Move the screen along.
      if (this.isYay){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }        
      }

      if (this.scroll){
        this.$root.scrollWindow();        
      }

    },
  },
  template: '#buton-template'
});


Vue.component('exp', {
  props: {
    base: {type: String },
    pow: {type: String },
  },
  template: '#exp-template'
});


Vue.component('frac', {
  props: {
    num: {type: String },
    den: {type: String },
  },
  template: '#frac-template'
});


Vue.component('big-frac', {
  props: {
    num: {type: String },
    den: {type: String },
  },
  template: '#big-frac-template'
});


// histogram example
// https://bl.ocks.org/d3noob/96b74d0bd6d11427dd797892551a103c
Vue.component('distribution', {
  props: {

    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    // Pass in outcomes directly.
    outcomes: {type: Array, default: function(){
      return [
        {x: 'tattoos', y: 0.2},
        {x: 'no tattoos', y: 0.8},
      ];
    }},
    chartHeight: {type: Number, default: 150},
    chartWidth: {type: Number, default: 200},
    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 50, left: 50};
      }
    },
  },
  computed: {
    xScale(){
      return d3.scaleBand()
          .domain(this.outcomes.map(d => d.x)).paddingInner(0.01).range([0, this.chartWidth]);
    },
    xScaleContinuous(){
      const domain = this.xScale.domain();
      const range = this.xScale.range();
      const bandwidth = this.xScale.bandwidth();
      return d3.scaleLinear().domain([domain[0], domain[domain.length-1]]).range([range[0] + bandwidth/2, range[1] - bandwidth/2]);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, 1]).range([this.chartHeight, 0]);
    },
    titleStyle(){
      return {'margin-left': this.margin.left + 'px', 'margin-right': this.margin.right + 'px'};
    },
    mean: function(){
      return _.sum(this.outcomes.map(outcome => outcome.x * outcome.y));
    },
  },
  data: function(){
    return {
      isCreated: false,
    }
  },
  created: function(){
    // Add domains
    this.isCreated = true;
  },
  mounted: function() {
    // Add the axis
    var xAxis = d3.axisBottom(this.xScale); //.ticks(8);
    var yAxis = d3.axisLeft(this.yScale).ticks(4);

    const chart = d3.select(this.$el).select('.container');
    chart.append('g').call(yAxis);
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);


    // x axis label
    chart.append("text")             
      .attr("transform",
            "translate(" + (this.chartWidth/2) + " ," + 
                           (this.chartHeight + this.margin.top + 20) + ")")
      .style("text-anchor", "middle")
      .text(this.xLabel);

    // y axis label
    chart.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - this.margin.left)
      .attr("x",0 - (this.chartHeight / 2))
      .attr("dy", "1em")
      .style("text-anchor", "middle")
      .text(this.yLabel);    

  },
  template: '#distribution-template'
});


Vue.component('visual-ev-click', {
  props: {
    title: {type: String},
    xLabel: {type: String},
    yLabel: {type: String},

    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
  },
  data: function(){
    return {
      isMouseover: false,

      mouseX: null,  // tracks mouse position always

      guessPx: null, // populated when user clicks
      guessReal: null, // populated when user clicks

      answerPx: null, // populated after delay when user clicks
      answerReal: null, // populated after delay when user clicks

      isMounted: false,
    };
  },

  watch:{
    answerReal(){
      this.$root.scrollWindow();
    }
  },

  computed: {
    trackerStyle: function(){
      return {
        left: (this.guessPx !== null ? this.guessPx : this.mouseX) + 'px'
      };
    },

    userDifference: function(){
      // Is close if it's less than X% away from the true answer
      var distribution_component = this.$refs['distribution'];
      const domain = distribution_component.xScale.domain();
      var total = domain[domain.length-1] - domain[0];

      return Math.abs(this.answerReal - this.guessReal);
    },

    feedbackString: function(){
      if (this.userDifference < .1){
        this.$root.play('yay');
        return 'spot on. Good work!';
      }
      if (this.userDifference < .3){
        this.$root.play('yay');
        return 'pretty close! Good job!';
      }
      this.$root.play('nope');
      return 'far off. Needs work.';
    },

    overlayStyle(){
       if(!this.isMounted){
          return;        
       }
       const d = this.$refs['distribution'];

       return {
          left: d.margin.left + 'px',
          height: d.chartHeight + d.margin.bottom + 'px',
          width: d.chartWidth + 'px'
       };
    }
  },

  mounted(){
    this.isMounted = true;
  },

  methods: {
    distributionClicked: async function(event){
      const distribution_component = this.$refs['distribution'];
      const distMean = distribution_component.mean;
      const xScale = distribution_component.xScaleContinuous; 

      this.guessPx = this.getRelativeMouseX(event);
      this.guessReal = xScale.invert(this.guessPx);

      // answerPx gets animated into the correct position.
      this.answerPx = this.guessPx;

      // Make the answer bar animate.
      await wait(300);
      this.answerPx = xScale(distMean);
      //debugger;

      // Make the text show.
      await wait(1300);
      this.answerReal = distMean;
    },

    getRelativeMouseX: function(event){
      // Find the parent element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'overlay'){
        refElement = refElement.parentElement;
      }
      return event.clientX - refElement.getBoundingClientRect().x;
    },

  },
  template: '#visual-ev-click-template',
});


Vue.component('triple-bayes', {
  props: {

    hypotheses: {type: Array}, // ['Nice', 'Evil']
        
    chartHeight: {type: Number, default: 160},
    chartWidth: {type: Number, default: 100},

    // Missing keys from config are not rendered.
    // {prior: {dist: [1, 4]}, likelihood: {isActive: true, isControllable: true, dist: [1, 10]}, posterior: {}}
    config: {type: Object},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '#ddd', dot: '#EF6D21'};
      }
    },
  },
  data: function(){
    return {
     conf: null,
     showFeedback: null,
    }
  },
  computed: {
    posteriorDist(){
      var distArr = _.zip(this.priorArr, this.likelihoodArr).map(x => _.reduce(x, _.multiply));
      if (_.max(distArr) > 9){ // Start attempting to simplify posterior when it gets too big.
        distArr = this.simplifiedArr(distArr);
      }
      return _.zipObject(this.hypotheses, distArr);
    },
    priorArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['prior'].dist || ones;
    },

    likelihoodArr(){
      const ones = _.range(this.hypotheses.length).map(_ => 1);
      return this.conf['likelihood'].dist || ones;
    },
    allCorrect(){
      const keys = ['prior', 'likelihood', 'posterior'];
      const parts = keys.map(key => !this.conf[key] || !this.conf[key].correct || this.isEqual(this.conf[key].correct, this.conf[key].dist));
      return _.every(parts);
    }
  },
  created(){
    this.conf = _.cloneDeep(this.config);
  },
  methods: {
    isEqual(arr1, arr2){
      return _.isEqual(this.simplifiedArr(arr1), this.simplifiedArr(arr2));
    },
    xLabels(key){
      if (key == 'prior'){
        return this.hypotheses.map(x => 'P(' + x + ')');
      }
      if (key == 'likelihood'){
        return this.hypotheses.map(x => 'P(E|' + x + ')' );        
      }
      if (key == 'posterior'){
        return this.hypotheses.map(x => 'P(' + x + '|E)');        
      }
    },
    // simplifiedArr([3, 6]) => [1, 2]
    simplifiedArr(arr){
      var maxFactor = _.min(arr);
      for (var i=maxFactor; i>1; i--){
        var isDivisible = _.every(arr.map(function(x){
          return Math.abs(x/i - Math.floor(x/i)) < .0001;
        }));
        if (isDivisible){
          break;
        }
      }
      var result = arr.map(x => Math.floor(x / i));
      //console.log(result);
      return result;
    },
    title(key){
      if (this.conf[key].title !== undefined){
        return this.conf[key].title;
      }
      const defaultTitles = {
        'prior': 'Prior Belief',
        'likelihood': 'Likelihood Ratio',
        'posterior': 'Posterior Belief'
      };
      return defaultTitles[key];
    },
    subtitle(key){
      if (this.conf[key].subtitle !== undefined){
        return this.conf[key].subtitle;
      }
      const defaultTitles = {
        'prior': 'What you thought before',
        'likelihood': 'Likelihood ratio of the evidence',
        'posterior': 'What you think after the evidence'
      };
      return defaultTitles[key];
    },
    hasKey(key){
      return this.conf[key];
    },
    isActive(key){
      return this.conf[key] && this.conf[key].isActive;
    },
    isControllable(key){
      return this.conf[key] && this.conf[key].isControllable;      
    },
    arrToDist(arr){
      return _.zipObject(this.hypotheses, arr);
    },
    isCompRight(key){
      return this.showFeedback && this.conf[key] && this.conf[key].correct && this.isEqual(this.conf[key].correct, this.conf[key].dist);
    },
    compStyle(key){
      return {opacity: this.conf[key] && this.conf[key].isActive ? 1 : 0.5};
    },
    likelihoodChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.likelihood, 'dist', distArr);
      this.refreshPosterior();
    },
    priorChanged(params){
      this.showFeedback = false;
      const distArr = this.hypotheses.map(hyp => params.dist[hyp]);
      Vue.set(this.conf.prior, 'dist', distArr);
      this.refreshPosterior();
    },
    refreshPosterior(){
      if (this.$refs['posterior-samples-chart']){
        this.$refs['posterior-samples-chart'].countsFromProps()         
      }
    },
    submitClicked(){
      this.showFeedback=true;
      if(this.allCorrect){
        const pset = firstAncestorOfComponent(this, 'pset');
        if (pset){
          pset.next();
        }
        this.$emit('yay');
      }
    }
  },
  template: '#triple-bayes-template'
});

Vue.component('samples-chart', {
  props: {

    xdomain: {type: Array}, // ['H', 'T']
    xLabels: {type: Array}, // ['P(H'), 'P(T)'] optional. Defaults to x-domain if not set.

    dist: {type: Object}, // {H: 3, T: 1}
        
    chartHeight: {type: Number, default: 100},
    chartWidth: {type: Number, default: 100},
    margin: {
      type: Object, 
      default: function(){
        return {top: 20, right: 10, bottom: 40, left: 10};
      }
    },

    isControllable: {type: Boolean, default: false}, 

    // Minimum number of bars in y direction.
    minNumInY: {type: Number, default: 10},

    colors: {
      type: Object, 
      default: function(){
        return {bar: '', dot: ''};
      }
    },

  },
  computed: {
    xScale(){
      // Can only use for categorical domain.
      return d3.scaleBand()
          .domain(this.xdomain).paddingInner(.1).range([0, this.chartWidth]);
    },
    xText(){
      return this.xLabels || this.xdomain;
    },

    maxBinLength(){
      return Math.max.apply(this, _.values(this.dist));
    },

    numBarsInY(){
      return Math.max(this.minNumInY, this.maxBinLength);
    },
    yScale(){
      return d3.scaleLinear()
          .domain([0, this.numBarsInY]).range([0, this.chartHeight]);
    },
    yScaleBandwidth(){
      return this.chartHeight / this.numBarsInY; 
    },
    view(){
      return this.maxBinLength < this.minNumInY ? 'discrete' : 'continuous';
    }
  },
  data: function(){
    return {
      yPadBetweenBars: 2,
      isCreated: false,
      counts: {},
    }
  },
  mounted: async function() {
    this.countsFromProps();
    this.isCreated = true;

    // Add the axis
    // Hack: for some reason axis needs to get added after a delay, or it doesn't show up.
    await wait(500);
    const this_ = this;
    var xAxis = d3.axisBottom(this.xScale).tickFormat(function(d, ind){
      return this_.xText[ind];
    }); //.ticks(8);
    const chart = d3.select(this.$el).select('.container');
    chart.append('g').attr('transform', 'translate(0,' + this.chartHeight + ')').call(xAxis);
  },
  watch: {
    dist: {
      handler(){
        this.countsFromProps();        
      },
      deep: true
    },
    counts: {
      handler(){
        this.$emit('dist-changed', {dist: _.mapValues(this.counts, x => Number(x))});  
      },
      deep: true
    },
  },
  methods: {
    prob(x){
      const total = _.sum(_.values(this.counts));
      return this.$root.roundTo(this.counts[x]/total*100, 0);
    },
    countsFromProps(){
      // Can't modify props, so we reactively copy it here.
      if (this.dist){
        for (var key in this.dist){
          Vue.set(this.counts, key, this.dist[key]);
        }        
      }      
    },
  },
  template: '#samples-chart-template'
});

// Put a buton inside a once-group to ensure it is only clicked once.
Vue.component('once-group', {
  data: function(){
    return {
      isClicked: false
    }
  },
  methods: {
    childClicked: function(childComponent) {
      if (this.isClicked){
        return;
      }
      this.isClicked = true;
    }
  },
  template: '#once-group-template',
});

// Allows hints to be shown. Buttons within the group can be clicked multiple times.
Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  computed: {
    lastChild(){
      if (this.clickedChildren.length > 0){
        return this.clickedChildren[this.clickedChildren.length-1];
      }
    },
    showHint(){
      if (DEBUG){
        return true;
      }
      if (this.lastChild){
        return this.lastChild.isNope;
      }
      return false;
    }
  },
  data: function(){
    return {
      clickedChildren: [],
    }
  },
  template: '#buton-group-template'
});


Vue.component('bold', {
  template: '#bold-template'
});

function makeComponent(componentName){
  Vue.component(componentName, {
    data: function(){
      return {

        problemTuples: [], // [ ['problem1', true], ['problem2', false] ]
        memory: null, // A variable for dumping short term component state.

        chapters: chapters,

        // State for 'ev-story'
        positivityPoints: 0,
        jokes: jokes,
        jokeInd: 0,
        clubs: clubs,
        clubInd: 0,


      };
    },
    computed: {
      // 'fakeout1': [false, true]
      problemToCorrectness(){
        return _.mapValues(_.groupBy(this.problemTuples, d => d[0]), arr => arr.map(d => d[1]));
      }
    },
    mounted: async function(){
      var this_ = this;
      bus.$on('answer-submitted', async function(input){        
        // Respond only if the input is within the current component.
        if (!isDescendant(this_, input)){
          return;
        }

        var avatar = firstAncestorOfComponent(input, 'avatar');
        if (!avatar){
          return;
        }

        var problemKey = avatar.$vnode.data.key;
        if (input.isYay){
          this_.addCorrectness(problemKey, true);          
        } 
        if (input.isNope){
          this_.addCorrectness(problemKey, false);          
        } 
      });
    },
    methods: {
      addCorrectness(key, isCorrect){
        this.problemTuples.push([key, isCorrect]);
//        console.log('logging ' + key + ': ' + isCorrect);
      },

      // Got the correct answer once.
      got: function(key){
//        console.log('calling "got" for ' + key);
        // Return the latest value
        if (this.problemToCorrectness[key]){
          var answers = this.problemToCorrectness[key];
          return answers[answers.length-1];
        } else {
          console.warn('checking for correctness of ' + key + ' which did not exist');
          return false;
        }
      },

      // Got the correct answer every time.
      perfect: function(key){
        if(this.problemToCorrectness[key] && _.every(this.problemToCorrectness[key])){
          return true;
        }
        return false;
      },
      nextJoke(params){
        this.positivityPoints += params.payoff;
        this.jokeInd++;
//        console.log(this.jokeInd + ' ' + this.jokes.length);
        if (this.jokeInd >= this.jokes.length){
          this.next();
        }
      },
      next(){
        this.$refs['pset'].next();
      }
    },
    template: '#' + componentName + '-template'
  });
}
['intro-scene', 'coin-flips', 'wizard-flips', 'chain-rule', 'ev-story', 'risk-reward', 'intro-to-pvalues', 'bayes-rule', 'thanks'].forEach(x => makeComponent(x));


Vue.component('next', {
  methods: {
    next(){
      if ('nope' in this.$attrs){
        this.$root.play('nope');
      }
      const pset = firstAncestorOfComponent(this, 'pset');
      if (pset){
        pset.next();
      }      
    }
  },
  template: '#next-template'
});


Vue.component('tree-diagram', {
  template: '#tree-diagram-template'
});


Vue.component('ev-tree', {
  props:{
    outcomes: {type: Array, default: () => [
        {certainty: 0.5, payoff: -1}, 
        {certainty: 0.5, payoff: 5}
      ]
    },
  },
  methods: {
    prettyString(val){
      return val > 0 ? '+' + val : val;
    }
  },
  template: '#ev-tree-template'
});


Vue.component('tree-node', {
  props:{
    emojis: {type: Array, default: () => ['üç±', 'ü•õ']},
    height: {type: Number, default: 100},
    width: {type: Number, default: 80},

    emojiHeight: {type: Number, default: 30},
    emojiWidth: {type: Number, default: 30},
    emojiPadding: {type: Number, default: 8}, // distance from emoji to line    

    linePadding: {type: Number, default: 20}, // distance from top/bottom

    margin: {
      type: Object, 
      default: function(){
        return {top: 10, right: 10, bottom: 50, left: 50};
      }
    },

    color: {
      type: String, default: '01' // which path to highlight
    },

  },
  computed: {
    lineX(){
      return this.width - this.emojiWidth - this.emojiPadding;
    }
  },
  template: '#tree-node-template'
});


Vue.component('fulcrum', {
  props: {
    width: {type: Number, default: 400},
    certainty: {type: Number, default: null},
  },

  data: function(){
    return {
      numLeftRows: 0, 
      numRightRows: 0, 
      shouldLeftWobble: false,
      shouldRightWobble: false,

      animationTime: 500,
      betweenAnimationTime: 200,
    };
  },
  computed: {
    percent: function(){
      if (!this.certainty){
        return '';
      }
      const params = this.$root.paramsFromCertainty(this.certainty);
      return params.percent;
    },
    fulcrumStyle: function(){
      const certainty = this.certainty || 0.5;
      return {left: (this.width*certainty - 50) + 'px'};
    }
  },
  methods: {
    wobble: async function(num_times){
      for (var i=0; i<num_times; i++){
        await this.leftWobble();
        await this.rightWobble();
      }
    },
    leftWobble: async function(){
      this.shouldLeftWobble = true;        
      await wait(this.animationTime);
      this.shouldLeftWobble = false;
      await wait(this.betweenAnimationTime);      
    },

    rightWobble: async function(){
      this.shouldRightWobble = true;        
      await wait(this.animationTime);
      this.shouldRightWobble = false;
      await wait(this.betweenAnimationTime);      
    }
  },

  template: '#fulcrum-template'
});

// Child slot should call next() on the parent to advance.
Vue.component('pset', {
  computed: {
    elms(){
      return this.$slots.default.filter(x => x.tag).map(x => x.elm);
    }
  },
  data: function(){
    return {
      ind: 0, // active index
    };
  },

  mounted: function(){
    // Hides elements initially.
    if (!DEBUG){
      for (var i=1; i<this.elms.length; i++){
        this.elms[i].style.display = 'none';
      }      
    }

    this.$root.report(0);
  },
  methods: {
    async next(){
      this.ind = this.ind + 1;
      if (this.ind >= this.elms.length){
        this.$emit('done');
        return;
      }

      // grey out previous indices
      for (var i=0; i<this.ind; i++){
        this.elms[i].style.opacity = 0.5;   
        this.elms[i].classList.add('disabled');  
      }

      // make current ind, fully visible
//      this.elms[this.ind].style.display = 'block';
      this.elms[this.ind].style.display = 'grid';

      this.$root.report(this.ind);

      await wait(200);
      this.$root.scrollWindow();
    }
  },
  template: '#pset-template'
});


const chapters = [
{
  component: 'intro-scene',
  image: 'scroll.png',
  title: 'The beginning',
},
{
  component: 'coin-flips',
  description: 'Independent events',
  image: 'milk.png',
},
{
  component: 'wizard-flips',
  description: 'What does randomness look like',
  image: 'wizard.png',
},
{
  component: 'chain-rule',
  description: 'Chain rule of probability',
  image: 'girl.png',
},
{
  component: 'ev-story',
  description: 'Expected value',
  image: 'wizard.png',
},
{
  component: 'intro-to-pvalues',
  description: 'P-values', 
  image: 'scientist.png',
},
{
  component: 'bayes-rule',
  description: 'Bayes Rule', 
  image: 'crow.png',
},
{
  component: 'thanks',
  image: 'wizard.png',
  title: 'The End', 
},

];


function formatPct(certainty){
  return roundTo(certainty*100, 0) + '%';
}

// round_to(2.777777, 0) -> 3
// round_to(2.777777, 2) -> 2.78
function roundTo(x, num_decimals){
  return parseFloat(x.toFixed(num_decimals));
}


// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {
    chapters: chapters,
    chapterInd: DEBUG ? 6 : 0,
    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    showTOC: false,
    hasVolume: false,

    isScrolling: false,

    elapsedMinutes: null,
    elapsedSeconds: null,


    activeLoops: [],
    // Doesn't need to be reactive so this is OK.
    soundToCount: {},

    summoningFlips: [],
  },
  watch: {
    chapterInd(){
    	this.playChapterAudio();
      if (this.chapterInd == 7){
        // scroll to the top
        window.scrollTo(0, 0);
      }
    },
    showTOC(){
      if (this.showTOC){
        this.play('open');
      } else {
        this.play('close');
      }
    }
  },
  computed: {
    currentChapter: function(){
      return this.chapters[this.chapterInd];
    },
    visibleScreen: function(){
      return this.currentChapter.component;
    },
    componentStyle(){
      if (this.showTOC){
        return {
          position: 'absolute',
          left: '180px',
          top: '0px',
          width: 'calc(100% - 180px)'
        };
      }
      return {
          position: 'absolute',
          left: '0px',
          top: '0px',
          width: '100%'
      };
    }
  },
  mounted(){
    const loadTime = Date.now();
    var this_ = this;
    setInterval(function(){
      const seconds = (Date.now() - loadTime) / 1000;
      this_.elapsedMinutes = Math.floor(seconds/60);
      this_.elapsedSeconds = this_.roundTo(seconds % 60, 0);
    }, 1000);
  },
  methods: {
    formatPct: formatPct,
    roundTo: roundTo,
    playChapterAudio(){
 	    this.silenceLoops();
      this.playLoop(this.chapters[this.chapterInd].component);
    },
    nextChapter: async function(){
      this.chapterInd = Math.min(this.chapters.length-1, this.chapterInd+1);
    },
    play: function(soundName){
      if(!this.hasVolume){
        return;
      }

      if (!sounds[soundName]){
        return;
      }

      const clip = sounds[soundName].clip;
      if (clip){
        this._playClip(clip);
        return;
      }

      const clips = sounds[soundName].clips;
      if (clips){
        if (!(soundName in this.soundToCount)){
          this.soundToCount[soundName] = 0;
        }

        const ind = this.soundToCount[soundName] % clips.length;
        this.soundToCount[soundName]++;
        this._playClip(clips[ind]);
      }
    },
    playLoop(soundName){
      if(!this.hasVolume){
        return;
      }

      if (!sounds[soundName]){
        return;
      }
      const loop = sounds[soundName];
      if (this.activeLoops.indexOf(loop) == -1){
        loop.play(); 
        loop.fade(0, volume[soundName] || 1, 1000);
        this.activeLoops.push(loop);
      }
    },
    silenceLoops(){
      this.activeLoops.forEach(function(loop){
        loop.fade(1, 0, 1000); 
        loop.stop();
      });
      this.activeLoops = [];
    },
    _playClip(clip){
      clip.play().catch(function(error){
        console.log(error.toString());
      });            
    },
    async scrollWindow(){
      if (this.isScrolling){
        return;
      }

      var minNumScrolls = 3;
      this.isScrolling = true;
      // Scroll down a little bit and see if we should keep scrolling.
      // Stop scrolling if we've reached the bottom, 
      // Or if we have somehow traveled up (i.e. user has moved the mouse)
      while (true){
        const startY = window.scrollY;
        if (this.lastStartY >= startY && minNumScrolls <= 0){

          // Hack: Wait and try one more time to scroll before exiting. 
          // Seems like there might be a delay to add stuff to the DOM?
          await wait(150);
          window.scrollBy(0, 10);
          if (this.lastStartY >= window.scrollY){
            break;
          }
        }
        this.lastStartY = startY;
        window.scrollBy(0, 15);
        minNumScrolls--;
        await wait(30);
      }
      this.isScrolling = false;
    }, 
    report(ind){
      const chapterName = this.currentChapter.component;
      console.log('reporting ' + chapterName + ' ' + ind);
      gtag('event', 'statsstory_v1', {
        'event_category': 'read',
        'event_label': 'statsstory_v1' + '-' + chapterName + '-' + ind,
        'value': 1
      });
    },
    toggleVolume(){
  		this.hasVolume = !this.hasVolume;
  		if (this.hasVolume){
  			this.playChapterAudio();
  		} else {
  			this.silenceLoops();			
  		}
    },
    mainClick(event){
      //console.log('click');
      // When you click on the margins, event.target is the "app" node. 
      //this.mouseEvent = event; 

      if (!isDescendant(this.$refs['toc'], event.target)){
        this.showTOC = false;
      }
    },
    toggleTOC(){
  		this.showTOC = !this.showTOC;
    },

  } // end methods
});

</script>