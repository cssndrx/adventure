<!doctype html>


<head>
<meta charset="utf-8" />
<!--<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,400,700,900" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet">-->

<!--
font-family: 'VT323', monospace;
font-family: 'Princess Sofia', cursive;
font-family: 'Indie Flower', cursive;
font-family: 'Dokdo', cursive;
font-family: 'East Sea Dokdo', cursive;
font-family: 'Creepster', cursive;
font-family: 'Bungee Hairline', cursive;
font-family: 'Bungee', cursive;
font-family: 'Bungee Shade', cursive;
font-family: 'Bungee Inline', cursive;
font-family: 'Cormorant Garamond', serif;
-->

<!-- todo: strip and remove the unused -->
<link href="https://fonts.googleapis.com/css?family=Dokdo|Fira+Sans:300,800,900" rel="stylesheet">

<link href="css/animate.css" rel="stylesheet" type="text/css">
<script src="js/lodash.min.js"></script>
<script src="js/d3.v4.min.js"></script>

<script src="js/vue.js"></script>

<script src="js/utils.js"></script>

<style>

*{
  font-family: 'Fira Sans', sans-serif;
  font-size: 18px;
  font-weight: 300;
}

div{
  margin-bottom: 16px;
}
.normal-div, .normal-div div{
  margin-bottom: 0px;
}

/* font-family: 'Gaegu', cursive; -- cute child like handwriting */
/* font-family: 'Dokdo', cursive; -- funky */
/* font-family: 'Bungee Shade', cursive; -- pop art caps */

ul{
  margin-top: 0px;
}

h4{
  font-size: 18px;
  font-weight: 500;
}

a{
  color: #337ab7; /* boostrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}

.nope{
  color:red; 
  font-size: 14px; 
}

.handwriting{
  font-family: 'Dokdo', cursive;    
}

.dialog-text, .dialog-text *{
  font-family: 'Dokdo', cursive;  
  font-size: 32px;
  width:350px;
}

.smaller-dialog-text, .smaller-dialog-text *{
  font-family: 'Dokdo', cursive;  
  font-size: 24px;
}

.centered, .centered *{
  font-size: 22px;
}

button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;

  font-size: 28px;
  font-weight: 900;
  margin-bottom: 8px; 
  padding: 8px 16px;
  margin: 8px;
}

.question button:hover, .question .clicked-button{
  color: white;
  background-color: black;
}


.bold{
  font-weight: 900;
}

.centered{
  display: grid;
  grid-template-columns: 1fr 500px 1fr;
  grid-template-rows: 1fr auto 1fr;
  grid-template-areas: 
    ". . ."
    ". centered-content ."
    ". . .";
  height: 500px;
}

.centered-content {
  grid-area: centered-content;
}

.centered button{
  margin: 0 auto;
  margin-bottom: 8px;
}


.hidden-at-first{
  opacity: 0;
  transition: opacity 1s;
}

.spin-and-pulse{
  position: absolute;
  animation: spin-and-pulse 5s ease 0s 1;
}

@keyframes spin-and-pulse {
  0% {
    transform: rotate(1turn);
  }
  5% {
    transform: rotate(0turn);
  }
  7% {
    transform: scale(1);
  }
  10% {
    transform: scale(1.2);
  }
  13% {
    transform: scale(1);
  }
  15% {
    transform: scale(1.1);
  }
  18% {
    transform: scale(1);
  }
}

.wobble{
  position: absolute;
  animation: wobble 5s ease 0s infinite;
}

@keyframes wobble {
  0% {
    transform: rotate(0turn);
  }
  5% {
    transform: rotate(0.003turn);
  }
  10% {
    transform: rotate(0turn);
  }
  12% {
    transform: rotate(0.003turn);
  }
  15% {
    transform: rotate(0turn);
  }
}

.bounce{
  position: absolute;
  animation: bounce 5s ease 0s infinite;
}

@keyframes bounce {
  0% {
    transform: translateY(20px);
  }
  3% {
    transform: translateY(-30px);
  }
  6% {
    transform: translateY(10px);
  }
  10% {
    transform: translateY(-10px);
  }
  12% {
    transform: translateY(0px);
  }
}

@keyframes mad-bounce {
  0% {
    transform: translateY(20px);
  }
  1% {
    transform: translateY(-30px);
  }
  2% {
    transform: translateY(10px);
  }
  3% {
    transform: translateY(-10px);
  }
  4% {
    transform: translateY(0px);
  }
}
.mad-bounce{
  position: absolute;
  animation: bounce 4s ease 0s infinite;  
}

@keyframes fallover{
  100% {
    transform: rotate(0.3turn);
  }
}

.fallover{
  position: absolute;
  animation: fallover 1s ease-in 0s 1; /* to not stand back up:  normal forwards;  */
}

.active-point{
  background-color: black;
}

.point-container{
  width: 350px;
  display:flex; 
  justify-content:space-between; 
  margin: 0 auto;
}

.point{
  display: inline-block;
  width: 30px;
  height: 30px;
  border-radius: 50%;
  border: 2px solid black;
}

.point:hover{
  background-color: #333;
}

.has-tooltip{
  position: relative;
}

.has-tooltip span{
  display: none;
  position:absolute;
  font-size: 10px;
  top: 24px;
  white-space: nowrap;

  background-color: rgba(0,0,0,0.5);
  padding: 8px;
  border-radius: 8px;
  color: white;
}

.has-tooltip:hover span{
  display: inline-block;
}


.extra-info, .extra-info *{
  font-size: 14px;
}

.smaller-children, .smaller-children *{
  font-size: 12px;
}

/* https://w3bits.com/rainbow-text/ */
.rainbow-text {
  background-image: repeating-linear-gradient(45deg, violet, indigo, blue, green, orange, red, violet);
  text-align: center;
  background-size: 800% 800%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow 4s ease infinite;
}

@keyframes rainbow { 
    0%{background-position:0% 50%}
    50%{background-position:100% 25%}
    100%{background-position:0% 50%}
}

.fade-enter-active, .fade-leave-active {
  transition: opacity 1s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}

.slide-fade-enter-active, .slide-fade-leave-active {
  transition: all .3s ease;
}
.slide-fade-enter, .slide-fade-leave-to {
  transform: translateY(-300px);
  opacity: 0;
}


.story-point-silhouette{
  -webkit-filter: contrast(0%) brightness(50%);
  filter: contrast(0%) brightness(50%);
  cursor: pointer;
}

.story-point-silhouette:hover{
  -webkit-filter: none;
  filter: none;
}


.cropcircle{
    width: 100px;
    height: 100px;
    border-radius: 100%;
/*    background: #000 no-repeat center;*/
    background-size: cover;
    border: 4px solid black;
}


</style>

<body>

<div class="handwriting normal-div" style="font-size:48px; text-align:center">The story so far</div>


<div id="app" style="position:relative">
  <div style="text-align: center">
    <div v-for="(storyPoint, ind) in storyPoints"
         @click="storyPointInd = ind"
         class="has-tooltip"
         style="display:inline-block;">
      <img :class="{'story-point-silhouette': currentStoryPoint !== storyPoint}"
          :src="'images/' + storyPoint.image" 
          style="width:50px">
      <span style="top:60px;">{{storyPoint.name}}</span>
    </div>
  </div>
<!--

<transition name="slide-fade">
<div v-if="show" style="background-color: blue; width:200px; height:200px;"></div>
</transition>

  <button @click="show = !show">
    Toggle render
  </button>


<button class="rainbow-text">Test</button>


<story :visible="true">
Are you here?

If so, you are in the <a @click="show('waiting')">right place</a>.

What is the probability that you will succeed?
</story>

<once-group>
<once-button>1/2</once-button>
<once-button>1/4</once-button>
<once-button>1/8</once-button>
</once-group>


<story ref="waiting">
I have been <a @click="show('changing')">waiting</a> for you. 
</story>

<story ref="changing">
The times are changing.

The prophecies are unclear, but the times are changing.

This planet is <a @click="show('new-world')">changing</a>.
</story>

<story ref="new-world">
<div>
You are going to bring us into this new world of <span class="animated infinite jello" style="display:inline-block">uncertainty</span>.
</div>-->


<!-- <div style="width: 150px; position:absolute; left: 0px; text-align: left; padding-left: 16px">

  <div v-for="storyPoint in storyPoints"
      @click="currentStoryPoint = storyPoint"
      style="margin-bottom: 4px;"
      :style="storyPointStyle(storyPoint)">
    <a :class="[storyPoint === currentStoryPoint ? 'active-tab': 'inactive-tab']">{{storyPoint.name}}</a>
  </div>

</div> -->


<keep-alive>
  <component v-bind:is="currentStoryPoint.component"></component>
</keep-alive>



</div> <!-- end #app -->

<script type="text/x-template" id="coin-flips-template">
<div>

<!-- jump to a diferent problem -->
<div class="point-container">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="{'active-point': point.key == activeOrLastKnownPoint}"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>

<!-- <transition name="fade" mode="out-in">-->

<avatar key="intro"
  v-if="show('intro')"
  image="monster.png" 
  text="Hey player, come over here!"
  :state="avatarState">
  <buton @click="set('HHHHH')">Oblige</buton>
</avatar>

<avatar key="HHHHH"
  v-if="show('HHHHH')"
  image="monster.png" 
  text="I tossed a coin 5 times and it landed HHHHH. What do you think it will land the 6th time?"
  :state="avatarState">

  <template v-slot:hint>
    <div v-if="memory == 'userSaidT'">
      <div>Nope, that's the Gambler's Fallacy... a common misconception that events that haven't occured are more likely to occur.</div>

      <div>Coins have no memory, so just because H came up a lot, doesn't mean that T is more likely to come up in the future.</div>
    </div>

    <div v-if="memory == 'userSaidH'">
      <div>Nope, that's the Hot Hand Fallacy... a common misconception that events that have occurred recently are "hot" and more likely to come up.</div>

      <div>Coins have no memory, so just because H came up a lot, doesn't mean that H is any more likely to come up in the future.</div>
    </div>

  </template>


  <buton @click="memory='userSaidH'" nope>H</buton>
  <buton @click="memory='userSaidT'" nope>T</buton>
  <buton @click="set('HHHHH-finale')" yay>I don't know</buton>
</avatar>

<avatar key="HHHHH-finale"
  v-if="show('HHHHH-finale')"
  image="monster_yay.png" 
  sound="right"
  text="Yeah! The correct answer is that there's no way to tell."
  :state="avatarState">
  <buton @click="set('HH')">Next</buton>
</avatar>

<interstitial 
    image="monster.png"
    key="independence" 
    v-if="show('independence')">
  <div>
    Coin flips are <bold>independent events</bold>.
  </div>

  <div>
    Meaning that knowing the result of one event does not give you information about the other events. Which of these is another example of an independent event?
  </div>

  <buton nope>Applying to jobs</buton>
  <buton @click="set('HH')" yay>Rolling dice</buton>
  <buton nope>Winning a lottery</buton>
  <buton nope>Drawing a nice picture</buton>

</interstitial>

<avatar key="HH"
  v-if="show('HH')"
  image="monster.png" 
  text="What is the probability that I toss a coin twice and get HH?"
  :state="avatarState">
  <buton nope="1/2 is the probability of tossing a single coin and getting H. Getting two heads in a row must be less than that.">1/2</buton>
  <buton @clik="set('HHH')" yay>1/4</buton>
  <buton nope="It is possible to say if you assume it is  a fair coin.">Can't say</buton>
</avatar>

<interstitial 
  key="HH-explanation" 
  v-if="show('HH-explanation')">
  <div>
    The probability of multiple independent events all occuring can be calculated by multiplication. This is called the probability of the <bold>joint event</bold>. So, the chance of getting HH is 1/2 x 1/2.
  </div>

  <div>
    Another way to see this is that there are 4 possible outcomes:

    <div style="margin-top:16px">
    HH<br>
    HT<br>
    TH<br>
    TT<br>
    </div>

    If we only care about the HH outcome, our probability of getting it is 1/4.
  </div>
  <buton @click="set('HHH')">Next</buton>
</interstitial> 

<avatar key="HHH"
  v-if="show('HHH')"
  image="monster.png" 
  text="What is the probability that I toss a coin three times and get HHH?"
  :state="avatarState">
  <buton nope>1/2</buton>
  <buton nope>1/3</buton>
  <buton @clik="set('10H')" yay>1/8</buton>
  <buton nope>Can't say</buton>

  <template v-slot:hint>
    <div>
      By the same logic as before, coin flips are independent events (i.e. a result doesn't affect the next result). The probabilities of the joint event: seeing X AND Y can be combined with multiplication. The chance of getting HHH is 1/2 x 1/2 x 1/2.
    </div>

    <div>
      Another way to see this is that there are 8 possible outcomes:

      HHH
      HHT
      HTH
      HTT
      THH
      THT
      TTH
      TTT

      If we only care about the HHH outcome, our probability of getting it is 1/8.
    </div>
  </template>
</avatar>


<avatar key="10H"
  v-if="show('10H')"
  image="monster.png" 
  text="What is the probability that I toss a coin 10 times and get HHHHHHHHHH?"
  :state="avatarState">
  <buton @clik="set('10HT')" yay>1/(2^10)</buton>
  <buton nope>1/2</buton>
  <buton nope>1/10</buton>
  <buton nope>1/20</buton>
  <buton nope>Can't say</buton>

  <template v-slot:hint>
    <div>
      Remember that independent events can be combined with multiplication.
    </div>

    <div>
      So the chance of getting HHHHHHHHHH is ....

      (big fraction) approx .01%
    </div>
  </template>
</avatar>


<avatar key="10HT"
  v-if="show('10HT')"
  image="monster.png" 
  text="What is the probability that I toss a coin 10 times and get HHHTHHTTTT?"
  :state="avatarState">
  <buton @clik="set('10HT-interstitial')" yay>1/(2^10)</buton>
  <buton nope>1/2</buton>
  <buton nope>1/10</buton>
  <buton nope>1/20</buton>
  <buton nope>Can't say</buton>
</avatar>

<interstitial 
    image="monster.png"
    key="10HT-interstitial" 
    v-if="show('10HT-interstitial')">
  <div>
    The chance of getting HHHTHHTTTT is the same as the probability of getting HHHHHHHHHH.
  </div>

  <div>
    Isn't it cool that it's the same probability as before?
  </div>

  <buton @click="set('100H')">Next</buton>
</interstitial>


<avatar key="100H"
  v-if="show('100H')"
  image="monster.png" 
  text="I have one final question. The other day I tossed a coin 100 times and it landed heads all 100 times! What do you think it will land on the 101-st time?"
  :state="avatarState">

  <buton-group :onClick="() => avatarState.showNewText=true">
    <buton yay>H</buton>
    <buton>T</buton>
    <buton>I don't know</buton>
  </buton-group>

  <template v-slot:new-text>
    Har-har! That was a trick question{{got('100H') ? ' but you got it!': '.'}} The probability of this happening on a fair coin is 1/2^100. If all the 2^80 atoms in the universe were flipping coins, this still probably wouldn't happen. So the coin must not be fair. 
  </template>

  <template v-slot:new-question>
    <buton @click="set('congrats')">Next</buton>
  </template>
</avatar>


<! -- Teehee thanks for playing with me! -->
<centered key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about <bold>independent events</bold> (two events that don't affect each other)</li>
    <li>You learned how to calculate the <bold>joint probability</bold> of independent events (you multiply)</li>
    <li>You learned that there are 2^80 atoms in the universe.</li>
  </ul> 

  <buton @click="$root.nextStory()">Next section</buton>
</centered>

<!-- </transition> -->

</div>
</script>

<script type="text/x-template" id="chain-rule-template">

<div>

<!-- jump to a diferent problem -->
<div class="point-container">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="{'active-point': point.key == activeOrLastKnownPoint}"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>

<!--<transition name="fade" mode="out-in">-->

<avatar key="intro"
  v-if="show('intro')"
  image="girl0.png" 
  text="Hello! I'm Veronica and I only date monsters that are tall and have great hair."
  :state="avatarState">
  <buton @click="set('problem0')">Next</buton>
</avatar>

<avatar key="problem0"
  v-if="show('problem0')" 
  image="girl1.png" 
  text="If 1/2 of all monsters are tall, and 1/4 of monsters have great hair, what is the probability that a random monster is datable?"
  :state="avatarState">

  <buton-group :onClick="() => avatarState.showOverlay=true">
    <buton>1/8</buton>
    <buton nope="Why 1/3? Try again.">1/3</buton>
    <buton nope="That doesn't make sense. 3/4 is more than the number of monsters that are tall. Try again.">3/4</buton>
    <buton yay>Can't say</buton>
  </buton-group>

  <template v-slot:overlay>
    <div v-if="got('problem0')">
      Right! It's not possible to say. 
    </div>
    <div v-else>
      It's actually not possible to say.
    </div>

    <div>
      P(tall AND great hair) ≠ P(tall) * P(great hair) in general.
    </div>

    <div>
      It is valid to multiply only when tallness and having great hair are <bold>independent</bold>. 
    </div>

    <div>
      Independence occurs when a monster's height provides <bold>no information</bold> on the monster's greatness of hair.
    </div>

    <buton @click="set('problem1')">Next</buton>
  </template>

</avatar>


<avatar key="problem1" 
        v-if="show('problem1')"
        image="girl0.png" 
        text="Yeah! I guess being tall and having great hair are slightly correlated. About 1/3 of tall monsters have great hair."
        :state="avatarState">

  <template v-slot:question>
    <div>What is the probability that a random monster is datable?, i.e. Is tall AND has great hair?</div>

    <div class="extra-info">Facts from before:
    <ul>
      <li>1/2 of all monsters are tall</li>
      <li>1/4 of all monsters have great hair</li>
    </ul>
    </div>


    <buton-group :onClick="() => avatarState.showOverlay=true">
      <buton yay>1/6</buton>
      <buton nope="We said that being tall and having great hair are not independent, so we cannot multiply 1/2 x 1/4.">1/8</buton>
      <buton nope="Are you just multiplying things together? Try again.">1/24</buton>
      <buton nope="The answer isn't always 'Can't say'...">Can't say</buton>
    </buton-group>
  </template>

  <template v-slot:overlay>
    <div>
      {{ got('problem1') ? 'Right.': 'Not quite.' }}
    </div>

    <div>
      The probability that a monster has great hair AND is tall, combines:
    </div>

    <div>
      (1) The probability the monster is tall: P(tall)
    </div>

    <div>
      (2) The probability the monster has great hair, given that the monster is tall: P(great hair | tall)
    </div>

    <div>
      P(great hair AND tall) = P(tall) * P (great hair | tall)
    </div>

    <buton @click="set('problem2')">Next</buton>
  </template>
</avatar>


<avatar key="problem2"
        v-if="show('problem2')"
        image="girl0.png"
        text="Oh thank you for your help so far. But I forgot... I also want them to have tattoos. 1/5 of monsters have tattoos."
        :state="avatarState">
  <div>What is P(tall, great hair, tattoos)?</div>

  <div class="extra-info">Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
    </ul>
  </div>

  <buton-group :onClick="() => avatarState.showOverlay=true">
    <buton nope>1/30</buton>
    <buton nope="Remember, we want to use P(great hair|tall), not P(tall).">1/40</buton>
    <buton nope="Wait, are you just blindly multiplying numbers? Stop that.">1/120</buton>
    <buton yay>Can't say</buton>
  </buton-group>

  <template v-slot:overlay>
    <div>
      {{ got('problem2') ? 'Right.': 'Not quite.' }} Again, it's not possible to say!
    </div>

<!--     <div> assumed independence
      Blindly multiplying P(tall) * P(great hair) * P(tattoos) assumes the events are independent. It doesn't work if any of the variables are very positively or negatively correlated.
    </div>

    <buton>How to do this properly?</buton>
 -->
    <div>
      To do this properly, use the logic in the <bold>Chain Rule</bold>:
    </div>

    <div class="smaller-children" style="margin-left: 16px;">
      <div style="color:magenta">
        First, consider the probability of the monster being tall.
      </div>

      <div style="color:green">
        Then, consider the probability of a tall monster having great hair.
      </div>

      <div style="color:blue">
        Then, consider the probability that a tall monster with great hair... would have a tattoo.
      </div>
    </div>

    <div>
      Multiply together to filter down to monsters that are tall and have great hair and have tattoos.
    </div>

    <div>
      Mathematically, this is written out as:
    </div>

    <div class="smaller-children">
      P(tattoo AND great hair AND tall) = <span style="color:magenta">P(tall)</span> * <span style="color:green">P(great hair | tall)</span> * <span style="color:blue">P(tattoo | great hair AND tall)</span>
    </div>

    <buton @click="set('problem3')">Try it</buton>

  </template>

</avatar>


<avatar key="problem3" 
        v-if="show('problem3')"
        image="girl1.png" 
        text="Ooh yeah I've heard of the Chain Rule. Here are some numbers."
        :state="avatarState">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li>Veronica only dates tall monsters with great hair and tattoos</li>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
      <li>P(tattoos) = 1/5</li>
      <li>P(tattoos|tall) = 1/6</li>
      <li>P(tattoos|tall AND great hair) = 1/7</li>
    </ul>
    </div>

    <div>
    P(tall, great hair, tattooed) =  1/<input-box :right="42" :onRight="() => set('problem4')"/>
    </div>

</avatar>


<avatar key="problem4" 
        v-if="show('problem4')"
        image="girl1.png" 
        text="Silly us! We forgot to include that these tall, great hair, tattooed monsters also need to be... around my age and single."
        :state="avatarState">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li>Veronica only dates monsters that are tall, have great hair, tattoos, around her age, and single</li>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
      <li>P(tattoos) = 1/5</li>
      <li>P(tattoos|tall) = 1/6</li>
      <li>P(tattoos|tall AND great hair) = 1/7</li>
      <li>P(around her age|tall AND great hair AND tattoos) = 1/5</li>
      <li>P(single|tall AND great hair AND tattoos AND around her age) = 1/2</li>
    </ul>
    </div>

    <div>
    P(tall, great hair, tattooed, around her age, single) =
    </div>

    1/<input-box :right="420" :onRight="() => set('not-many')"/>
</avatar>


<avatar key="not-many"
        v-if="show('not-many')"
        animation="mad-bounce"
        image="girl_mad.png" text="That's not very many people!">

  <div>
    Even though each individual criteria may not seem picky, requiring that a monster have all those traits leaves Veronica with a very small dating pool.
  </div>

  <buton @click="set('congrats')">Next</buton>
</avatar>



<centered key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about independence</li>
    <li>You learned about Chain Rule</li>
    <li>You befriended Veronica ❤️</li>
  </ul> 

  <buton @click="$root.nextStory()">Next section</buton>
</centered>

</transition>

</div>

</script>

<script type="text/x-template" id="risk-reward-template">
<div>

<!-- jump to a diferent problem -->
<div class="point-container" style="width:220px">
  <div v-for="point in points" 
  @click="set(point.key)" 
  class="point has-tooltip" 
  :class="{'active-point': point.key == activeOrLastKnownPoint}"
  :style="pointStyle(point)">
    <span>{{point.name}}</span>
  </div>
</div>


<!--<transition name="fade" mode="out-in">-->

<avatar key="intro"
  v-if="show('intro')"
  image="bear.png" 
  text="Do you dare play with a bear???"
  :state="avatarState">
  <buton @click="set('ev')">Yes</buton>
</avatar>

<avatar key="ev"
  v-if="show('ev')"
  image="bear.png" 
  text="What would you rather? (a) I pay you 1 coin or... (b) I pay you 4 coins with 20% certainty, and 80% of the time you get nothing."
  :state="avatarState">
  <buton @click="set('ev-right')" yay>(a) 1 coin with certainty</buton>
  <buton @click="set('ev-wrong'); delay(() => avatarState.showOverlay=true, 3000)" nope>(b) 4 coins with 20% certainty</buton>
</avatar>

<avatar key="ev-right"
  v-if="show('ev-right')"
  image="bear.png" 
  text="Well, that's correct."
  :state="avatarState">

  <template v-slot:question>
    <div>
     On average, the 4 coins with 20% probability is only worth 0.8 coins on average, so the 1 coin with certainty is worth more.
    </div>

    <buton @click="set('100')">Next</buton>
  </template>
</avatar>

<avatar key="ev-wrong"
  v-if="show('ev-wrong')"
  image="bear_money.png" 
  text="Heh heh ."
  animation="spin-and-pulse"
  :state="avatarState">

  <template v-slot:overlay>
    <div>
      Player! Your answer was incorrect.
    </div>

    <div>
      On average, the 4 coins with 20% certainty is only worth 0.8 coins.
    </div>

    <div>
      AND it's riskier because the payout isn't guaranteed.
    </div>

    <div>
      By the risk-reward tradeoff, you ought to be compensated for extra risk with higher average reward.
    </div>

    <div style="font-size: 10px">
      The bear offered a bum deal because 4 coins with 20% probability was higher risk and lower average reward.
    </div>

    <buton @click="set('100')">Next</buton>
  </template>
</avatar>

<avatar key="100"
  v-if="show('100')"
  image="bear.png" 
  text="What if I offered you the chance to pick one choice and play 100 times? Which would you pick?"
  :state="avatarState">
  <buton @click="set('100-right');" yay>(a) 1 coin with certainty</buton>
  <buton @click="set('100-wrong'); delay(() => avatarState.showOverlay=true, 3000)" nope>(b) 4 coins with 20% certainty</buton>
</avatar>


<avatar key="100-right"
  v-if="show('100-right')"
  image="bear.png" 
  text="Yeah, that's correct."
  :state="avatarState">

  <template v-slot:question>
    <div>
     Playing 100 times doesn't change the fact that 4 coins with 20% probability has the lower expected value.
    </div>

    <buton @click="set('100-chart')">Next</buton>
  </template>
</avatar>

<avatar key="100-wrong"
  v-if="show('100-wrong')"
  image="bear_money.png" 
  text="Heh. Wrong."
  animation="spin-and-pulse"
  :state="avatarState">

  <template v-slot:question>
    <div>
     Playing 100 times doesn't change the fact that 4 coins with 20% probability has the lower expected value.
    </div>

    <buton @click="set('100-chart')">Next</buton>
  </template>
</avatar>

<centered key="100-chart"
  v-if="show('100-chart')">
  <div>
  Running a simulation where a computer really executes the 4 coins with 20% probability deal 100 times, yields... (chart)
  </div>
  
  <div>
    We see the average result is near 80, although random variation resulted in totals near 60 and 100. But in __% of casses, taking the guaranteed 100 coins would have been a better choice.
  </div>

  <div>
    This is a sneak peak of the Binomial Distribution which you will see later in this adventure. Statisticians have invented distributions to model many common scenarios. 
  </div>

  <buton @click="set('congrats')">Stats is cool</buton>
</centered>

<centered key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about expected value (the average)</li>
    <li>You got a sneak peak of the usefulness statistical distributions</li>
  </ul> 

  <buton @click="$root.nextStory()">Next section</buton>
</centered>

<!--</transition> -->
</div>
</script>


<!-- begin templates -->
<script type="text/x-template" id="interstitial-template">
<centered>
   <div class="cropcircle" style="margin:0 auto; margin-bottom:16px" :style="cropCircleStyle"></div>
  <slot></slot>
</centered>
</script>


<script type="text/x-template" id="centered-template">
<div class="centered">
  <div class="centered-content"><slot></slot></div> 
</div>
</script>

<script type="text/x-template" id="bold-template">
<span class="bold"><slot></slot></span> 
</script>


<script type="text/x-template" id="avatar-template">
<div style="position: relative; height: 500px; width:800px; margin:0 auto; margin-top:16px">

<!-- overlay-->
<transition name="slide-fade">
<div v-if="state.showOverlay && hasSlot('overlay')"
     style="position:absolute; z-index:1; height: 500px; width:100%; opacity:0.9; background-color: white; color:black;">
  <centered>
      <slot name="overlay"></slot>
  </centered>
</div>
</transition>


<img v-if="state.showRainbow" src="images/rainbow.png">

<img :src="imgSrc" 
     :class="imgClasses"
     style="height: 300px; left: 80px; position:absolute; top:0px;">


<!-- Dialog box -->
<div style="position:absolute; left: 300px; top:0px;"
  v-if="showLiveText">
  <img src="images/dialog.png" >
  <div style="position: absolute; left:40px; top:23px;" class="dialog-text"
  :class="{'smaller-dialog-text': text.length > 140}">
    <live-text  
        key="initial-text"
        v-if="!state.showNewText" @live-text-complete="showQuestion=true">
      {{text}}
    </live-text> 

    <live-text 
        key="new-text"
        v-if="state.showNewText"
        @live-text-complete="showNewQuestion=true">
        <slot name="new-text"></slot>
    </live-text>
  </div>
</div>

<!-- Mini dialog -->
<div v-if="showMiniDialog" style="position:absolute; left: 100px; top:300px;">
  <img src="images/mini_dialog.png" style="width:150px">
  <div style="position: absolute; left:40px; top:40px;" class="smaller-dialog-text">
    Yep!
  </div>
</div>

<!-- Bottom right -->
  <div class="question" style="position:absolute; left: 100px; top: 300px; width: 500px;">

    <!-- Show hint via nopeText or nope slot -->
    <div v-if="nopeText" 
         class="nope" style="margin-top:24px">{{nopeText}}</div>
    <transition name="fade">
      <div v-if="showHint" class="nope">
        <slot name="hint"></slot>
      </div>
    </transition>


  <transition name="fade" mode="out-in">  
    <div v-if="showQuestion && !showNewQuestion">  
      <slot name="question"></slot>
      <slot></slot> <!-- todo: consider removing default slot -->
    </div>

    <slot v-if="showNewQuestion" name="new-question"></slot>
  </transition>

  </div>

</div>
</script>



<script type="text/x-template" id="story-template">
<div v-if="isVisible"><slot></slot></div>
</script>

<script type="text/x-template" id="live-text-template">
  <div>
    <transition-group name="fade" tag="span">
      <span v-for="(token, i) in visibleTokens" :key="i" v-html="token">
      </span>
    </transition-group>
  </div>
</script>


<script type="text/x-template" id="monk-head-template">
<div class="handwriting normal-div"
      style="display:inline-block; position:relative; white-space: nowrap;">
  <img src="images/monk_head.png" style="width:80px;">

  <!-- speech pointing to left -->
  <div v-if="hasSlot('lhs')">
    <div style="width:22px; border:1px solid black; transform:rotate(50deg); position:absolute; top:-14px; left:10px;"></div>
    <div style="position:absolute; top: -40px; left:0px;">
      <slot name="lhs"></slot>
    </div>
  </div>

  <!-- speech pointing to right -->
  <div v-if="hasSlot('rhs')">
    <div style="width:24px; border:1px solid black; transform:rotate(310deg); position:absolute; top:-14px; left:50px;"></div>
    <div style="position:absolute; top: -40px; left: 60px;">
      <slot name="rhs"></slot>
    </div>
  </div>

</div>
</script>


<script type="text/x-template" id="buton-template">
<span style="margin-bottom:0px; position:relative; display:inline-block">
  <div v-if="showX" 
       class="handwriting" 
       style="display:inline-block; position:absolute; color:red; font-size: 64px; left: calc(50% - 20px); top:-4px">X</div>
  <button @click="butonClicked()" v-on="$listeners" :class="{'rainbow-text': showRainbowText, 'clicked-button': clickedButton}"><slot></slot>
  </button>
<!--  <transition name="fade">
    <div v-if="showNopeText" class="nope" style="margin-bottom:8px; position:relative; top:-4px;">
      {{nope}}
    </div>
  </transition>-->
</span>
</script>


<script type="text/x-template" id="input-box-template">
  <div style="display:inline-block; position:relative;">
    <input v-model="val" placeholder="?" style="width:50px; display:inline">
    <buton style="display:inline" @click="answerSubmit">Go</buton>
  
    <transition name="fade">
      <span v-if="showNopeText" class="nope" style="position:absolute; bottom: -8px; margin-bottom:0px">
        {{nopeText}}
      </span>
    </transition>
  </div>
</script>


<!-- end templates -->


<script>

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();

var sounds = {
  'speech': {clip: new Audio('sounds/speech.wav')},
  'buton': {clip: new Audio('sounds/button.wav')},
  'wrong': {clip: new Audio('sounds/wrong.wav')},
  'chimes': {clip: new Audio('sounds/chimes.wav')},

  // 'right': {clip: new Audio('sounds/right_soft.wav'), duration: 1000},
  'right': {clip: new Audio('sounds/swish1.wav')},

  'curious': {clip: new Audio('sounds/curious.wav')},
};

Vue.component('input-box', {
  props: {
    right: {type: Number, default: 0},
    hints: {
      type: Array, 
      default: function(){ return ['Try again']; },
    },
    onRight: {
      type: Function,
      default: function(){},
    },
  },
  computed: {
    nopeText: function(){
      return this.hints[Math.min(this.numWrong, this.hints.length-1)];
    }
  },
  data: function(){
    return {
      val: null,
      showNopeText: false,
      numWrong: 0,
    }
  },
  methods: {
    answerSubmit: function(){
      // look at the value in the input.
      if (this.val == this.right){
        this.showNopeText = false;
        this.onRight();
      } else {
        this.numWrong++;
        this.showNopeText = true;
      }
    }
  },
  template: '#input-box-template'
});

function firstAncestorOfComponent(node, componentName){
  while(node !== undefined){
    node = node.$parent;
    if (node !== undefined && node.$options.name === componentName){
      return node;
    }
  }
  return undefined;
}

function isDescendant(ancestor, maybeChild){
  var node = maybeChild.$parent;
  while(node !== undefined){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }
  return false;
}

Vue.component('avatar', {
  props: {
    image: {type: String}, // 'girl.png'
    text: {type: String},
    animation: {type: String, default: 'wobble'},
    sound: {type: String},

    // Events that get triggered from parent.
    state: {type: Object, default: function() { 
      return {
        showOverlay: false, showRainbow: false, showFall: false, showNewText: false}; 
      }
    },
  },
  data: function(){
    return {
      // Internally triggered events.
      showQuestion: false,
      showNewQuestion: false,

      showMiniDialog: false,
      showLiveText: false,
      showHint: false,

      reactionImage: null,
      nopeText: null,
    };
  },

  mounted: async function(){
    // Add a blink
    var this_ = this;

    if (this.sound){
      this.$root.play(this.sound);
      await wait(sounds[this.sound].duration || 500);
    }

    await wait(500);
    this_.showLiveText = true;


    bus.$on('buton-clicked', async function(buton){
      // <buton nope="why not">
      this_.handleNopeButon(buton);
    });

    // setInterval(async function(){
    //   // change it to the blink
    //   console.log('blinking');
    //   this_.reactionImage = 'monster_blink.png';
    //   await wait(100);
    //   this_.reactionImage = null;
    // }, 3000);
  },
  computed: {
    imgClasses: function(){
      var classes = {fallover: this.state.showFall};
      classes[this.animation] = true;
      return classes;
    },
    imgSrc: function(){
      return 'images/'+ (this.reactionImage || this.image);
    }
  },

  methods: {
    hasSlot: function(name){
      return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
    },
    handleNopeButon: function(buton){
      // when the player clicks on a nope button, if the button has nope text, that is rendered.
      // otherwise, if the avatar has a hint slot that is shown. 

      if (buton.nopeText){  
        this.nopeText = buton.nopeText;        
      } else if(buton.isNope && this.hasSlot('hint')){
        this.showHint = true;
      }

    }
  },
  template: '#avatar-template'
});


// Just like a button, but with some special abilities.
// When clicked it looks at it's parent to see if it's a buton-group.
// Executes the onClick event if so.
// e.g.
// <buton-group onClick="doSomethingSecond">
//   <buton @click="doSomethingFirst">Click me</buton>
// </buton-group>

// However, if the buton is a nope buton the buton-group does not get triggered.
// <buton nope="stop and think">Tricked ya</buton>
// <buton nope>Tricked ya</buton>

// Buttons may also have a yay attribute.
// Which causes the button to turn rainbow-text after it gets clicked.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.

    // moved to attr
    //yay: {type: Boolean, default:false}, // Causes cool animation to happen when clicked.
  },
  data: function(){
    return {
      showNopeText: false,
      showRainbowText: false,
      showX: false,
      clickedButton: false,
    }
  },
  computed: {
    nopeText: function(){
      return this.nope;
    },
    // Returns true for: <buton nope> or <buton nope="why not">
    isNope: function(){
      return this.nope || this.nope==="";
    },
    isYay: function(){
      return 'yay' in this.$attrs;
    },
  },
  methods: {
    butonClicked: async function(){
      this.$root.play('buton');
      this.clickedButton = true;

      // Mark the buton as wrong.
      if (this.isNope){
        this.showX = true;
      }

      // Tell those listening on the bus that the buton has been clicked.
      bus.$emit('buton-clicked', this);

      await wait(1000);
      this.$emit('clik');


      if (!this.isNope && this.$parent.onClick !== undefined){
        // Add delay so any custom handlers on the buton execute before the generic buton-group executes.
        await wait(1000);
        this.$parent.onClick();        
      }

    },
  },
  template: '#buton-template'
});

Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  template: '<div><slot></slot></div>'
});


Vue.component('centered', {
  template: '#centered-template'
});

Vue.component('bold', {
  template: '#bold-template'
});

Vue.component('interstitial', {
  props: {
    image: {type: String, default: 'monster.png'}, 
  },
  computed: {
    cropCircleStyle: function(){
      return {'background-image': 'url("images/' + this.image + '")'};
    }
  },
  mounted: function(){
    this.$root.play('chimes');
  },
  template: '#interstitial-template'
});

function makeComponent(componentName, points){
  Vue.component(componentName, {
    data: function(){
      return {
        active: 'intro',
        lastActive: 'intro',

        points: points, // jump points in the story

        problemsRight: new Set(), // 'problem0' (use string key)
        problemsWrong: new Set(),

        memory: null, // A variable for dumping short term component state.

        avatarState: {
          showRainbow: false,
          showFall: false,
          showOverlay: true, 
          showNewText: false,       
        },
      };
    },
    computed: {
      activeOrLastKnownPoint: function(){
        if (points.map(d => d.key).indexOf(this.active) > -1){
          return this.active;
        }  
        return this.lastActive;
      }
    },
    mounted: async function(){
      var this_ = this;
      bus.$on('buton-clicked', async function(buton){
        // Have avatar react based on buton attributes.
        var avatar = firstAncestorOfComponent(buton, 'avatar');
        if (!avatar){
          // The buton was not used within an avatar, but something else.
          return;
        }
        var problemKey = avatar.$vnode.data.key;

        // If there's a yay.
        if (buton.isYay){
          avatar.reactionImage = 'monster_yay.png';          
          this_.problemsRight.add(problemKey);
          this_.$root.play('right');

          // If the user got it on their first try, show a rainbow.
          if (!this_.problemsWrong.has(problemKey)){
            this_.avatarState.showRainbow = true; 
          }
        }
        
        // just a naked <buton nope>
        if (buton.isNope){
          avatar.reactionImage = 'monster_cry.png';          
          this_.problemsWrong.add(problemKey);
        } 
      });
    },
    methods: {
      print: function(thing){
        console.log(thing);
      },
      show: function(id){
        return true;
//        return id == this.active;
      }, 
      got: function(id){
        return this.problemsRight.has(id);
      },
      set: async function(id, optionalDelay){
        this.lastActive = this.active;
        console.log('setting: ' + id);
        // do the animationss
        // this.avatarState.showRainbow = true;
        // this.avatarState.showFall = true;
        // this.avatarState.showOverlay = true;
        if (optionalDelay !== undefined){
          console.log('started waiting');
          await wait(optionalDelay);        
          console.log('done waiting');
        }

        this.active = id;
        // Reset avatar state.
        // console.log('reseting state');
        this.avatarState = {
          showRainbow: false,
          showFall: false,
          showOverlay: false,
          showNewText: false,        
        };
      },
      delay: async function(fn, ms){
        await wait(ms);
        fn();
      },
      pointStyle: function(point){
        if (this.problemsRight.has(point.key) && !this.problemsWrong.has(point.key)){
          return {
            'background-image' : "url('images/rainbow.png')",
            'background-size': 'cover'
          };
        } 
      },
    },
    template: '#' + componentName + '-template'
  });
}

// Joint prob with independence
//makeComponent('demo', []);

makeComponent('coin-flips', [
  { key: 'intro', name: 'Intro', },
  { key: 'HHHHH', name: '5 heads', },
  { key: 'HH', name: 'Probability of 2 heads', },
  { key: 'HHH', name: 'Probability of 3 heads', },
  { key: '10H', name: 'Probability of 10 heads', },
  { key: '10HT', name: 'Probability of 10 heads and tails', },
  { key: '100H', name: '100 heads', },
  { key: 'congrats', name: 'Congrats', },
]); 

// Conditional prob + join prob with chain rule
makeComponent('chain-rule', [
  { key: 'intro', name: 'Intro', },
  { key: 'problem0', name: 'Independence', },
  { key: 'problem1', name: 'Conditional probability', },
  { key: 'problem2', name: 'Tattoos', },
  { key: 'problem3', name: 'Chain Rule', },
  { key: 'problem4', name: 'Chain Rule 5', },
  { key: 'not-many', name: 'Aww', },
  { key: 'congrats', name: 'Congrats', },
  ]); 

// EV
makeComponent('risk-reward', [
  { key: 'intro', name: 'Intro', },
  { key: 'ev', name: 'EV', },
  { key: '100', name: 'EV 100', },
  { key: '100-chart', name: 'Binomial distribution', },
  { key: 'congrats', name: 'Congrats', },
]); 



// Can be used to delay logic
// <delay></delay>
Vue.component('delay', {
  props: {
    ms: {type: Number, default: 500},
    hidden: {type: Boolean, default: false},
  },
  data: function(){
    return {
      shouldShow: false,
    }
  },
  mounted: function(){
    var this_ = this;
    setTimeout(function(){
      this_.shouldShow = true;
    }, this.ms);
  },
  template: `<span v-if="shouldShow"><slot></slot></span>`,
});


// Hides content until it is revealed as part of the story.
Vue.component('story', {
  props: {
    visible: {type: Boolean, default:false},
  },
  data: function(){
    return {
      isVisible: this.visible,
    };
  },
  watch: {
    isVisible: scrollWindow,
  },
  template: '#story-template'
});


/*

How should this work:
- split the text into words
- inject the words in via setinterval
- add a transition component that makes it fade in when it is injected
*/
Vue.component('live-text', {
  props: {
    interval: {type: Number, default: 1000},
  },

  render: function (createElement) {
    var data = [];

    for (var i=0; i<this.$slots.default.length; i++){
      var vnode = this.$slots.default[i];

      if (vnode.tag){
        data.push([vnode.tag, vnode.data, vnode.children])
      } else if (vnode.text){
        var tokens = vnode.text.split(' ').filter(token => token);
        data = _.concat(data, tokens.map(token => ['span', {}, token + ' ']));
      }
    }

    var vnodes = data.map(function(tuple, i){
      const tag = tuple[0];
      const nodeData = tuple[1];
      const children = tuple[2];
      const meta = {
        ref: i, 
        class: { 'hidden-at-first': true }
      };

      return createElement(tag, _.merge(meta, nodeData), children);
    });

    return createElement(
      'div',   // tag name
      vnodes, 
    )
  },

  data: function(){
    return {
      visibleTokens: [],
    };
  },

  mounted: async function(){
    console.log('mounting live text');
    var elts = _.values(this.$refs);

    function pauseDuration(text){
      const short = 100;
      const med = 500;
      const long = 1000;
      if (!text){
        return short;
      }
      if (text.includes('.') || text.includes('?') || text.includes('!')){
        return long;
      }
      if (text.includes(')')){
        return med;
      }
      return short;
    }

    this.$root.play('speech');
    for (var i=0; i<elts.length; i++){
      var elt = elts[i];
      elt.style.opacity = 1;

      // Pause.
      var duration = pauseDuration(elt.textContent);
      if (duration == 1000){
        this.$root.pause('speech');
      }
      await wait(duration);
      if (duration == 1000){
        this.$root.play('speech');
      }
    }

    this.$root.pause('speech');
    this.$emit('live-text-complete');
  },

  template: '#live-text-template'
});

var storyPoints = [
{
  name: 'Coin Flips',
  component: 'coin-flips',
  image: 'monster.png',
},
{
  name: 'Chain Rule',
  component: 'chain-rule',
  image: 'girl0.png',
},
{
  name: 'Risk Reward',
  component: 'risk-reward',
  image: 'bear.png',
},

];

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {

    storyPoints: storyPoints,
    storyPointInd: 0,

    sounds: {
       'text-blip-high': new Audio('sounds/text-blip-high.ogg')
    },

    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    //soundNameToCount: {},

    show: false,
    isPlaying: false,
  },

  computed: {
    currentStoryPoint: function(){
      return this.storyPoints[this.storyPointInd];
    }
  },
  // watch: {
  //   currentStoryPoint: function(){
  //     this.$root.play('swish');
  //   },
  // },

  methods: {
//    show: show, 
    renderAsPercent: renderAsPercent,

    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,
    nextStory: function(){
      this.storyPointInd = Math.min(this.storyPoints.length-1, this.storyPointInd+1);
    },

    // // Changes tabs.
    // setStoryPoint: function(componentName){
    //   var story_point = _.filter(storyPoints, {component: componentName});
    //   if (story_point.length !== 1){
    //     console.error('must match exactly one story point');
    //     debugger;
    //   }
    //   this.currentStoryPoint = story_point[0];
    //   this.play('achievement0');
    // },

    // // Given 0.8 --> returns {}
    // paramsFromCertainty: function(certainty){
    //   if (certainty == 1.0){
    //     return {
    //       numLoseIfWrong: 10000000, 
    //       numWinIfRight: 1,
    //       certainty: certainty,
    //       percent: '100%',
    //     };
    //   }
    //   return {
    //     numWinIfRight: 1, 
    //     numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
    //     certainty: certainty,
    //     percent: this.renderAsPercent(certainty)
    //   };      
    // },

    // paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
    //   var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
    //   return this.paramsFromCertainty(certainty);
    // },

    play: function(soundName){
      console.log('playing ' + soundName);
      var sound = sounds[soundName].clip;
      sound.play();
    },
    pause: function(soundName){
      console.log('pausing');
      var sound = sounds[soundName].clip;
      sound.pause();
      sound.currentTime = 0;      
    }
  } // end methods
});

</script>