<!doctype html>
<meta charset="utf-8" />

<head>
<!--<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,400,700,900" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet">-->

<!--
font-family: 'VT323', monospace;
font-family: 'Princess Sofia', cursive;
font-family: 'Indie Flower', cursive;
font-family: 'Dokdo', cursive;
font-family: 'East Sea Dokdo', cursive;
font-family: 'Creepster', cursive;
font-family: 'Bungee Hairline', cursive;
font-family: 'Bungee', cursive;
font-family: 'Bungee Shade', cursive;
font-family: 'Bungee Inline', cursive;
font-family: 'Cormorant Garamond', serif;
-->

<!-- todo: strip and remove the unused -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Bungee|Bungee+Hairline|Bungee+Inline|Bungee+Shade|Cormorant+Garamond|Creepster|Dokdo|East+Sea+Dokdo|Indie+Flower|Princess+Sofia|VT323" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=East+Sea+Dokdo|Gaegu:300,400,700|Montserrat:300,400|Open+Sans|Raleway|Roboto+Slab" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Eagle+Lake|Lato|Raleway" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Fira+Sans:300,800,900" rel="stylesheet">

<link href="css/animate.css" rel="stylesheet" type="text/css">
<script src="js/lodash.min.js"></script>
<script src="js/d3.v4.min.js"></script>

<script src="js/vue.js"></script>

<script src="js/utils.js"></script>
<script src="js/forest.js"></script>

<style>

*{
  font-family: 'Fira Sans', sans-serif;
  font-size: 18px;
  font-weight: 300;
}

div{
  margin-bottom: 16px;
}

/* font-family: 'Gaegu', cursive; -- cute child like handwriting */
/* font-family: 'Dokdo', cursive; -- funky */
/* font-family: 'Bungee Shade', cursive; -- pop art caps */

ul{
  margin-top: 0px;
}

h4{
  font-size: 18px;
  font-weight: 500;
}

a{
  color: #337ab7; /* boostrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}

.nope{
  color:red; 
  font-size: 10px; 
}

.dialog-text *{
  font-family: 'Dokdo', cursive;  
  font-size: 32px;
  width:350px;
}

.explanation *{
  font-size: 22px;
}

button{
  cursor: pointer;
  background-color: white;
  border-radius: 4px;

  font-size: 24px;
  font-weight: 900;
  margin-bottom: 8px; 
}

.question button:hover, .question .clicked-button{
  color: white;
  background-color: black;
}


.strong{
  font-weight: 900;
}

.explanation{
  display: grid;
  grid-template-columns: 1fr 500px 1fr;
  grid-template-rows: 1fr auto 1fr;
  height: 500px;
}

.explanation button{
  margin: 0 auto;
  margin-bottom: 8px;
}


.hidden-at-first{
  opacity: 0;
  transition: opacity 1s;
}

.wobble{
  position: absolute;
  animation: wobble 5s ease 0s infinite;
}

@keyframes wobble {
  0% {
    transform: rotate(0turn);
  }
  5% {
    transform: rotate(0.005turn);
  }
  10% {
    transform: rotate(0turn);
  }
  12% {
    transform: rotate(0.005turn);
  }
  15% {
    transform: rotate(0turn);
  }
}

.bounce{
  position: absolute;
  animation: bounce 5s ease 0s infinite;
}

@keyframes bounce {
  0% {
    transform: translateY(20px);
  }
  3% {
    transform: translateY(-30px);
  }
  6% {
    transform: translateY(10px);
  }
  10% {
    transform: translateY(-10px);
  }
  12% {
    transform: translateY(0px);
  }
}

@keyframes mad-bounce {
  0% {
    transform: translateY(20px);
  }
  10% {
    transform: translateY(-30px);
  }
  20% {
    transform: translateY(10px);
  }
  30% {
    transform: translateY(-10px);
  }
  40% {
    transform: translateY(0px);
  }
}
.mad-bounce{
  position: absolute;
  animation: bounce 1.5s ease 0s infinite;  
}

@keyframes fallover{
  100% {
    transform: rotate(0.3turn);
  }
}

.fallover{
  position: absolute;
  animation: fallover 1s ease-in 0s 1; /* to not stand back up:  normal forwards;  */
}

.dot{
  display: inline-block;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background-color: #eee;
}

.dot:hover{
  background-color: #777;
}


.dot span{
  display: none;
  position:absolute;
  font-size: 10px;
  top: 24px;
  white-space: nowrap;

  background-color: rgba(0,0,0,0.5);
  padding: 8px;
  border-radius: 8px;
  color: white;
}

.dot:hover span{
  display: inline-block;
}


.extra-info, .extra-info *{
  font-size: 12px;
}

.smaller-children, .smaller-children *{
  font-size: 12px;
}

/* https://w3bits.com/rainbow-text/ */
.rainbow-text {
  background-image: repeating-linear-gradient(45deg, violet, indigo, blue, green, orange, red, violet);
  text-align: center;
  background-size: 800% 800%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow 4s ease infinite;
}

@keyframes rainbow { 
    0%{background-position:0% 50%}
    50%{background-position:100% 25%}
    100%{background-position:0% 50%}
}

.fade-enter-active, .fade-leave-active {
  transition: opacity 1s;
}
.fade-enter, .fade-leave-to {
  opacity: 0;
}

.slide-fade-enter-active, .slide-fade-leave-active {
  transition: all .3s ease;
}
.slide-fade-enter, .slide-fade-leave-to {
  transform: translateY(-300px);
  opacity: 0;
}

</style>

<body>


<div id="app" style="position:relative">



<!--

<transition name="slide-fade">
<div v-if="show" style="background-color: blue; width:200px; height:200px;"></div>
</transition>

  <button @click="show = !show">
    Toggle render
  </button>


<button class="rainbow-text">Test</button>


<story :visible="true">
Are you here?

If so, you are in the <a @click="show('waiting')">right place</a>.

What is the probability that you will succeed?
</story>

<once-group>
<once-button>1/2</once-button>
<once-button>1/4</once-button>
<once-button>1/8</once-button>
</once-group>


<story ref="waiting">
I have been <a @click="show('changing')">waiting</a> for you. 
</story>

<story ref="changing">
The times are changing.

The prophecies are unclear, but the times are changing.

This planet is <a @click="show('new-world')">changing</a>.
</story>

<story ref="new-world">
<div>
You are going to bring us into this new world of <span class="animated infinite jello" style="display:inline-block">uncertainty</span>.
</div>-->



<div>


<!-- <div style="width: 150px; position:absolute; left: 0px; text-align: left; padding-left: 16px">

  <div v-for="storyPoint in storyPoints"
      @click="currentStoryPoint = storyPoint"
      style="margin-bottom: 4px;"
      :style="storyPointStyle(storyPoint)">
    <a :class="[storyPoint === currentStoryPoint ? 'active-tab': 'inactive-tab']">{{storyPoint.name}}</a>
  </div>

</div> -->


<keep-alive>
  <component v-bind:is="currentStoryPoint.component"></component>
</keep-alive>


</div> <!-- end centering box -->



</div> <!-- end #app -->


<script type="text/x-template" id="chain-rule-template">
<div>

<!-- <buton-group :onClick="() => showFall = true">
  <buton @click="showRainbow=true">Test buton</buton>
</buton-group>

<div style="position:relative; left: 200px">
<div class="dot" @click="set('problem0')">
  <span>The independence problem</span>
</div>
<div class="dot">
  <span>This second great thing</span>
</div>
<div class="dot">
  <span>This third thing</span>
</div>
</div>
-->


{{avatarState}}
<transition-group name="fade" mode="out-in">

<avatar key="intro"
  v-if="show('intro')"
  image="girl0.png" 
  text="I only date tall monsters with great hair."
  :state="avatarState">
  <buton @click="set('problem0')">Next</buton>
</avatar>

<avatar key="problem0"
  v-if="show('problem0')" 
  image="girl1.png" 
  text="If 1/2 of all monsters are tall, and 1/4 of monsters have great hair, what is the probability that a random monster is datable?"
  :state="avatarState">

  <buton-group :onClick="() => avatarState.showExplanation=true">
    <buton>1/8</buton>
    <buton nope="Why 1/3? Try again.">1/3</buton>
    <buton nope="That doesn't make sense. 3/4 is more than the number of monsters that are tall. Try again.">3/4</buton>
    <buton @click="yay('problem0')" yay>Can't say</buton>
  </buton-group>

  <template v-slot:explanation>
    <div v-if="got('problem0')">
      Right! It's not possible to say. 
    </div>
    <div v-else>
      It's actually not possible to say.
    </div>

    <div>
    Multiplying probabilities implies that the two events are independent.
    </div>

    <div>
      Being tall must provide <span class="strong">no information</span> on whether a monster has great hair.
    </div>

    <buton @click="set('problem1')">Next</buton>
  </template>

</avatar>


<avatar key="problem1" 
        v-if="show('problem1')"
        image="girl0.png" 
        text="Yeah! I guess being tall and having great hair are slightly correlated. About 1/3 of tall monsters have great hair."
        :state="avatarState">

  <template v-slot:extra>
    Facts from before:
    <ul>
      <li>1/2 of all monsters are tall</li>
      <li>1/4 of all monsters have great hair</li>
    </ul>
  </template>

  <template v-slot:question>
    <div>What is the probability that a random monster is datable?, i.e. Is tall AND has great hair?</div>

    <buton-group :onClick="() => avatarState.showExplanation=true">
      <buton @click="yay('problem1')" yay>1/6</buton>
      <buton nope="We said that being tall and having great hair are not independent, so we cannot multiply 1/2 x 1/4.">1/8</buton>
      <buton nope="Are you just multiplying things together? Try again.">1/24</buton>
      <buton nope="The answer isn't always 'Can't say'...">Can't say</buton>
    </buton-group>
  </template>

  <template v-slot:explanation>
    <div>
      {{ got('problem1') ? 'Right.': 'Not quite.' }}
    </div>

    <div>
      The probability that a monster has great hair AND is tall, combines:
    </div>

    <div>
      (1) The probability the monster is tall: P(tall)
    </div>

    <div>
      (2) The probability the monster has great hair, given that the monster is tall: P(great hair | tall)
    </div>

    <div>
      P(great hair AND tall) = P(tall) * P (great hair | tall)
    </div>

    <buton @click="set('problem2')">Next</buton>
  </template>
</avatar>


<avatar key="problem2"
        v-if="show('problem2')"
        image="girl0.png"
        text="Oh thank you for your help so far. But I forgot... I also want them to have tattoos. 1/5 of monsters have tattoos."
        :state="avatarState">
  <div>What is P(tall, great hair, tattoos)?</div>

  <buton-group :onClick="() => avatarState.showExplanation=true">
    <buton>1/30</buton>
    <buton nope="Remember, we want to use P(great hair|tall), not P(tall).">1/40</buton>
    <buton nope="Wait, are you just blindly multiplying numbers? Stop that.">1/120</buton>
    <buton @click="yay('problem2')" yay>Can't say</buton>
  </buton-group>

  <template v-slot:extra>
    Facts from before:
    <ul>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
    </ul>
  </template>

  <template v-slot:explanation>
    <div>
      {{ got('problem2') ? 'Right.': 'Not quite.' }} Again, it's not possible to say!
    </div>

<!--     <div> assumed independence
      Blindly multiplying P(tall) * P(great hair) * P(tattoos) assumes the events are independent. It doesn't work if any of the variables are very positively or negatively correlated.
    </div>

    <buton>How to do this properly?</buton>
 -->
    <div>
      To do this properly, use the logic in the <span class="strong">Chain Rule</span>:
    </div>

    <div class="smaller-children" style="margin-left: 16px;">
      <div style="color:magenta">
        First, consider the probability of the monster being tall.
      </div>

      <div style="color:green">
        Then, consider the probability of a tall monster having great hair.
      </div>

      <div style="color:blue">
        Then, consider the probability that a tall monster with great hair... would have a tattoo.
      </div>
    </div>

    <div>
      Multiply together to filter down to monsters that are tall and have great hair and have tattoos.
    </div>

    <div>
      Mathematically, this is written out as:
    </div>

    <div class="smaller-children">
      P(tattoo AND great hair AND tall) = <span style="color:magenta">P(tall)</span> * <span style="color:green">P(great hair | tall)</span> * <span style="color:blue">P(tattoo | great hair AND tall)</span>
    </div>

    <buton>Try it</buton>

  </template>

</avatar>


<avatar key="problem3" 
        v-if="show('problem3')"
        image="girl1.png" 
        text="Ooh yeah I've heard of the Chain Rule. Here are more than enough numbers to get you through."
        :state="avatarState">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li>Veronica only dates tall monsters with great hair and tattoos</li>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
      <li>P(tattoos) = 1/5</li>
      <li>P(tattoos|tall) = 1/6</li>
      <li>P(tattoos|tall AND great hair) = 1/7</li>
    </ul>
    </div>

    <div>
    P(tall, great hair, tattooed) =
    </div>

    1/<input-box :right="42" />
</avatar>


<avatar key="problem4" 
        v-if="show('problem4')"
        image="girl1.png" 
        text="Silly us! We forgot to include that these tall, great hair, tattooed monsters also need to be... around my age and single."
        :state="avatarState">

    <div class="extra-info">
    Facts from before:
    <ul>
      <li>Veronica only dates monsters that are tall, have great hair, tattoos, around her age, and single</li>
      <li>P(tall) = 1/2</li>
      <li>P(great hair) = 1/4</li>
      <li>P(great hair|tall) = 1/3</li>
      <li>P(tattoos) = 1/5</li>
      <li>P(tattoos|tall) = 1/6</li>
      <li>P(tattoos|tall AND great hair) = 1/7</li>
      <li>P(around her age|tall AND great hair AND tattoos) = 1/5</li>
      <li>P(single|tall AND great hair AND tattoos AND around her age) = 1/2</li>
    </ul>
    </div>

    <div>
    P(tall, great hair, tattooed, around her age, single) =
    </div>

    1/<input-box :right="420" />
</avatar>


<avatar key="not-many"
        v-if="show('not-many')"
        animation="mad-bounce"
        image="girl_mad.png" text="That's not very many people!">

  What will you say to Veronica? 
  <buton class="smaller-children">I know you'll find someone soon.</buton>
  <buton class="smaller-children">Even though each individual criteria may not seem picky, requiring that a monster have all those traits leaves you with a very small dating pool.</buton>
</avatar>



<explanation key="congrats"
  v-if="show('congrats')">
  <div style="font-size: 48px; letter-spacing:4px;">
  CONGRATS
  </div>
  
  <ul>
    <li>You learned about independence</li>
    <li>You learned about Chain Rule</li>
    <li>You befriended Veronica ❤️</li>
  </ul> 
</explanation>

</transition-group>

</div>

</script>


<!-- begin templates -->
<script type="text/x-template" id="explanation-template">
<div class="explanation">
  <div></div>
  <div></div>
  <div></div>

  <div></div>
  <div><slot></slot></div> 
  <div></div>

  <div></div>
  <div></div>
  <div></div>

</div>
</script>


<script type="text/x-template" id="avatar-template">
<div style="position: relative; height: 500px;">


<!-- overlay with explanation -->
<transition name="slide-fade">
<div v-if="state.showExplanation && hasSlot('explanation')"
     style="position:absolute; z-index:1; height: 500px; width:100%; opacity:0.9; background-color: white; color:black;">
  <explanation>
      <slot name="explanation"></slot>
  </explanation>
</div>
</transition>


<img v-if="state.showRainbow" src="images/rainbow.png">

<img :src="'images/'+ image" 
     :class="imgClasses"
     style="height: 400px; left: 50px; position:absolute; top:0px;">


<!-- Dialog box -->
<div style="position:absolute; left: 300px; top:0px;">
  <img src="images/dialog.png" >
  <div style="position: absolute; left:40px; top:23px;" class="dialog-text">
    <live-text @live-text-complete="showQuestionAndExtra()">
      {{text}}
    </live-text>
  </div>
</div>

<!-- Bottom right -->
<transition name="fade">
  <div v-if="showQuestion" class="question" style="position:absolute; left: 380px; top: 300px; width: 300px;">
    <slot name="question"></slot>
    <slot></slot> <!-- todo: consider removing default slot -->
  </div>
</transition>

<!-- Bottom left -->
<transition name="fade">
  <div v-if="showExtra" style="position:absolute; top: 400px; left: 50px; width:250px;" class="extra-info">
    <slot name="extra"></slot>
  </div>
</transition>


</div>
</script>



<script type="text/x-template" id="story-template">
<div v-if="isVisible"><slot></slot></div>
</script>

<script type="text/x-template" id="live-text-template">
  <div>
    <transition-group name="fade" tag="span">
      <span v-for="(token, i) in visibleTokens" :key="i" v-html="token">
      </span>
    </transition-group>
  </div>
</script>


<script type="text/x-template" id="monk-head-template">
<div class="handwriting normal-divs"
      style="display:inline-block; position:relative; white-space: nowrap;">
  <img src="images/monk_head.png" style="width:80px;">

  <!-- speech pointing to left -->
  <div v-if="hasSlot('lhs')">
    <div style="width:22px; border:1px solid black; transform:rotate(50deg); position:absolute; top:-14px; left:10px;"></div>
    <div style="position:absolute; top: -40px; left:0px;">
      <slot name="lhs"></slot>
    </div>
  </div>

  <!-- speech pointing to right -->
  <div v-if="hasSlot('rhs')">
    <div style="width:24px; border:1px solid black; transform:rotate(310deg); position:absolute; top:-14px; left:50px;"></div>
    <div style="position:absolute; top: -40px; left: 60px;">
      <slot name="rhs"></slot>
    </div>
  </div>

</div>
</script>


<script type="text/x-template" id="buton-template">
<div style="margin-bottom:0px; position:relative;">
  <button @click="butonClicked()" v-on="$listeners" :class="{'rainbow-text': showRainbowText, 'clicked-button': clickedButton}"><slot></slot>
  </button>
  <transition name="fade">
    <div v-if="showNopeText" class="nope" style="margin-bottom:8px; position:relative; top:-4px;">
      {{nope}}
    </div>
  </transition>
</div>
</script>


<script type="text/x-template" id="input-box-template">
  <div style="display:inline-block; position:relative;">
    <input v-model="val" placeholder="?" style="width:50px; display:inline">
    <buton style="display:inline" @click="answerSubmit">Go</buton>
  
    <transition name="fade">
      <span v-if="showNopeText" class="nope" style="position:absolute; bottom: -8px; margin-bottom:0px">
        {{nopeText}}
      </span>
    </transition>
  </div>
</script>


<!-- end templates -->


<script>

const wait = ms => new Promise(resolve => setTimeout(resolve, ms));

// https://alligator.io/vuejs/global-event-bus/
const bus = new Vue();

Vue.component('input-box', {
  props: {
    right: {type: Number, default: 0},
    hints: {
      type: Array, 
      default: function(){ return ['Try again']; },
    },
    onRight: {
      type: Function,
      default: function(){},
    },
  },
  computed: {
    nopeText: function(){
      return this.hints[Math.min(this.numWrong, this.hints.length-1)];
    }
  },
  data: function(){
    return {
      val: null,
      showNopeText: false,
      numWrong: 0,
    }
  },
  methods: {
    answerSubmit: function(){
      // look at the value in the input.
      if (this.val == this.right){
        this.showNopeText = false;
        this.onRight();
      } else {
        this.numWrong++;
        this.showNopeText = true;
      }
    }
  },
  template: '#input-box-template'
});

function isDescendant(ancestor, maybeChild){
  var node = maybeChild.$parent;
  while(node !== undefined){
    if (node === ancestor){
      return true;
    }
    node = node.$parent;
  }
  return false;
}

Vue.component('avatar', {
  props: {
    image: {type: String}, // 'girl.png'
    text: {type: String},
    animation: {type: String, default: 'wobble'},

    // Events that get triggered from parent.
    state: {type: Object, default: function() { 
      return {
        showExplanation: false, showRainbow: false, showFall: false}; 
      }
    },
  },

  computed: {
    imgClasses: function(){
      var classes = {fallover: this.state.showFall};
      classes[this.animation] = true;
      return classes;
    }
  },
  data: function(){
    return {
      // Internally triggered events.
      showQuestion: false,
      showExtra: false,
    };
  },

  methods: {
    hasSlot: function(name){
      return !!this.$slots[ name ] || !!this.$scopedSlots[ name ];
    },
    showQuestionAndExtra: async function(){
      this.showQuestion=true; 
      await wait(1000);
      this.showExtra=true;
    },
  },
  template: '#avatar-template'
});


// Just like a button, but with some special abilities.
// When clicked it looks at it's parent to see if it's a buton-group.
// Executes the onClick event if so.
// e.g.
// <buton-group onClick="doSomethingSecond">
//   <buton @click="doSomethingFirst">Click me</buton>
// </buton-group>

// Unless the buton has nope text nope="something", in which case the buton-group does not get triggered.
// e.g.
// <buton nope="stop and think">Tricked ya</buton>

// Buttons may also have a yay attribute.
// Which causes the button to turn rainbow-text after it gets clicked.
Vue.component('buton', {
  props: {
    nope: {type: String}, // Text for why the answer is wrong. Blocks progression.

    // moved to attr
    //yay: {type: Boolean, default:false}, // Causes cool animation to happen when clicked.
  },
  data: function(){
    return {
      showNopeText: false,
      showRainbowText: false,
      clickedButton: false,
    }
  },

  methods: {
    butonClicked: async function(){
      console.log('buton clicked');
      bus.$emit('buton-clicked', this);

      if (this.nope){
        this.showNopeText = true;
        this.$emit('nope-clicked');
        // Early return.
        return;
      }

      this.clickedButton = true;
      // if ('yay' in this.$attrs){
      //   console.log('yay that was a good button');
      //   this.showRainbowText = true;        
      // }
      // Add delay so any custom handlers on the buton execute before the generic buton-group executes.
      await wait(1000);

      if (this.$parent.onClick !== undefined){
        this.$parent.onClick();        
      }
    },
  },
  template: '#buton-template'
});

Vue.component('buton-group', {
  props: {
    onClick: {type: Function, 
              default: () => console.warn('buton-group should have onClick') },
  },
  template: '<div><slot></slot></div>'
});


Vue.component('explanation', {
  template: '#explanation-template'
});

Vue.component('chain-rule', {
  data: function(){
    return {
      active: 'intro',

      problemsRight: [], // 'problem0' (use string key)
      gotCorrelationIntuitionRight: false,

      avatarState: {
        showRainbow: false,
        showFall: false,
        showExplanation: true,        
      },
    };
  },
  mounted: async function(){
    var this_ = this;
    bus.$on('buton-clicked', async function(buton){
      // Have avatar react based on buton attributes.
      if ('yay' in buton.$attrs){
        this_.avatarState.showRainbow = true;        
      }
      if (buton.nope !== undefined){
        this_.avatarState.showFall = true;
        await wait(3000);
        this_.avatarState.showFall = false;
      }
    });
  },
  methods: {
    print: function(thing){
      console.log(thing);
    },
    specialClicked: function(){
      console.log('special clicked');
    },
    show: function(id){
      return true;
//      return id == this.active;
    }, 
    yay: function(id){
      this.problemsRight.push(id);
    },
    got: function(id){
      return this.problemsRight.indexOf(id) > -1;
    },
    set: async function(id, optionalDelay){
      // do the animationss
      // this.avatarState.showRainbow = true;
      // this.avatarState.showFall = true;
      // this.avatarState.showExplanation = true;
      if (optionalDelay !== undefined){
//        debugger;
        console.log('started waiting');
        await wait(optionalDelay);        
        console.log('done waiting');
      }

      this.active = id;
      // Reset avatar state.
      console.log('reseting state');
      this.avatarState = {
        showRainbow: false,
        showFall: false,
        showExplanation: false,        
      };
    },
  },
  template: '#chain-rule-template'
});

// Vue.component('question', {
//   template: '#question-template'
// });


// Hides content until it is revealed as part of the story.
Vue.component('story', {
  props: {
    visible: {type: Boolean, default:false},
  },
  data: function(){
    return {
      isVisible: this.visible,
    };
  },
  watch: {
    isVisible: scrollWindow,
  },
  template: '#story-template'
});


/*

How should this work:
- split the text into words
- inject the words in via setinterval
- add a transition component that makes it fade in when it is injected
*/
Vue.component('live-text', {
  props: {
    interval: {type: Number, default: 1000},
  },

  render: function (createElement) {
    var data = [];
//    debugger;

    for (var i=0; i<this.$slots.default.length; i++){
      var vnode = this.$slots.default[i];

      if (vnode.tag){
        data.push([vnode.tag, vnode.data, vnode.children])
      } else if (vnode.text){
        var tokens = vnode.text.split(' ').filter(token => token);
        data = _.concat(data, tokens.map(token => ['span', {}, token + ' ']));
      }
    }

    var vnodes = data.map(function(tuple, i){
      const tag = tuple[0];
      const nodeData = tuple[1];
      const children = tuple[2];
      const meta = {
        ref: i, 
        class: { 'hidden-at-first': true }
      };

      return createElement(tag, _.merge(meta, nodeData), children);
    });

    return createElement(
      'div',   // tag name
      vnodes, 
    )
  },

  data: function(){
    return {
      visibleTokens: [],
    };
  },

  mounted: async function(){
    var elts = _.values(this.$refs);
    var lastSentence = [];
    var currentSentence = [];

    for (var i=0; i<elts.length; i++){
      var elt = elts[i];
      currentSentence.push(elt);
      elt.style.opacity = 1;

      const isEndOfSentence = elt.textContent && elt.textContent.includes('.');
      const duration = isEndOfSentence ? 1000 : 100;
      await wait(duration);

// Fading by words.
//      elt.style.opacity = 0.5;

// Fading by sentences.
      // console.log('i: ' + i + ' len ' + elts.length);
      if (isEndOfSentence){
        lastSentence = currentSentence;
        currentSentence = [];
        // Fade the lastSentence away.
        await(2000);
        // for (var j=0; j<lastSentence.length; j++){
        //   elt.classList.remove('hidden-at-first');
        //   elt.classList.add('become-dull');
        //   lastSentence[j].style.opacity = 0.5;
        //   await wait(50);
        // }          
      }
    }

    // I think sticking this here should work.
    this.$emit('live-text-complete');
  },

  template: '#live-text-template'
});

var storyPoints = [
// {
//   name: 'Monk Intro',
//   component: 'monk-intro',
// },
// {
//   name: 'Monk Game',
//   component: 'monk-game',
// },
// {
//   name: 'Forest Intro',
//   component: 'forest-intro',
// },
// {
//   name: 'Forest Game',
//   component: 'forest-game',
// },
// {
//   name: 'Distribution Interlude',
//   component: 'distribution-interlude',
//   nest: 1
// },
{
  name: 'Chain Rule',
  component: 'chain-rule',
},
// {
//   name: 'Cats',
//   component: 'cat-forest',
// },


];

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {

    storyPoints: storyPoints,
    currentStoryPoint: storyPoints[0],

    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    soundNameToCount: {},

    show: false,
  },

  watch: {
    currentStoryPoint: function(){
      this.$root.play('swish');
    },
  },

  methods: {
//    show: show, 
    renderAsPercent: renderAsPercent,

    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,

    // Changes tabs.
    setStoryPoint: function(component_name){
      var story_point = _.filter(storyPoints, {component: component_name});
      if (story_point.length !== 1){
        console.error('must match exactly one story point');
        debugger;
      }
      this.currentStoryPoint = story_point[0];
      this.play('achievement0');
    },

    // Given 0.8 --> returns {}
    paramsFromCertainty: function(certainty){
      if (certainty == 1.0){
        return {
          numLoseIfWrong: 10000000, 
          numWinIfRight: 1,
          certainty: certainty,
          percent: '100%',
        };
      }
      return {
        numWinIfRight: 1, 
        numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
        certainty: certainty,
        percent: this.renderAsPercent(certainty)
      };      
    },

    paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
      var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
      return this.paramsFromCertainty(certainty);
    },

    storyPointStyle: function(storyPoint){
      if (storyPoint.nest === undefined){
        return {};
      }
      return {
        'margin-left': storyPoint.nest * 8 + 'px',
        'font-size': '12px'
      };
    },

    play: function(soundName){
      console.log('playing ' + soundName);

      var audio;
      if (isNaN(soundName[soundName.length-1])){ // is string last char
        const count = this.soundNameToCount[soundName] || 0;
        this.soundNameToCount[soundName] = count+1;
        audio = new Audio('sounds/' + soundName + (count % 2) + '.wav');
      } else { // is number last char
        audio = new Audio('sounds/' + soundName + '.wav');
      }
      audio.play();      
    }
  } // end methods
});


</script>