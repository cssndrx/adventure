<!doctype html>
<meta charset="utf-8" />

<head>
<!--<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:200,400,700,900" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Gloria+Hallelujah" rel="stylesheet">-->

<!--
font-family: 'VT323', monospace;
font-family: 'Princess Sofia', cursive;
font-family: 'Indie Flower', cursive;
font-family: 'Dokdo', cursive;
font-family: 'East Sea Dokdo', cursive;
font-family: 'Creepster', cursive;
font-family: 'Bungee Hairline', cursive;
font-family: 'Bungee', cursive;
font-family: 'Bungee Shade', cursive;
font-family: 'Bungee Inline', cursive;
font-family: 'Cormorant Garamond', serif;
-->

<!-- todo: strip and remove the unused -->
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Bungee|Bungee+Hairline|Bungee+Inline|Bungee+Shade|Cormorant+Garamond|Creepster|Dokdo|East+Sea+Dokdo|Indie+Flower|Princess+Sofia|VT323" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=East+Sea+Dokdo|Gaegu:300,400,700|Montserrat:300,400|Open+Sans|Raleway|Roboto+Slab" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Eagle+Lake|Lato|Raleway" rel="stylesheet">

<link href="css/animate.css" rel="stylesheet" type="text/css">
<script src="js/lodash.min.js"></script>
<script src="js/d3.v4.min.js"></script>

<script src="js/vue.js"></script>

<script src="js/utils.js"></script>
<script src="js/forest.js"></script>

<style>

*{
  font-family: 'Montserrat', sans-serif; /* a bit wider */
  font-family: 'Raleway', sans-serif; /* a bit tighter */
  font-size: 16px;
}

div{
  margin-bottom: 16px;
}

.past{
  color: #777;
}


.header{
  font-family: 'Eagle Lake', cursive;
}

/* font-family: 'Gaegu', cursive; -- cute child like handwriting */
/* font-family: 'Dokdo', cursive; -- funky */
/* font-family: 'Bungee Shade', cursive; -- pop art caps */
.word-problem{
  margin: 16px;
  font-family: 'Gaegu', cursive;
  font-size: 16px;
  line-height: 1.5em;
}

button{
  max-width: 150px;
  margin-right: 8px;
  cursor: pointer;

  background-color: white;
  border-radius: 4px;
}

h4{
  font-size: 18px;
  font-weight: 500;
}

a{
  color: #337ab7; /* boostrap blue */
  text-decoration: none;
  cursor: pointer;
}

img{
  max-width: 400px;
}

.monk-dual-quiz .active{
  font-family: 'Bungee Shade', cursive; 
  font-size: 18px;   
}

.monk-dual-quiz .inactive{
  font-family: 'Bungee Hairline', cursive;
  font-size: 10px;
  color: #ccc;
  cursor: pointer;
}

.monk-dual-quiz .inactive:hover{
  color:black;
}

.moneybag-widget {
  display:inline-grid;
  grid-template-columns: 180px 1fr; /* chosen to get 10 moneybags on rhs*/
  grid-template-rows: 44px 1fr;
}

.moneybag-widget .lhs{
  text-align: left;
}

.moneybag-widget .rhs{
  text-align: right;
}

.normal-divs div{
  margin-bottom: 0px;
}

.fulcrum {
  display: inline-block;
  color: white;
  width: 0; 
  height: 0; 
  border-left: 50px solid transparent;
  border-right: 50px solid transparent;  
  border-bottom: 50px solid black;
}

.smooth{
  transition: all 1s ease;
}

.handwriting{
  font-family: 'Dokdo', cursive;  
}

.bold {
  font-family: 'Bungee Shade', cursive;  
}

.uncertain {
  font-family: 'Bungee Hairline', cursive;
}

.clicked-button{
  font-family: 'Bungee Shade', cursive;  
}

.right-answer{
  color: green;
}

.wrong-answer{
  color: red;
}

.moneybag-button:hover{
  background-color: #ccc;
}

.progress-moneybag{
  display: block;
  margin: 0 auto;
  width: 20px;
}

/* https://codepen.io/anon/pen/Laoxro */
.pulse{
  position: relative;
}

.pulse:after {
  content:"";
  display:block;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 3px solid #CBA82C;
  position:absolute;
  top:-40px;
  left:2px;
  animation: pulse 2s ease 0s infinite;
}

@keyframes pulse {
  0% {
      opacity: 1;
      transform: scale(1);
  }
  80% {
      opacity: 0;
      transform: scale(2);
  }
  100% {
      opacity: 0;
      transform: scale(3);
  }
}

.right-wobble{
  position: absolute;
  animation: rightwobble 1s ease 0s 1;
}

@keyframes rightwobble {
  0% {
    transform: rotate(0turn);
  }
  30% {
    transform: rotate(0.005turn);
  }
  100% {
    transform: rotate(0turn);
  }
}


.left-wobble{
  position: absolute;
  animation: leftwobble 0.5s ease 0s 1;
}

@keyframes leftwobble {
  0% {
    transform: rotate(0turn);
  }
  30% {
    transform: rotate(-0.01turn);
  }
  100% {
    transform: rotate(0turn);
  }
}


.lr-arrow{
  position: absolute;
  animation: lr 2s ease 0s infinite;
}

@keyframes lr {
  0% {
    transform: translateX(0px);
  }
  30% {
    transform: translateX(20px);
  }
}


.clickme-button{
  animation: pulseborder 1s ease 0s infinite;
}

@keyframes pulseborder{
  0% {
    border-bottom: 1px dashed red;
  }
  30% {
    border-bottom: 5px dashed red;
  }  
}

.pulse-text{
  animation: pulsetext 1s ease 0s infinite;
}

@keyframes pulsetext{
  0% {
    color: white;
  }
  30% {
    color: orange;
  }
  100% {
    color: white;
  }
}

.story-index{
  margin-top: 32px;
  border: 2px solid grey;
}

.active-tab{
  font-weight: bold;
}

.inactive-tab{
  color: #bbb;
}

/* for animate.css compat */
.animated{
  display: inline-block;
  animation-duration: 3s;
}

.jello {
  color: black;
}

.fade-to-black{
  color: #777;
  transition: all 1s ease;
}

.fade-to-black:hover{
  color: #000;
}



.fade-enter-active, .fade-leave-active {
  transition: opacity 1s;
}
.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ {
  opacity: 0;
}



.hidden-at-first{
  opacity: 0;
  transition: opacity 1s;
}

.become-dull{
  transition: opacity 2s;
}

pre {
    white-space: pre-wrap;       /* Since CSS 2.1 */
    word-wrap: break-word;       /* Internet Explorer 5.5+ */
    margin: 0px;
}

.slider{
  background-color: red;
  width:10px;
  height:30px;
  border: 2px solid black;
  border-radius: 2px;
}

</style>

<body>


<div id="app" style="position:relative">
<live-text>
  Most people exhibit overconfidence. When people say they are 80% sure, research finds they are correct 60% of the time.

  Us monks have developed a way to help people be more calibrated.

  For each possible certainty, convert it to the fair bet.
</live-text>

<live-text>
  Imagine an oracle who is always 80% right. What fee structure would cause them to neither gain nor lose money?
</live-text>




starlab storytime

<!--<live-text>
All of us who do creative work, we get into it because we have good taste. But it's like there is this gap. For the first couple years that you're making stuff, what you're making isn't so good. It’s not that great. It’s trying to be good, it has ambition to be good, but it’s not that good.

<a href="https://www.google.com">Click me</a>.


But your taste, the thing that got you into the game, is still killer. And your taste is good enough that you can tell that what you're making is kind of a disappointment to you. A lot of people never get past that phase. They quit.

Everybody I know who does interesting, creative work they went through years where they had really good taste and they could tell that what they were making wasn't as good as they wanted it to be. They knew it fell short. Everybody goes through that.

And if you are just starting out or if you are still in this phase, you gotta know its normal and the most important thing you can do is do a lot of work. Do a huge volume of work. Put yourself on a deadline so that every week or every month you know you're going to finish one story. It is only by going through a volume of work that you're going to catch up and close that gap. And the work you're making will be as good as your ambitions.

I took longer to figure out how to do this than anyone I’ve ever met. It takes awhile. It’s gonna take you a while. It’s normal to take a while. You just have to fight your way through that.
</live-text> -->

<slider-guess></slider-guess>

<!--<h1 class="header" style="font-size:64px;">Adventures in Cognitive Biases</h1>-->

<story :visible="true">
Are you here?

If so, you are in the <a @click="show('waiting')">right place</a>.
</story>

<story ref="waiting">
I have been <a @click="show('changing')">waiting</a> for you. 
</story>

<story ref="changing">
The times are changing.

The prophecies are unclear, but the times are changing.

This planet is <a @click="show('new-world')">changing</a>.
</story>

<story ref="new-world">
<div>
You are going to bring us into this new world of <span class="animated infinite jello" style="display:inline-block">uncertainty</span>.
</div>



<div style="max-width: 400px; margin: 0 auto; text-align: center;">


<div style="width: 150px; position:absolute; left: 0px; text-align: left; padding-left: 16px">

  <div v-for="storyPoint in storyPoints"
      @click="currentStoryPoint = storyPoint"
      style="margin-bottom: 4px;"
      :style="storyPointStyle(storyPoint)">
    <a :class="[storyPoint === currentStoryPoint ? 'active-tab': 'inactive-tab']">{{storyPoint.name}}</a>
  </div>

</div>


<keep-alive>
  <component v-bind:is="currentStoryPoint.component"></component>
</keep-alive>


</div> <!-- end centering box -->



</div> <!-- end #app -->



<!-- begin templates -->

<script type="text/x-template" id="slider-guess-template">
<div style="width: 300px; border: 1px solid red; position:relative">
  <div style="border:1px solid black; position:absolute; top: 50px;left:0px;width:100%;"></div>
  <div class="slider" style="position:absolute; top:35px; left:100px;" draggable="true"></div>
  <div class="slider" style="position:absolute; top:35px; right:100px;"></div>
</div>
</script>


<script type="text/x-template" id="story-template">
<live-text v-if="isVisible"><slot></slot></live-text>
</script>

<script type="text/x-template" id="live-text-template">
  <div>
    <transition-group name="fade" tag="span">
      <span v-for="(token, i) in visibleTokens" :key="i" v-html="token">
      </span>
    </transition-group>
  </div>
</script>

<script type="text/x-template" id="text-animation-template">
<div>
  {{visibleText}}
</div>
</script>

<script type="text/x-template" id="monk-head-template">
<div class="handwriting normal-divs"
      style="display:inline-block; position:relative; white-space: nowrap;">
  <img src="images/monk_head.png" style="width:80px;">

  <!-- speech pointing to left -->
  <div v-if="hasSlot('lhs')">
    <div style="width:22px; border:1px solid black; transform:rotate(50deg); position:absolute; top:-14px; left:10px;"></div>
    <div style="position:absolute; top: -40px; left:0px;">
      <slot name="lhs"></slot>
    </div>
  </div>

  <!-- speech pointing to right -->
  <div v-if="hasSlot('rhs')">
    <div style="width:24px; border:1px solid black; transform:rotate(310deg); position:absolute; top:-14px; left:50px;"></div>
    <div style="position:absolute; top: -40px; left: 60px;">
      <slot name="rhs"></slot>
    </div>
  </div>

</div>
</script>


<script type="text/x-template" id="cat-forest-template">
<div style="text-align:left" class="cat-style">


<div class="cat-tongue" style="font-size:48px;">The Average Forest</div>

<div>
Adventurer, if you're up to the task...
</div>

<div>
Your journey will take you through an average forest, where you will encounter creatures that need your help.
</div>

<!--<div>
A distribution shows the possible outcomes and how likely they are to occur.
</div> -->



<div class="cat-problem" style="text-align:left; margin-left: 32px;">

  <div class="cat-tongue" style="font-size:32px;">The Average Cat</div>

  <img src="images/cat1.png">
  <div>
    Cat surveyed forest. Average cat eat 5.2 mouse/day. Dat lot!
  </div>

  <div>
  Diss cat only get 2 mouse/day. Is diss cat very unlucky?
  </div>

  <button>Yes, poor kitty</button>
  <button>No</button>
  <button>Not enough info</button>
</div>

<div>
  Yarrr king make average go up! Average no help with outlier!
</div>

<div>
  Okkk okkk we try again.
</div>

<div class="cat-problem">
  <div class="cat-tongue" style="font-size:32px;">The Average And Standard Deviation Cat</div>

  <div style="text-align:center;">
    <img src="images/cat2.png">
  </div>

  <div>
    Ok we ignore king cat data point.
  </div>

  <div>
    Compare this cat forest with neighbor cat forest.
  </div>

</div>


</div>
</script>


<script type="text/x-template" id="game-intro-template">
<div>

<!--<div>
Things are getting more and more <span class="animated infinite rubberBand">~~uncertain~~</span>.
</div> -->

</div>

</script>

<!-- end templates -->


<script>


Vue.component('game-intro', {
  // data: function(){
  //   return {
  //     evQuestions: evQuestions,
  //     questionInd: 0,

  //     isGameComplete: false,
  //   };
  // },
  // computed: {
  //   visibleQuestions: function(){
  //     return this.evQuestions.slice(0, this.questionInd+1);      
  //   },
  // },
  // watch: {
  //   visibleQuestions: scrollWindow,
  //   isGameComplete: scrollWindow
  // },
  // methods: {
  //   onQuestionComplete: function(params){
  //     this.questionInd++;
  //     // this.numUserMoneybags += params.numMoneybagsGained;

  //     // if (this.numUserMoneybags == this.numMoneybagsNeeded){
  //     //   // todo: trigger game end
  //     //   this.gameOutcome = 'userWon';        
  //     // } else if (this.questionInd == this.monkQuestions.length){
  //     //   // todo: trigger game end
  //     //   this.gameOutcome = 'monkOutOfQuestions';
  //     // } else {
  //     //   this.questionInd++;        
  //     // }
  //   },
  // },
  template: '#game-intro-template',
});



Vue.component('cat-forest', {
  // data: function(){
  //   return {
  //     evQuestions: evQuestions,
  //     questionInd: 0,

  //     isGameComplete: false,
  //   };
  // },
  // computed: {
  //   visibleQuestions: function(){
  //     return this.evQuestions.slice(0, this.questionInd+1);      
  //   },
  // },
  // watch: {
  //   visibleQuestions: scrollWindow,
  //   isGameComplete: scrollWindow
  // },
  // methods: {
  //   onQuestionComplete: function(params){
  //     this.questionInd++;
  //     // this.numUserMoneybags += params.numMoneybagsGained;

  //     // if (this.numUserMoneybags == this.numMoneybagsNeeded){
  //     //   // todo: trigger game end
  //     //   this.gameOutcome = 'userWon';        
  //     // } else if (this.questionInd == this.monkQuestions.length){
  //     //   // todo: trigger game end
  //     //   this.gameOutcome = 'monkOutOfQuestions';
  //     // } else {
  //     //   this.questionInd++;        
  //     // }
  //   },
  // },
  template: '#cat-forest-template',
});

var evQuestions = [

  [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}],

  [{certainty: 0.1, hp:14}, {certainty: 0.3, hp:13}, {certainty: 0.4, hp:12}, {certainty: 0.2, hp:11}],

  [{certainty: 0.8, hp:4}, {certainty: 0.2, hp:3}],

];

Vue.component('distribution-interlude', {
  data: function(){
    return {
      evQuestions: evQuestions,
      questionInd: 0,

      isGameComplete: false,
    };
  },
  computed: {
    visibleQuestions: function(){
      return this.evQuestions.slice(0, this.questionInd+1);      
    },
  },
  watch: {
    visibleQuestions: scrollWindow,
    isGameComplete: scrollWindow
  },
  methods: {
    onQuestionComplete: function(params){
      this.questionInd++;
      // this.numUserMoneybags += params.numMoneybagsGained;

      // if (this.numUserMoneybags == this.numMoneybagsNeeded){
      //   // todo: trigger game end
      //   this.gameOutcome = 'userWon';        
      // } else if (this.questionInd == this.monkQuestions.length){
      //   // todo: trigger game end
      //   this.gameOutcome = 'monkOutOfQuestions';
      // } else {
      //   this.questionInd++;        
      // }
    },
  },
  template: '#distribution-interlude-template',
});

Vue.component('forest-outcomes', {
  props: {
    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
    certaintyAs: {type: String, default: 'percent'}, // 'odds'
  },
  data: function(){
    return {
      animatedInd: null,
    };
  },
  computed: {
    outcomeColors: function(){
      var colors = _.times(this.outcomes.length, () => 'transparent');
      if (this.animatedInd !== null){
         colors[this.animatedInd] = '#ccc';
      }
      return colors;
    }
  },

  methods: {
    drawOutcome: async function(){
      var numCycles = 3;
      var outcomeInd = drawIndFromOutcomes(this.outcomes);
      var numIters = numCycles*this.outcomes.length+outcomeInd -1;

      // milliseconds
      var activeTimes = this.outcomes.map(outcome => outcome.certainty * 500);

      // Each outcome is active for a different length of time.
      for (var i=0; i<numIters; i++){
        var animatedInd = i % activeTimes.length;
        this.animatedInd = animatedInd;
        await wait(activeTimes[animatedInd]);

        // Check if it's the last one and emit an event.
        if (i == numIters-1){
          console.log('outcome ind: ' + outcomeInd)
          this.$emit('outcome-drawn', {outcomeInd: outcomeInd});
        }
      }
    },

    renderCertainty: function(certainty){
      if (this.certaintyAs == 'percent'){
        return this.$root.renderAsPercent(certainty) + ' chance';        
      } else if (this.certaintyAs == 'odds'){
        var params = this.$root.paramsFromCertainty(certainty);
        // stopped here figuring out how we want to render x parts chance
        // could hardcode it? 
        return 'nope'; 
      } else{
        console.error('unrecognized certaintyAs: ' + this.certaintyAs);
      }
    },

  },
  template: '#forest-outcomes-template',
});


function outcomesMean(outcomes){
  return sum(outcomes.map(outcome => outcome.certainty * outcome.hp));
}

function outcomesVariance(outcomes){
  var mean_hp = outcomesMean(outcomes);
  return sum(outcomes.map(outcome => outcome.certainty * (outcome.hp - mean_hp) * (outcome.hp - mean_hp)));
}

function outcomesStd(outcomes){
  return Math.sqrt(outcomesVariance(outcomes));
}

Vue.component('visual-ev-click', {
  props: {
    outcomes: {type: Array, default: () => [{certainty: 0.1, hp:4}, {certainty: 0.3, hp:3}, {certainty: 0.4, hp:2}, {certainty: 0.2, hp:1}] },
  },
  data: function(){
    return {
      isMouseover: false,

      mouseX: null,  // tracks mouse position always

      guessPx: null, // populated when user clicks
      guessReal: null, // populated when user clicks

      answerPx: null, // populated after delay when user clicks
      answerReal: null, // populated after delay when user clicks
    };
  },

  computed: {
    trackerStyle: function(){
      return {
        left: (this.guessPx !== null ? this.guessPx : this.mouseX) + 'px'
      };
    },

    isUserClose: function(){
      // Is close if it's less than X% away from the true answer
      var distribution_component = this.$refs['distribution'];
      var total = distribution_component.xMax - distribution_component.xMin;

      var difference = Math.abs(this.answerReal - this.guessReal);
      return difference / total < .05;
    }
  },

  methods: {
    distributionClicked: function(event){
      var distribution_component = this.$refs['distribution'];
      var stats = distribution_component.stats;
      var xScale = distribution_component.xScale;


      this.guessPx = this.getRelativeMouseX(event);
      this.guessReal = xScale.invert(this.guessPx);

      // answerPx gets animated into the correct position.
      this.answerPx = this.guessPx;
      var this_ = this;
      setTimeout(function(){
        // Make the answer bar to animate.
        this_.answerPx = xScale(stats.mean);

        // Make the text to show.
        setTimeout(() => this_.answerReal = stats.mean, 1000);
      }, 200);

    },

    getRelativeMouseX: function(event){
      // https://stackoverflow.com/questions/5921413/difference-between-e-target-and-e-currenttarget
      // e.target is what triggers the event dispatcher to trigger and e.currentTarget is what you assigned your listener to.

      // Find the 'dist' element to compute relative mouse coords.
      var refElement = event.target;
      while (refElement.className !== 'dist'){
        refElement = refElement.parentElement;
      }

      // console.log(event.target.className + ' ' + event.clientX + '      ' + refElement.className + JSON.stringify(refElement.getBoundingClientRect()));        
      return event.clientX - refElement.getBoundingClientRect().x;
    },

  },
  template: '#visual-ev-click-template',
});

// outcomes = [
//  {certainty: 0.4, hp: 15, caption: 'warmth'}, 
//  {certainty: 0.6, hp: 0, caption: 'you fail to start the fire'}
// ]
Vue.component('distribution', {
  props: {
    outcomes: {type: Array, required: true},
    // barWidth: {type: Number, default: 50},

    chartHeight: {type: Number, default: 160},
    chartWidth: {type: Number, default: 400},

    xAttr: {type: String, default: 'hp'},
    yAttr: {type: String, default: 'certainty'},

    // If we want the x-axis to be the same between problems, so
    // hardcode it here.
    xMin: {type: Number, default: -10},
    xMax: {type: Number, default: 10},
    // Uses xMin and xMax if false, otherwise fits to smallest xMin and xMax.
    fittedX: {type: Boolean, default: false},
    showMean: {type: Boolean, default: false},
    showStd: {type: Boolean, default: false},

    margin: {
      type: Object, 
      default: function(){
        return {top: 0, right: 0, bottom: 0, left: 20};
      }
    },
  },
  computed: {
    barWidth: function(){
      var domain = this.domain;
      return (this.chartWidth - this.margin.left - this.margin.right) / (domain[1] - domain[0]);
    },
    domain: function(){
      // Note: we adjust for barWidth within barStyle.
      var xVals = _.map(this.outcomes, outcome => outcome[this.xAttr]);
      return this.fittedX ? [_.min(xVals), _.max(xVals)] : [this.xMin, this.xMax];
    },
    xScale: function(){
      return d3.scaleLinear()
        .domain(this.domain)
        .range([this.margin.left, this.chartWidth-this.margin.right]);
    },

    yScale: function(){
      return d3.scaleLinear()
        .domain([0, 1])
        .range([this.margin.bottom, this.chartHeight-this.margin.top]);
    },
    stats: function(){
      return {
        mean: outcomesMean(this.outcomes), 
        std: outcomesStd(this.outcomes),
      }      
    },
    meanStyle: function(){
      return {
        left: this.xScale(this.stats.mean) + 'px',
      }
    }, 
    stdStyle: function(){
      var width = this.stats.std * this.barWidth; 
      return {
        // left: this.meanStyle.left,
        width: width + 'px',
      }
    }
  },

  data: function(){
    return {
      animatedInd: null,
    }
  },

  methods: {
    renderAsPercent: renderAsPercent,
    barStyle: function(outcome, barIndex){
      return {
        width: this.barWidth + 'px',
        height: this.yScale(outcome[this.yAttr]) + 'px',
        left: (this.xScale(outcome[this.xAttr]) - this.barWidth / 2) + 'px',
        'background-color': barIndex === this.animatedInd ? 'blue': 'orange'
      };
    },

    // todo: dedup?
    drawOutcome: async function(){
      var numCycles = 5;
      var outcomeInd = drawIndFromOutcomes(this.outcomes);
      var numIters = numCycles*this.outcomes.length+outcomeInd -1;

      // milliseconds
      var activeTimes = this.outcomes.map(outcome => outcome.certainty * 500);

      // Each outcome is active for a different length of time.
      for (var i=0; i<numIters; i++){
        var animatedInd = i % activeTimes.length;
        this.animatedInd = animatedInd;
        await wait(activeTimes[animatedInd]);

        // Check if it's the last one and emit an event.
        if (i == numIters-1){
          this.$emit('outcome-drawn', {outcomeInd: outcomeInd});
        }
      }
    },

  },
  template: '#distribution-template'
});

// Useful for hiding logic inside of a v-if.
// e.g.
// <div v-if="isUserReallyCorrect">
//   <hidden>{{numMoneybagsGained = 10}}</hidden>
// </div>
Vue.component('hidden', {
  template: `<span style="display:none"><slot></slot></span>`,
});


// Can be used to delay logic
// <delay :delayFn="() => show('wrong-basic')"></delay>
Vue.component('delay', {
  props: {
    delay: {type: Number, default: 500},
    delayFn: {type: Function, required: true},
  },
  mounted: function(){
    var this_ = this;
    setTimeout(function(){
      this_.delayFn();
    }, this.delay);
  },
  template: `<span style="display:none"></span>`,
});

// https://jsfiddle.net/39hkrot0/5/
Vue.component('once-group', {
  data: function(){
    return {
      isClicked: false
    }
  },
  template: `<div><slot></slot></div>`,
  methods: {

    childClicked: function(childComponent) {
      if (this.isClicked){
        return;
      }
      this.isClicked = true;

      // Change the buttons to indicate that it is disabled.
      var this_ = this;
      this.$slots.default.forEach((item, index) => {
        if (item.tag) {
          // var button_value = item.componentInstance.$props.value;
          // if (button_value === this_.userAnswer){
          if (childComponent === item.componentInstance){
            item.elm.classList.add('clicked-button');
          } else {
            item.elm.setAttribute('disabled', true); 
          }
        }
      });
    }
  }
});

// once-button must live inside a once-group
// The once-group enforces that only one child can be called once.
Vue.component('once-button', {
  data: function(){
    return {
      self: this
    }
  },
  template: '<game-button @click.native="$parent.childClicked(self)"><slot></slot></game-button>'
});

// game-button differs from once-button, in that it doesn't live in a 
// special parent.
// If a game-button is clicked, it's siblings may still be clicked.
// game-button just provides a color to the user whether the guess was
// correct or not
Vue.component('game-button', {
  props: {    
    isRight: {type: Boolean, default: null},
  },
  data: function(){
    return {
      isClicked: false,
    };
  },
  methods: {
    buttonClicked: function(){      
      if (this.isClicked === true){
        return;
      }; 
      this.$root.play('heal');
      this.isClicked = true;
    }
  },
  template: `<button @click="buttonClicked()" 
                    :class="{'clicked-button' : isClicked, 'right-answer': isClicked===true && isRight===true,
                      'wrong-answer': isClicked===true && isRight===false }"
                    class="game-button"
                    ><slot></slot></button>`
});


// https://jsfiddle.net/jamesbrndwgn/85h6n1q9/14/
Vue.component('stagger', {
  props: {
    interval: {type: Number, default: 1000},
  },

  mounted: function(){
    var this_ = this;
    this.$slots.default.forEach((item, index) => {
      // item: VNode
      if (item.tag) { // item.tag: 'div'
        item.elm.classList.add('fade-from'); // item.elm: <div>sup</div>

        setTimeout(() => {
          item.elm.classList.remove('fade-from');
          item.elm.classList.add('fade-in', 'fade-to');
          scrollWindow();

          // trigger that the animation is complete
          if (index == this_.$slots.default.length - 1){
            setTimeout(function(){
              this_.$emit('stagger-complete');
            }, this_.interval);
          }
        }, this_.interval + (index*this_.interval));
      }
    });

    // use setTimeout instead of setInteval
    // todo: look at JS () => {}
  },
  template: `<div><slot></slot></div>`
});

// A component where you give it
// ['Hm', '.', '.', '.', '.', '.']
// and it uses setInterval + data to animate.
// Also trigger an event when it's done? 
Vue.component('text-animation', {
  props: {
    text: {type: String}, // Can pass in 'Hm...'
    tokens: {type: Array}, // Or ['Hm', '.', '.', '.', '.', '.']
    interval: {type: Number, default: 500},
  },
  data: function(){
    return {
      visibleText: '',
    };
  },
  created: function(){
    var current_ind = 0;
    var this_ = this;
    const tokens = this.tokens ? this_.tokens : this.text.split('');

    function animation(){
      // Add one token at a time
      // console.log('current_ind: ' + current_ind);
      // console.log('this_.tokens: ' + this_.tokens);
      this_.visibleText = tokens.slice(0, current_ind).join('');
      current_ind++;

      if (current_ind > tokens.length+1){
        clearInterval(animation_timer);
        setTimeout(function(){
          this_.$emit('text-animation-complete');
        }, 500);
      }
    }
    animation();
    var animation_timer = setInterval(animation, this.interval);
  },
  template: '#text-animation-template'
});


// Hides content until it is revealed as part of the story.
Vue.component('story', {
  props: {
    visible: {type: Boolean, default:false},
  },
  data: function(){
    return {
      isVisible: this.visible,
    };
  },
  watch: {
    isVisible: scrollWindow,
  },
  template: '#story-template'
});


Vue.component('slider-guess', {
  // props: {
  //   visible: {type: Boolean, default:false},
  // },
  // data: function(){
  //   return {
  //     isVisible: this.visible,
  //   };
  // },
  // watch: {
  //   isVisible: scrollWindow,
  // },
  template: '#slider-guess-template'
});


/*

How should this work:
- split the text into words
- inject the words in via setinterval
- add a transition component that makes it fade in when it is injected
*/
Vue.component('live-text', {
  props: {
    interval: {type: Number, default: 1000},
  },

  render: function (createElement) {
    var data = [];
//    debugger;

    for (var i=0; i<this.$slots.default.length; i++){
      var vnode = this.$slots.default[i];

      if (vnode.tag){
        data.push([vnode.tag, vnode.data, vnode.children])
      } else if (vnode.text){
        var tokens = vnode.text.split(' ').filter(token => token);
        data = _.concat(data, tokens.map(token => ['span', {}, token + ' ']));
      }
    }

    var vnodes = data.map(function(tuple, i){
      const tag = tuple[0];
      const nodeData = tuple[1];
      const children = tuple[2];
      const meta = {
        ref: i, 
        class: { 'hidden-at-first': true }
      };

      return createElement(tag, _.merge(meta, nodeData), children);
    });

    return createElement(
      'div',   // tag name
      vnodes, 
    )
  },

  data: function(){
    return {
      visibleTokens: [],
    };
  },

  mounted: async function(){
    var elts = _.values(this.$refs);
    var lastSentence = [];
    var currentSentence = [];

    for (var i=0; i<elts.length; i++){
      var elt = elts[i];
      currentSentence.push(elt);
      elt.style.opacity = 1;

      const isEndOfSentence = elt.textContent && elt.textContent.includes('.');
      const duration = isEndOfSentence ? 1000 : 100;
      await wait(duration);

// Fading by words.
//      elt.style.opacity = 0.5;

// Fading by sentences.
      // console.log('i: ' + i + ' len ' + elts.length);
      if (isEndOfSentence){
        lastSentence = currentSentence;
        currentSentence = [];
        // Fade the lastSentence away.
        await(2000);
        for (var j=0; j<lastSentence.length; j++){
          elt.classList.remove('hidden-at-first');
          elt.classList.add('become-dull');
          lastSentence[j].style.opacity = 0.5;
          await wait(50);
        }          
      }
    }
  },

  template: '#live-text-template'
});

var storyPoints = [
// {
//   name: 'Monk Intro',
//   component: 'monk-intro',
// },
// {
//   name: 'Monk Game',
//   component: 'monk-game',
// },
// {
//   name: 'Forest Intro',
//   component: 'forest-intro',
// },
// {
//   name: 'Forest Game',
//   component: 'forest-game',
// },
// {
//   name: 'Distribution Interlude',
//   component: 'distribution-interlude',
//   nest: 1
// },
{
  name: 'Intro',
  component: 'game-intro',
},
{
  name: 'Cats',
  component: 'cat-forest',
},


];

// Gotchas:
// DOM does not update for new property additions.
// DOM does not update for direct assignments within arrays.
// https://vuejs.org/2016/02/06/common-gotchas/#Why-isn%E2%80%99t-the-DOM-updating  
new Vue({
  el: '#app',
  data: {

    storyPoints: storyPoints,
    currentStoryPoint: storyPoints[0],

    // Obj property additions do not update DOM, so prepopulate all the keys in the object. Or use lists.
    soundNameToCount: {},
  },

  watch: {
    currentStoryPoint: function(){
      this.$root.play('swish');
    },
  },

  methods: {
    show: show, 
    renderAsPercent: renderAsPercent,

    // round_to(2.777777, 0) -> 3
    // round_to(2.777777, 2) -> 2.78
    roundTo: roundTo,

    // Changes tabs.
    setStoryPoint: function(component_name){
      var story_point = _.filter(storyPoints, {component: component_name});
      if (story_point.length !== 1){
        console.error('must match exactly one story point');
        debugger;
      }
      this.currentStoryPoint = story_point[0];
      this.play('achievement0');
    },

    // Given 0.8 --> returns {}
    paramsFromCertainty: function(certainty){
      if (certainty == 1.0){
        return {
          numLoseIfWrong: 10000000, 
          numWinIfRight: 1,
          certainty: certainty,
          percent: '100%',
        };
      }
      return {
        numWinIfRight: 1, 
        numLoseIfWrong: this.roundTo(certainty/(1-certainty), 1),
        certainty: certainty,
        percent: this.renderAsPercent(certainty)
      };      
    },

    paramsFromBet: function(num_win_if_right, num_lose_if_wrong){
      var certainty = num_lose_if_wrong/(num_win_if_right+num_lose_if_wrong);
      return this.paramsFromCertainty(certainty);
    },

    storyPointStyle: function(storyPoint){
      if (storyPoint.nest === undefined){
        return {};
      }
      return {
        'margin-left': storyPoint.nest * 8 + 'px',
        'font-size': '12px'
      };
    },

    play: function(soundName){
      console.log('playing ' + soundName);

      var audio;
      if (isNaN(soundName[soundName.length-1])){ // is string last char
        const count = this.soundNameToCount[soundName] || 0;
        this.soundNameToCount[soundName] = count+1;
        audio = new Audio('sounds/' + soundName + (count % 2) + '.wav');
      } else { // is number last char
        audio = new Audio('sounds/' + soundName + '.wav');
      }
      audio.play();      
    }
  } // end methods
});


</script>